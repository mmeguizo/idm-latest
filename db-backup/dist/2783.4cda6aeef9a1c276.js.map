{"version":3,"file":"2783.4cda6aeef9a1c276.js","mappings":"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","names":["ThLargeIcon","BaseIcon","pathId","ngOnInit","this","UniqueComponentId","static","ɵThLargeIcon_BaseFactory","t","i0","type","selectors","standalone","features","decls","vars","consts","template","rf","ctx","getClassNames","ariaLabel","ariaHidden","role","encapsulation","DataView_div_1_i_2_Template","ctx_r7","loadingIcon","DataView_div_1_ng_container_3_SpinnerIcon_1_Template","DataView_div_1_ng_container_3_2_ng_template_0_Template","DataView_div_1_ng_container_3_2_Template","DataView_div_1_ng_container_3_Template","ctx_r8","loadingIconTemplate","DataView_div_1_Template","ctx_r0","DataView_div_2_ng_container_2_Template","DataView_div_2_Template","ctx_r1","headerTemplate","DataView_p_paginator_3_Template","_r14","$event","ctx_r13","paginate","ctx_r2","rows","first","totalRecords","pageLinks","alwaysShowPaginator","rowsPerPageOptions","paginatorDropdownAppendTo","paginatorDropdownScrollHeight","paginatorLeftTemplate","paginatorRightTemplate","currentPageReportTemplate","showFirstLastIcon","paginatorDropdownItemTemplate","showCurrentPageReport","showJumpToPageDropdown","showPageLinks","paginatorStyleClass","DataView_ng_container_5_Template","DataView_div_7_ng_container_2_Template","ctx_r15","emptyMessageLabel","DataView_div_7_ng_container_3_Template","DataView_div_7_Template","ctx_r4","emptyMessageTemplate","empty","DataView_p_paginator_8_Template","_r19","ctx_r18","ctx_r5","DataView_div_9_ng_container_2_Template","DataView_div_9_Template","ctx_r6","footerTemplate","_c0","_c1","a1","a2","_c2","a0","$implicit","_c3","DataViewLayoutOptions_BarsIcon_2_Template","DataViewLayoutOptions_3_ng_template_0_Template","DataViewLayoutOptions_3_Template","DataViewLayoutOptions_ThLargeIcon_5_Template","DataViewLayoutOptions_6_ng_template_0_Template","DataViewLayoutOptions_6_Template","_c4","DataView","el","cd","filterService","config","paginator","paginatorPosition","lazy","lazyLoadOnInit","emptyMessage","style","styleClass","gridStyleClass","trackBy","index","item","filterBy","filterLocale","loading","sortField","sortOrder","value","layout","_layout","initialized","changeLayout","onLazyLoad","EventEmitter","onPage","onSort","onChangeLayout","header","footer","templates","_value","listTemplate","gridTemplate","itemTemplate","listIconTemplate","gridIconTemplate","filteredValue","filterValue","translationSubscription","getTranslation","TranslationKeys","EMPTY_MESSAGE","constructor","emit","createLazyLoadMetadata","translationObserver","subscribe","markForCheck","ngOnChanges","simpleChanges","currentValue","updateTotalRecords","hasFilter","filter","sort","ngAfterContentInit","forEach","getType","updateItemTemplate","length","event","data1","data2","value1","ObjectUtils","resolveFieldData","value2","result","localeCompare","isEmpty","data","getBlockableElement","nativeElement","children","filterMatchMode","searchFields","split","trim","ngOnDestroy","unsubscribe","i1","contentQueries","dirIndex","Header","Footer","PrimeTemplate","_t","hostAttrs","inputs","outputs","ngContentSelectors","dependencies","i2","i3","SpinnerIcon","styles","changeDetection","DataViewLayoutOptions","dv","preventDefault","BarsIcon","DataViewModule","imports","CommonModule","SharedModule","PaginatorModule","coerceNumberProperty","fallbackValue","_isNumberValue","isNaN","parseFloat","Number","coerceElement","elementOrRef","ElementRef","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","target","eventName","options","resultSelector","isFunction","undefined","pipe","mapOneOrManyArgs","add","remove","isEventTarget","addEventListener","removeEventListener","map","methodName","handler","isNodeStyleEventEmitter","addListener","removeListener","toCommonHandlerRegistry","isJQueryStyleEventEmitter","on","off","isArrayLike","mergeMap","subTarget","innerFrom","TypeError","Observable","subscriber","args","next","animationFrameProvider","schedule","callback","request","requestAnimationFrame","cancel","cancelAnimationFrame","delegate","handle","timestamp","Subscription","animationFrameScheduler","AnimationFrameScheduler","AsyncScheduler","flush","action","_active","flushId","_scheduled","actions","error","shift","execute","state","delay","id","AnimationFrameAction","AsyncAction","scheduler","work","super","requestAsyncId","push","recycleAsyncId","_a","resolved","nextHandle","activeHandles","findAndClearHandle","Immediate","setImmediate","cb","Promise","resolve","then","clearImmediate","immediateProvider","AsapScheduler","AsapAction","bind","auditTime","duration","asyncScheduler","audit","durationSelector","operate","source","hasValue","lastValue","durationSubscriber","isComplete","endDuration","complete","cleanupDuration","createOperatorSubscriber","closed","timer","hasV8BreakIterator","Intl","v8BreakIterator","supportsPassiveEvents","shadowDomIsSupported","Platform","_platformId","isBrowser","isPlatformBrowser","document","EDGE","test","navigator","userAgent","TRIDENT","BLINK","window","chrome","CSS","WEBKIT","IOS","FIREFOX","ANDROID","SAFARI","ɵfac","PLATFORM_ID","ɵprov","token","factory","providedIn","normalizePassiveListenerOptions","supportsPassiveEventListeners","Object","defineProperty","get","capture","_getShadowRoot","element","_supportsShadowDom","head","createShadowRoot","attachShadow","rootNode","getRootNode","ShadowRoot","_getEventTarget","composedPath","ScrollDispatcher","_ngZone","_platform","_scrolled","Subject","_globalSubscription","_scrolledCount","scrollContainers","Map","_document","register","scrollable","has","set","elementScrolled","deregister","scrollableReference","delete","scrolled","auditTimeInMs","observer","_addGlobalListener","subscription","_removeGlobalListener","of","_","container","ancestorScrolled","elementOrElementRef","ancestors","getAncestorScrollContainers","indexOf","scrollingContainers","_subscription","_scrollableContainsElement","_getWindow","defaultView","scrollableElement","getElementRef","parentElement","runOutsideAngular","DOCUMENT","ViewportRuler","ngZone","_change","_changeListener","change","_viewportSize","getViewportSize","_updateViewportSize","output","width","height","getViewportRect","scrollPosition","getViewportScrollPosition","top","left","bottom","right","documentElement","documentRect","getBoundingClientRect","body","scrollTop","scrollY","scrollLeft","scrollX","throttleTime","innerWidth","innerHeight","CdkScrollableModule","ɵmod","ɵinj","DIR_DOCUMENT","InjectionToken","DIR_DOCUMENT_FACTORY","inject","RTL_LOCALE_PATTERN","Directionality","_resolveDirectionality","rawValue","toLowerCase","language","dir","extendStyles","dest","importantProperties","key","hasOwnProperty","setProperty","removeProperty","toggleNativeDragInteractions","enable","userSelect","toggleVisibility","position","opacity","combineTransforms","transform","initialTransform","parseCssTimeUnitsToMs","multiplier","parseCssPropertyValue","computedStyle","name","getPropertyValue","part","getMutableClientRect","clientRect","x","y","isInsideClientRect","adjustClientRect","isPointerNearClientRect","rect","threshold","pointerX","pointerY","xThreshold","yThreshold","ParentPositionTracker","positions","clear","cache","elements","handleScroll","cachedPosition","newTop","newLeft","viewportScrollPosition","topDifference","leftDifference","node","contains","deepCloneNode","clone","cloneNode","descendantsWithId","querySelectorAll","nodeName","removeAttribute","i","transferCanvasData","transferInputData","transferData","selector","descendantElements","cloneElements","cloneUniqueId","context","getContext","drawImage","passiveEventListenerOptions","passive","activeEventListenerOptions","dragImportantProperties","Set","DragRef","disabled","_disabled","_dropContainer","_toggleNativeDragInteractions","_handles","_config","_viewportRuler","_dragDropRegistry","_passiveTransform","_activeTransform","_hasStartedDragging","_moveEvents","_pointerMoveSubscription","EMPTY","_pointerUpSubscription","_scrollSubscription","_resizeSubscription","_boundaryElement","_nativeInteractionsEnabled","_disabledHandles","_direction","dragStartDelay","beforeStarted","started","released","ended","entered","exited","dropped","moved","_pointerDown","targetHandle","_getTargetHandle","_initializeDragSequence","_rootElement","_pointerMove","pointerPosition","_getPointerPositionOnPage","Math","abs","_pickupPositionOnPage","dragStartThreshold","isDelayElapsed","Date","now","_dragStartTime","_getDragStartDelay","_endDragSequence","isDragging","isReceiving","run","_startDragSequence","constrainedPointerPosition","_getConstrainedPointerPosition","_hasMoved","_lastKnownPointerPosition","_updatePointerDirectionDelta","_updateActiveDropContainer","offset","constrainPosition","_initialClientRect","activeTransform","_applyRootElementTransform","observers","distance","_getDragDistance","delta","_pointerDirectionDelta","_pointerUp","_nativeDragStart","withRootElement","withParent","parentDragRef","_parentPositions","registerDragItem","getPlaceholderElement","_placeholder","getRootElement","getVisibleElement","withHandles","handles","disabledHandles","withPreviewTemplate","_previewTemplate","withPlaceholderTemplate","_placeholderTemplate","rootElement","_removeRootElementListeners","_initialTransform","SVGElement","_ownerSVGElement","ownerSVGElement","withBoundaryElement","boundaryElement","_containInsideBoundaryOnResize","parent","_parentDragRef","dispose","_anchor","_destroyPreview","_destroyPlaceholder","removeDragItem","_removeSubscriptions","reset","disableHandle","enableHandle","withDirection","direction","_withDropContainer","getFreeDragPosition","setFreeDragPosition","withPreviewContainer","_previewContainer","_sortFromLastPointerPosition","_preview","_previewRef","destroy","_placeholderRef","stopDragging","webkitTapHighlightColor","_rootElementTapHighlight","_stopScrolling","_animatePreviewToPlaceholder","_cleanupDragArtifacts","_cleanupCachedDimensions","dropPoint","isTouchEvent","_lastTouchEventTime","dropContainer","parentNode","placeholder","_createPlaceholderElement","anchor","createComment","shadowRoot","insertBefore","_createPreviewElement","appendChild","replaceChild","_getPreviewInsertionPoint","start","_initialContainer","_initialIndex","getItemIndex","getScrollableParents","referenceElement","stopPropagation","isTouchSequence","isAuxiliaryMouseButton","button","isSyntheticEvent","isFakeEvent","isFakeTouchstartFromScreenReader","touch","touches","changedTouches","identifier","radiusX","radiusY","isFakeMousedownFromScreenReader","buttons","detail","draggable","rootStyles","pointerMove","pointerUp","scrollEvent","_updateOnScroll","_boundaryRect","previewTemplate","_pickupPositionInElement","matchSize","_getPointerPositionInElement","_pointerPositionAtLastDirectionChange","startDragging","_previewRect","currentIndex","isPointerOverContainer","_isOverContainer","previousIndex","previousContainer","drop","rawX","rawY","newContainer","_getSiblingContainerFromPosition","exit","enter","sortingDisabled","_startScrollingIfNecessary","_sortItem","_applyPreviewTransform","previewConfig","previewClass","preview","rootRect","viewRef","viewContainer","createEmbeddedView","detectChanges","matchElementSize","getTransform","margin","zIndex","classList","setAttribute","Array","isArray","className","placeholderRect","getTransformTransitionDurationInMs","getComputedStyle","transitionedProperties","property","find","prop","propertyIndex","rawDurations","rawDelays","propertyName","clearTimeout","timeout","setTimeout","placeholderConfig","placeholderTemplate","pointerEvents","elementRect","handleElement","referenceRect","point","targetTouches","_getViewportScrollPosition","pageX","pageY","svgMatrix","getScreenCTM","svgPoint","createSVGPoint","matrixTransform","inverse","dropContainerLock","lockAxis","pickupX","pickupY","boundaryRect","previewWidth","previewHeight","_getPreviewRect","minY","maxY","clamp$1","pointerPositionOnPage","positionSinceLastChange","changeX","changeY","pointerDirectionChangeThreshold","shouldEnable","currentPosition","pickupPosition","leftOverflow","rightOverflow","topOverflow","bottomOverflow","mouse","scrollDifference","_cachedShadowRoot","initialParent","previewContainer","documentRef","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","round","min","max","rootNodes","nodeType","ELEMENT_NODE","wrapper","createElement","sourceRect","moveItemInArray","array","fromIndex","toIndex","from","clamp","to","transferArrayItem","currentArray","targetArray","targetIndex","splice","SingleAxisSortStrategy","_element","_itemPositions","orientation","_previousSwap","drag","overlaps","items","withItems","pointerDelta","siblings","newIndex","_getItemIndexFromPointerPosition","isHorizontal","findIndex","currentItem","siblingAtNewPosition","newPosition","itemOffset","_getItemOffsetPx","siblingOffset","_getSiblingOffsetPx","oldOrder","slice","sibling","isDraggedItem","elementToOffset","activeDraggables","_activeDraggables","newPositionReference","_shouldEnterAsFirstChild","_cacheItemPositions","withSortPredicate","predicate","_sortPredicate","p","getActiveItemsSnapshot","reverse","updateOnScroll","elementToMeasure","a","b","immediateSibling","end","itemPositions","lastItemRect","firstItemRect","floor","DropListRef","autoScrollDisabled","autoScrollStep","enterPredicate","sortPredicate","sorted","receivingStarted","receivingStopped","_isDragging","_draggables","_siblings","_activeSiblings","_viewportScrollSubscription","_verticalScrollDirection","_horizontalScrollDirection","_stopScrollTimers","_startScrollInterval","interval","takeUntil","_scrollNode","scrollStep","scrollBy","withScrollableParents","registerDropContainer","_sortStrategy","removeDropContainer","_draggingStarted","_notifyReceivingSiblings","_cacheParentPositions","_reset","previousItems","every","connectedTo","withOrientation","_scrollableElements","size","_clientRect","scrollNode","verticalScrollDirection","horizontalScrollDirection","getElementScrollDirections","computedVertical","getVerticalScrollDirection","computedHorizontal","getHorizontalScrollDirection","scrollHeight","clientHeight","scrollWidth","clientWidth","_initialScrollSnap","msScrollSnapType","scrollSnapType","_listenToScrollEvents","_stopReceiving","_canReceive","elementFromPoint","_startReceiving","activeSiblings","initiator","receiver","draggedItems","activeCapturingEventOptions","DragDropRegistry","_dropInstances","_dragInstances","_activeDragInstances","_globalListeners","_draggingPredicate","scroll","_preventDefaultWhileDragging","_persistentTouchmoveListener","some","startsWith","e","_clearGlobalListeners","streams","eventOptions","merge","instance","DEFAULT_CONFIG","DragDrop","createDrag","createDropList","CDK_DRAG_PARENT","CDK_DRAG_HANDLE","CDK_DRAG_PLACEHOLDER","CDK_DRAG_PREVIEW","CDK_DRAG_CONFIG","CDK_DROP_LIST","CdkDrag","_dragRef","_viewContainerRef","_dir","dragDrop","_changeDetectorRef","_selfHandle","_parentDrag","_destroyed","movedEvent","_assignDefaults","_dropListRef","addItem","_syncInputs","_handleEvents","ngAfterViewInit","onStable","take","_updateRootElement","_setupHandlesListener","freeDragPosition","changes","rootSelectorChange","rootElementSelector","positionChange","firstChange","removeItem","closest","_getBoundaryElement","boundary","ref","templateRef","startEvent","releaseEvent","endEvent","enterEvent","exitEvent","dropEvent","draggingDisabled","startWith","tap","childHandleElements","switchMap","_stateChanges","handleInstance","dragRef","i1$1","ɵdir","hostVars","hostBindings","booleanAttribute","exportAs","provide","useExisting","CDK_DROP_LIST_GROUP","CdkDropListGroup","_items","_uniqueIdCounter","CdkDropList","_dropLists","_group","_scrollDispatcher","_unsortedItems","_setupInputSyncSubscription","_syncItemsWithRef","getSortedItems","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","coerceArray","list","_scrollableParentsResolved","scrollableParents","listAutoScrollDisabled","listOrientation","useValue","DragDropModule","providers","AngleDoubleDownIcon","ɵAngleDoubleDownIcon_BaseFactory","AngleDoubleUpIcon","ɵAngleDoubleUpIcon_BaseFactory","PickList_div_1_AngleUpIcon_2_Template","PickList_div_1_3_ng_template_0_Template","PickList_div_1_3_Template","PickList_div_1_AngleDoubleUpIcon_5_Template","PickList_div_1_6_ng_template_0_Template","PickList_div_1_6_Template","PickList_div_1_AngleDownIcon_8_Template","PickList_div_1_9_ng_template_0_Template","PickList_div_1_9_Template","PickList_div_1_AngleDoubleDownIcon_11_Template","PickList_div_1_12_ng_template_0_Template","PickList_div_1_12_Template","PickList_div_1_Template","_r33","ctx_r32","_r3","moveUp","selectedItemsSource","onSourceReorder","SOURCE_LIST","ctx_r34","moveTop","ctx_r35","moveDown","ctx_r36","moveBottom","sourceMoveDisabled","moveUpAriaLabel","moveUpIconTemplate","moveTopAriaLabel","moveTopIconTemplate","moveDownAriaLabel","moveDownIconTemplate","moveBottomAriaLabel","moveBottomIconTemplate","PickList_div_3_div_1_Template","ctx_r37","sourceHeader","PickList_div_3_ng_container_2_Template","PickList_div_3_Template","sourceHeaderTemplate","PickList_div_4_ng_container_1_ng_container_1_Template","PickList_div_4_ng_container_1_Template","ctx_r39","sourceFilterTemplate","sourceFilterOptions","PickList_div_4_ng_template_2_SearchIcon_3_Template","PickList_div_4_ng_template_2_span_4_1_ng_template_0_Template","PickList_div_4_ng_template_2_span_4_1_Template","PickList_div_4_ng_template_2_span_4_Template","ctx_r45","sourceFilterIconTemplate","PickList_div_4_ng_template_2_Template","_r49","ctx_r48","onFilter","ctx_r40","sourceFilterPlaceholder","ariaSourceFilterLabel","PickList_div_4_Template","_r41","PickList_ng_template_7_li_0_ng_container_1_Template","_c5","_c6","PickList_ng_template_7_li_0_Template","_r57","ctx_r56","item_r50","i_r51","ctx_r55","onItemClick","onSourceSelect","idSource","ctx_r58","onOptionMouseDown","ctx_r60","onSourceItemDblClick","ctx_r61","onItemTouchEnd","ctx_r62","ctx_r53","isSelected","itemClass","dragdrop","PickList_ng_template_7_Template","isItemVisible","PickList_ng_container_8_li_1_ng_container_1_Template","PickList_ng_container_8_li_1_Template","ctx_r63","emptyMessageSourceTemplate","PickList_ng_container_8_li_2_ng_container_1_Template","PickList_ng_container_8_li_2_Template","ctx_r64","emptyFilterMessageSourceTemplate","PickList_ng_container_8_Template","filterValueSource","PickList_ng_container_11_AngleRightIcon_1_Template","PickList_ng_container_11_AngleDownIcon_2_Template","PickList_ng_container_11_Template","viewChanged","PickList_12_ng_template_0_Template","PickList_12_Template","PickList_ng_container_14_AngleDoubleRightIcon_1_Template","PickList_ng_container_14_AngleDoubleDownIcon_2_Template","PickList_ng_container_14_Template","PickList_15_ng_template_0_Template","PickList_15_Template","PickList_ng_container_17_AngleLeftIcon_1_Template","PickList_ng_container_17_AngleUpIcon_2_Template","PickList_ng_container_17_Template","ctx_r10","PickList_18_ng_template_0_Template","PickList_18_Template","PickList_ng_container_20_AngleDoubleLeftIcon_1_Template","PickList_ng_container_20_AngleDoubleUpIcon_2_Template","PickList_ng_container_20_Template","ctx_r12","PickList_21_ng_template_0_Template","PickList_21_Template","PickList_div_23_div_1_Template","ctx_r79","targetHeader","PickList_div_23_ng_container_2_Template","PickList_div_23_Template","ctx_r14","targetHeaderTemplate","PickList_div_24_ng_container_1_ng_container_1_Template","PickList_div_24_ng_container_1_Template","ctx_r81","targetFilterTemplate","targetFilterOptions","PickList_div_24_ng_template_2_SearchIcon_3_Template","PickList_div_24_ng_template_2_span_4_1_ng_template_0_Template","PickList_div_24_ng_template_2_span_4_1_Template","PickList_div_24_ng_template_2_span_4_Template","ctx_r87","targetFilterIconTemplate","PickList_div_24_ng_template_2_Template","_r91","ctx_r90","TARGET_LIST","ctx_r82","targetFilterPlaceholder","ariaTargetFilterLabel","PickList_div_24_Template","_r83","PickList_ng_template_27_li_0_ng_container_1_Template","PickList_ng_template_27_li_0_Template","_r99","ctx_r98","item_r92","i_r93","ctx_r97","selectedItemsTarget","onTargetSelect","idTarget","ctx_r100","ctx_r102","onTargetItemDblClick","ctx_r103","ctx_r104","ctx_r95","PickList_ng_template_27_Template","ctx_r17","PickList_ng_container_28_li_1_ng_container_1_Template","PickList_ng_container_28_li_1_Template","ctx_r105","emptyMessageTargetTemplate","PickList_ng_container_28_li_2_ng_container_1_Template","PickList_ng_container_28_li_2_Template","ctx_r106","emptyFilterMessageTargetTemplate","PickList_ng_container_28_Template","filterValueTarget","PickList_div_29_AngleUpIcon_2_Template","PickList_div_29_3_ng_template_0_Template","PickList_div_29_3_Template","PickList_div_29_AngleDoubleUpIcon_5_Template","PickList_div_29_6_ng_template_0_Template","PickList_div_29_6_Template","PickList_div_29_AngleDownIcon_8_Template","PickList_div_29_9_ng_template_0_Template","PickList_div_29_9_Template","PickList_div_29_AngleDoubleDownIcon_11_Template","PickList_div_29_12_ng_template_0_Template","PickList_div_29_12_Template","PickList_div_29_Template","_r122","ctx_r121","_r16","onTargetReorder","ctx_r123","ctx_r124","ctx_r125","ctx_r19","targetMoveDisabled","_c7","_c8","PickList","platformId","renderer","tabindex","rightButtonAriaLabel","leftButtonAriaLabel","allRightButtonAriaLabel","allLeftButtonAriaLabel","upButtonAriaLabel","downButtonAriaLabel","topButtonAriaLabel","bottomButtonAriaLabel","responsive","sourceTrackBy","targetTrackBy","showSourceFilter","showTargetFilter","metaKeySelection","sourceStyle","targetStyle","showSourceControls","showTargetControls","stripedRows","keepSelection","breakpoint","_breakpoint","destroyMedia","initMedia","onMoveToSource","onMoveAllToSource","onMoveAllToTarget","onMoveToTarget","onSourceFilter","onTargetFilter","onFocus","onBlur","listViewSourceChild","listViewTargetChild","sourceFilterViewChild","targetFilterViewChild","translation","aria","moveToTargetAriaLabel","moveToTarget","moveAllToTargetAriaLabel","moveAllToTarget","moveToSourceAriaLabel","moveToSource","moveAllToSourceAriaLabel","moveAllToSource","focusedOptionId","focusedOptionIndex","moveToTargetIconTemplate","moveAllToTargetIconTemplate","moveToSourceIconTemplate","moveAllToSourceIconTemplate","visibleOptionsSource","visibleOptionsTarget","reorderedListElement","movedUp","movedDown","itemTouched","styleElement","fromListType","media","focusedOption","focused","sourceList","targetList","mediaChangeListener","createStyle","filterSource","resetSourceFilter","filterTarget","resetTargetFilter","ngAfterViewChecked","listItem","listItems","DomHandler","scrollInView","selectedItems","itemId","findIndexInList","selected","metaKey","ctrlKey","shiftKey","originalEvent","listType","moveRight","moveLeft","query","toLocaleLowerCase","isVisibleInList","sortByIndexInList","item1","item2","listElement","selectedItemIndex","temp","movedItem","unshift","selectedItem","includes","moveAllRight","movedItems","removedItem","moveAllLeft","onDrop","isTransfer","dropIndexes","getDropIndexes","onListFocus","getListElement","selectedFirstItem","findSingle","changeFocusedOptionIndex","onListBlur","getListItems","listElemet","getLatestSelectedVisibleOptionIndex","visibleList","latestSelectedItem","getVisibleList","setSelectionList","findNextOptionIndex","matchedOptionIndex","link","findPrevOptionIndex","onItemKeyDown","code","onArrowDownKey","onArrowUpKey","onHomeKey","onEndKey","onEnterKey","onSpaceKey","getFocusedOption","order","getAttribute","scrollIntoView","block","inline","optionIndex","lastSelectedIndex","focusedIndex","lastIndex","droppedList","findFilteredCurrentIndex","visibleOptions","resetFilter","onItemKeydown","currentTarget","which","nextItem","findNextItem","focus","prevItem","findPrevItem","nextElementSibling","hasClass","isHidden","previousElementSibling","matchMedia","matches","bindMediaChangeListener","unbindMediaChangeListener","listen","moveRightDisabled","moveLeftDisabled","moveAllRightDisabled","moveAllLeftDisabled","destroyStyle","removeChild","viewQuery","i4","i5","AngleDoubleLeftIcon","AngleDoubleRightIcon","AngleDownIcon","AngleLeftIcon","AngleRightIcon","AngleUpIcon","SearchIcon","DragConfig","PickListModule","ButtonModule","RippleModule","HomeIcon","OrderList_AngleUpIcon_3_Template","OrderList_4_ng_template_0_Template","OrderList_4_Template","OrderList_AngleDoubleUpIcon_6_Template","OrderList_7_ng_template_0_Template","OrderList_7_Template","OrderList_AngleDownIcon_9_Template","OrderList_10_ng_template_0_Template","OrderList_10_Template","OrderList_AngleDoubleDownIcon_12_Template","OrderList_13_ng_template_0_Template","OrderList_13_Template","OrderList_div_15_div_1_Template","OrderList_div_15_ng_container_2_Template","OrderList_div_15_Template","OrderList_div_16_ng_container_1_ng_container_1_Template","OrderList_div_16_ng_container_1_Template","filterTemplate","filterOptions","OrderList_div_16_ng_template_2_SearchIcon_3_Template","OrderList_div_16_ng_template_2_span_4_1_ng_template_0_Template","OrderList_div_16_ng_template_2_span_4_1_Template","OrderList_div_16_ng_template_2_span_4_Template","ctx_r25","filterIconTemplate","OrderList_div_16_ng_template_2_Template","_r29","ctx_r28","onFilterKeyup","ctx_r20","filterPlaceholder","ariaFilterLabel","OrderList_div_16_Template","_r21","ctx_r9","OrderList_ng_template_19_li_0_ng_container_1_Template","OrderList_ng_template_19_li_0_Template","_r37","item_r30","i_r31","ctx_r38","ctx_r41","ctx_r33","OrderList_ng_template_19_Template","ctx_r11","OrderList_ng_container_20_li_1_ng_container_1_Template","OrderList_ng_container_20_li_1_Template","ctx_r42","OrderList_ng_container_20_li_2_ng_container_1_Template","OrderList_ng_container_20_li_2_Template","ctx_r43","emptyFilterMessageTemplate","OrderList_ng_container_20_Template","a3","OrderList","ariaLabelledBy","listStyle","controlsPosition","selection","val","d_selection","selectionChange","onReorder","onSelectionChange","onFilterEvent","listViewChild","filterViewChild","selectedId","selectedIndex","metaSelection","insertIntoOrderedArray","focusableEl","getVisibleOptions","moveDisabled","OrderListModule","_r7","onSortChange","_r0","sortOptions","product_r11","image","description","rating","category","price","inventoryStatus","ListDemoComponent_ng_template_8_div_0_Template","product_r14","ListDemoComponent_ng_template_9_div_1_Template","products_r12","city_r15","city_r16","ListDemoComponent","productService","products","sourceCities","targetCities","orderCities","getProducts","label","substring","core","Xpm","ListDemoComponent_ng_template_7_Template","ListDemoComponent_ng_template_8_Template","ListDemoComponent_ng_template_9_Template","ListDemoComponent_ng_template_15_Template","ListDemoComponent_ng_template_21_Template","ListDemoRoutingModule","oAB","cJS","RouterModule","forChild","path","component","ListDemoModule","FormsModule","InputTextModule","DropdownModule","RatingModule"],"sourceRoot":"webpack:///","sources":["./node_modules/primeng/fesm2022/primeng-icons-thlarge.mjs","./node_modules/primeng/fesm2022/primeng-dataview.mjs","./node_modules/@angular/cdk/fesm2022/coercion.mjs","./node_modules/rxjs/dist/esm/internal/observable/fromEvent.js","./node_modules/rxjs/dist/esm/internal/scheduler/animationFrameProvider.js","./node_modules/rxjs/dist/esm/internal/scheduler/animationFrame.js","./node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameScheduler.js","./node_modules/rxjs/dist/esm/internal/scheduler/AnimationFrameAction.js","./node_modules/rxjs/dist/esm/internal/util/Immediate.js","./node_modules/rxjs/dist/esm/internal/scheduler/immediateProvider.js","./node_modules/rxjs/dist/esm/internal/scheduler/asap.js","./node_modules/rxjs/dist/esm/internal/scheduler/AsapScheduler.js","./node_modules/rxjs/dist/esm/internal/scheduler/AsapAction.js","./node_modules/rxjs/dist/esm/internal/operators/auditTime.js","./node_modules/rxjs/dist/esm/internal/operators/audit.js","./node_modules/@angular/cdk/fesm2022/platform.mjs","./node_modules/@angular/cdk/fesm2022/scrolling.mjs","./node_modules/@angular/cdk/fesm2022/bidi.mjs","./node_modules/@angular/cdk/fesm2022/drag-drop.mjs","./node_modules/@angular/cdk/fesm2022/a11y.mjs","./node_modules/primeng/fesm2022/primeng-icons-angledoubledown.mjs","./node_modules/primeng/fesm2022/primeng-icons-angledoubleup.mjs","./node_modules/primeng/fesm2022/primeng-picklist.mjs","./node_modules/primeng/fesm2022/primeng-orderlist.mjs","./src/app/demo/components/uikit/list/listdemo.component.html","./src/app/demo/components/uikit/list/listdemo.component.ts","./src/app/demo/components/uikit/list/listdemo-routing.module.ts","./src/app/demo/components/uikit/list/listdemo.module.ts"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Component } from '@angular/core';\nimport { BaseIcon } from 'primeng/baseicon';\nimport { UniqueComponentId } from 'primeng/utils';\n\nclass ThLargeIcon extends BaseIcon {\n    pathId;\n    ngOnInit() {\n        this.pathId = 'url(#' + UniqueComponentId() + ')';\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: ThLargeIcon, deps: null, target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.5\", type: ThLargeIcon, isStandalone: true, selector: \"ThLargeIcon\", usesInheritance: true, ngImport: i0, template: `\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" [attr.aria-label]=\"ariaLabel\" [attr.aria-hidden]=\"ariaHidden\" [attr.role]=\"role\" [class]=\"getClassNames()\">\n            <g [attr.clip-path]=\"pathId\">\n                <path\n                    fill-rule=\"evenodd\"\n                    clip-rule=\"evenodd\"\n                    d=\"M1.90909 6.36364H4.45455C4.96087 6.36364 5.44645 6.1625 5.80448 5.80448C6.1625 5.44645 6.36364 4.96087 6.36364 4.45455V1.90909C6.36364 1.40277 6.1625 0.917184 5.80448 0.55916C5.44645 0.201136 4.96087 0 4.45455 0H1.90909C1.40277 0 0.917184 0.201136 0.55916 0.55916C0.201136 0.917184 0 1.40277 0 1.90909V4.45455C0 4.96087 0.201136 5.44645 0.55916 5.80448C0.917184 6.1625 1.40277 6.36364 1.90909 6.36364ZM1.46154 1.46154C1.58041 1.34268 1.741 1.27492 1.90909 1.27273H4.45455C4.62264 1.27492 4.78322 1.34268 4.90209 1.46154C5.02096 1.58041 5.08871 1.741 5.09091 1.90909V4.45455C5.08871 4.62264 5.02096 4.78322 4.90209 4.90209C4.78322 5.02096 4.62264 5.08871 4.45455 5.09091H1.90909C1.741 5.08871 1.58041 5.02096 1.46154 4.90209C1.34268 4.78322 1.27492 4.62264 1.27273 4.45455V1.90909C1.27492 1.741 1.34268 1.58041 1.46154 1.46154ZM1.90909 14H4.45455C4.96087 14 5.44645 13.7989 5.80448 13.4408C6.1625 13.0828 6.36364 12.5972 6.36364 12.0909V9.54544C6.36364 9.03912 6.1625 8.55354 5.80448 8.19551C5.44645 7.83749 4.96087 7.63635 4.45455 7.63635H1.90909C1.40277 7.63635 0.917184 7.83749 0.55916 8.19551C0.201136 8.55354 0 9.03912 0 9.54544V12.0909C0 12.5972 0.201136 13.0828 0.55916 13.4408C0.917184 13.7989 1.40277 14 1.90909 14ZM1.46154 9.0979C1.58041 8.97903 1.741 8.91128 1.90909 8.90908H4.45455C4.62264 8.91128 4.78322 8.97903 4.90209 9.0979C5.02096 9.21677 5.08871 9.37735 5.09091 9.54544V12.0909C5.08871 12.259 5.02096 12.4196 4.90209 12.5384C4.78322 12.6573 4.62264 12.7251 4.45455 12.7273H1.90909C1.741 12.7251 1.58041 12.6573 1.46154 12.5384C1.34268 12.4196 1.27492 12.259 1.27273 12.0909V9.54544C1.27492 9.37735 1.34268 9.21677 1.46154 9.0979ZM12.0909 6.36364H9.54544C9.03912 6.36364 8.55354 6.1625 8.19551 5.80448C7.83749 5.44645 7.63635 4.96087 7.63635 4.45455V1.90909C7.63635 1.40277 7.83749 0.917184 8.19551 0.55916C8.55354 0.201136 9.03912 0 9.54544 0H12.0909C12.5972 0 13.0828 0.201136 13.4408 0.55916C13.7989 0.917184 14 1.40277 14 1.90909V4.45455C14 4.96087 13.7989 5.44645 13.4408 5.80448C13.0828 6.1625 12.5972 6.36364 12.0909 6.36364ZM9.54544 1.27273C9.37735 1.27492 9.21677 1.34268 9.0979 1.46154C8.97903 1.58041 8.91128 1.741 8.90908 1.90909V4.45455C8.91128 4.62264 8.97903 4.78322 9.0979 4.90209C9.21677 5.02096 9.37735 5.08871 9.54544 5.09091H12.0909C12.259 5.08871 12.4196 5.02096 12.5384 4.90209C12.6573 4.78322 12.7251 4.62264 12.7273 4.45455V1.90909C12.7251 1.741 12.6573 1.58041 12.5384 1.46154C12.4196 1.34268 12.259 1.27492 12.0909 1.27273H9.54544ZM9.54544 14H12.0909C12.5972 14 13.0828 13.7989 13.4408 13.4408C13.7989 13.0828 14 12.5972 14 12.0909V9.54544C14 9.03912 13.7989 8.55354 13.4408 8.19551C13.0828 7.83749 12.5972 7.63635 12.0909 7.63635H9.54544C9.03912 7.63635 8.55354 7.83749 8.19551 8.19551C7.83749 8.55354 7.63635 9.03912 7.63635 9.54544V12.0909C7.63635 12.5972 7.83749 13.0828 8.19551 13.4408C8.55354 13.7989 9.03912 14 9.54544 14ZM9.0979 9.0979C9.21677 8.97903 9.37735 8.91128 9.54544 8.90908H12.0909C12.259 8.91128 12.4196 8.97903 12.5384 9.0979C12.6573 9.21677 12.7251 9.37735 12.7273 9.54544V12.0909C12.7251 12.259 12.6573 12.4196 12.5384 12.5384C12.4196 12.6573 12.259 12.7251 12.0909 12.7273H9.54544C9.37735 12.7251 9.21677 12.6573 9.0979 12.5384C8.97903 12.4196 8.91128 12.259 8.90908 12.0909V9.54544C8.91128 9.37735 8.97903 9.21677 9.0979 9.0979Z\"\n                    fill=\"currentColor\"\n                />\n            </g>\n            <defs>\n                <clipPath [id]=\"pathId\">\n                    <rect width=\"14\" height=\"14\" fill=\"white\" />\n                </clipPath>\n            </defs>\n        </svg>\n    `, isInline: true });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: ThLargeIcon, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'ThLargeIcon',\n                    standalone: true,\n                    imports: [BaseIcon],\n                    template: `\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" [attr.aria-label]=\"ariaLabel\" [attr.aria-hidden]=\"ariaHidden\" [attr.role]=\"role\" [class]=\"getClassNames()\">\n            <g [attr.clip-path]=\"pathId\">\n                <path\n                    fill-rule=\"evenodd\"\n                    clip-rule=\"evenodd\"\n                    d=\"M1.90909 6.36364H4.45455C4.96087 6.36364 5.44645 6.1625 5.80448 5.80448C6.1625 5.44645 6.36364 4.96087 6.36364 4.45455V1.90909C6.36364 1.40277 6.1625 0.917184 5.80448 0.55916C5.44645 0.201136 4.96087 0 4.45455 0H1.90909C1.40277 0 0.917184 0.201136 0.55916 0.55916C0.201136 0.917184 0 1.40277 0 1.90909V4.45455C0 4.96087 0.201136 5.44645 0.55916 5.80448C0.917184 6.1625 1.40277 6.36364 1.90909 6.36364ZM1.46154 1.46154C1.58041 1.34268 1.741 1.27492 1.90909 1.27273H4.45455C4.62264 1.27492 4.78322 1.34268 4.90209 1.46154C5.02096 1.58041 5.08871 1.741 5.09091 1.90909V4.45455C5.08871 4.62264 5.02096 4.78322 4.90209 4.90209C4.78322 5.02096 4.62264 5.08871 4.45455 5.09091H1.90909C1.741 5.08871 1.58041 5.02096 1.46154 4.90209C1.34268 4.78322 1.27492 4.62264 1.27273 4.45455V1.90909C1.27492 1.741 1.34268 1.58041 1.46154 1.46154ZM1.90909 14H4.45455C4.96087 14 5.44645 13.7989 5.80448 13.4408C6.1625 13.0828 6.36364 12.5972 6.36364 12.0909V9.54544C6.36364 9.03912 6.1625 8.55354 5.80448 8.19551C5.44645 7.83749 4.96087 7.63635 4.45455 7.63635H1.90909C1.40277 7.63635 0.917184 7.83749 0.55916 8.19551C0.201136 8.55354 0 9.03912 0 9.54544V12.0909C0 12.5972 0.201136 13.0828 0.55916 13.4408C0.917184 13.7989 1.40277 14 1.90909 14ZM1.46154 9.0979C1.58041 8.97903 1.741 8.91128 1.90909 8.90908H4.45455C4.62264 8.91128 4.78322 8.97903 4.90209 9.0979C5.02096 9.21677 5.08871 9.37735 5.09091 9.54544V12.0909C5.08871 12.259 5.02096 12.4196 4.90209 12.5384C4.78322 12.6573 4.62264 12.7251 4.45455 12.7273H1.90909C1.741 12.7251 1.58041 12.6573 1.46154 12.5384C1.34268 12.4196 1.27492 12.259 1.27273 12.0909V9.54544C1.27492 9.37735 1.34268 9.21677 1.46154 9.0979ZM12.0909 6.36364H9.54544C9.03912 6.36364 8.55354 6.1625 8.19551 5.80448C7.83749 5.44645 7.63635 4.96087 7.63635 4.45455V1.90909C7.63635 1.40277 7.83749 0.917184 8.19551 0.55916C8.55354 0.201136 9.03912 0 9.54544 0H12.0909C12.5972 0 13.0828 0.201136 13.4408 0.55916C13.7989 0.917184 14 1.40277 14 1.90909V4.45455C14 4.96087 13.7989 5.44645 13.4408 5.80448C13.0828 6.1625 12.5972 6.36364 12.0909 6.36364ZM9.54544 1.27273C9.37735 1.27492 9.21677 1.34268 9.0979 1.46154C8.97903 1.58041 8.91128 1.741 8.90908 1.90909V4.45455C8.91128 4.62264 8.97903 4.78322 9.0979 4.90209C9.21677 5.02096 9.37735 5.08871 9.54544 5.09091H12.0909C12.259 5.08871 12.4196 5.02096 12.5384 4.90209C12.6573 4.78322 12.7251 4.62264 12.7273 4.45455V1.90909C12.7251 1.741 12.6573 1.58041 12.5384 1.46154C12.4196 1.34268 12.259 1.27492 12.0909 1.27273H9.54544ZM9.54544 14H12.0909C12.5972 14 13.0828 13.7989 13.4408 13.4408C13.7989 13.0828 14 12.5972 14 12.0909V9.54544C14 9.03912 13.7989 8.55354 13.4408 8.19551C13.0828 7.83749 12.5972 7.63635 12.0909 7.63635H9.54544C9.03912 7.63635 8.55354 7.83749 8.19551 8.19551C7.83749 8.55354 7.63635 9.03912 7.63635 9.54544V12.0909C7.63635 12.5972 7.83749 13.0828 8.19551 13.4408C8.55354 13.7989 9.03912 14 9.54544 14ZM9.0979 9.0979C9.21677 8.97903 9.37735 8.91128 9.54544 8.90908H12.0909C12.259 8.91128 12.4196 8.97903 12.5384 9.0979C12.6573 9.21677 12.7251 9.37735 12.7273 9.54544V12.0909C12.7251 12.259 12.6573 12.4196 12.5384 12.5384C12.4196 12.6573 12.259 12.7251 12.0909 12.7273H9.54544C9.37735 12.7251 9.21677 12.6573 9.0979 12.5384C8.97903 12.4196 8.91128 12.259 8.90908 12.0909V9.54544C8.91128 9.37735 8.97903 9.21677 9.0979 9.0979Z\"\n                    fill=\"currentColor\"\n                />\n            </g>\n            <defs>\n                <clipPath [id]=\"pathId\">\n                    <rect width=\"14\" height=\"14\" fill=\"white\" />\n                </clipPath>\n            </defs>\n        </svg>\n    `\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ThLargeIcon };\n","import * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Input, Output, ContentChild, ContentChildren, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { ObjectUtils } from 'primeng/utils';\nimport * as i1 from 'primeng/api';\nimport { TranslationKeys, Header, Footer, PrimeTemplate, SharedModule } from 'primeng/api';\nimport * as i3 from 'primeng/paginator';\nimport { PaginatorModule } from 'primeng/paginator';\nimport { SpinnerIcon } from 'primeng/icons/spinner';\nimport { ThLargeIcon } from 'primeng/icons/thlarge';\nimport { BarsIcon } from 'primeng/icons/bars';\n\n/**\n * DataView displays data in grid or list layout with pagination and sorting features.\n * @group Components\n */\nclass DataView {\n    el;\n    cd;\n    filterService;\n    config;\n    /**\n     * When specified as true, enables the pagination.\n     * @group Props\n     */\n    paginator;\n    /**\n     * Number of rows to display per page.\n     * @group Props\n     */\n    rows;\n    /**\n     * Number of total records, defaults to length of value when not defined.\n     * @group Props\n     */\n    totalRecords;\n    /**\n     * Number of page links to display in paginator.\n     * @group Props\n     */\n    pageLinks = 5;\n    /**\n     * Array of integer/object values to display inside rows per page dropdown of paginator\n     * @group Props\n     */\n    rowsPerPageOptions;\n    /**\n     * Position of the paginator.\n     * @group Props\n     */\n    paginatorPosition = 'bottom';\n    /**\n     * Custom style class for paginator\n     * @group Props\n     */\n    paginatorStyleClass;\n    /**\n     * Whether to show it even there is only one page.\n     * @group Props\n     */\n    alwaysShowPaginator = true;\n    /**\n     * Target element to attach the paginator dropdown overlay, valid values are \"body\" or a local ng-template variable of another element (note: use binding with brackets for template variables, e.g. [appendTo]=\"mydiv\" for a div element having #mydiv as variable name).\n     * @group Props\n     */\n    paginatorDropdownAppendTo;\n    /**\n     * Paginator dropdown height of the viewport in pixels, a scrollbar is defined if height of list exceeds this value.\n     * @group Props\n     */\n    paginatorDropdownScrollHeight = '200px';\n    /**\n     * Template of the current page report element. Available placeholders are {currentPage},{totalPages},{rows},{first},{last} and {totalRecords}\n     * @group Props\n     */\n    currentPageReportTemplate = '{currentPage} of {totalPages}';\n    /**\n     * Whether to display current page report.\n     * @group Props\n     */\n    showCurrentPageReport;\n    /**\n     * Whether to display a dropdown to navigate to any page.\n     * @group Props\n     */\n    showJumpToPageDropdown;\n    /**\n     * When enabled, icons are displayed on paginator to go first and last page.\n     * @group Props\n     */\n    showFirstLastIcon = true;\n    /**\n     * Whether to show page links.\n     * @group Props\n     */\n    showPageLinks = true;\n    /**\n     * Defines if data is loaded and interacted with in lazy manner.\n     * @group Props\n     */\n    lazy;\n    /**\n     * Whether to call lazy loading on initialization.\n     * @group Props\n     */\n    lazyLoadOnInit = true;\n    /**\n     * Text to display when there is no data. Defaults to global value in i18n translation configuration.\n     * @group Props\n     */\n    emptyMessage = '';\n    /**\n     * Inline style of the component.\n     * @group Props\n     */\n    style;\n    /**\n     * Style class of the component.\n     * @group Props\n     */\n    styleClass;\n    /**\n     * Style class of the grid.\n     * @group Props\n     */\n    gridStyleClass = '';\n    /**\n     * Function to optimize the dom operations by delegating to ngForTrackBy, default algorithm checks for object identity.\n     * @group Props\n     */\n    trackBy = (index, item) => item;\n    /**\n     * Comma separated list of fields in the object graph to search against.\n     * @group Props\n     */\n    filterBy;\n    /**\n     * Locale to use in filtering. The default locale is the host environment's current locale.\n     * @group Props\n     */\n    filterLocale;\n    /**\n     * Displays a loader to indicate data load is in progress.\n     * @group Props\n     */\n    loading;\n    /**\n     * The icon to show while indicating data load is in progress.\n     * @group Props\n     */\n    loadingIcon;\n    /**\n     * Index of the first row to be displayed.\n     * @group Props\n     */\n    first = 0;\n    /**\n     * Property name of data to use in sorting by default.\n     * @group Props\n     */\n    sortField;\n    /**\n     * Order to sort the data by default.\n     * @group Props\n     */\n    sortOrder;\n    /**\n     * An array of objects to display.\n     * @group Props\n     */\n    value;\n    /**\n     * Defines the layout mode.\n     * @group Props\n     */\n    get layout() {\n        return this._layout;\n    }\n    set layout(layout) {\n        this._layout = layout;\n        if (this.initialized) {\n            this.changeLayout(layout);\n        }\n    }\n    /**\n     * Callback to invoke when paging, sorting or filtering happens in lazy mode.\n     * @param {DataViewLazyLoadEvent} event - Custom lazy load event.\n     * @group Emits\n     */\n    onLazyLoad = new EventEmitter();\n    /**\n     * Callback to invoke when pagination occurs.\n     * @param {DataViewPageEvent} event - Custom page event.\n     * @group Emits\n     */\n    onPage = new EventEmitter();\n    /**\n     * Callback to invoke when sorting occurs.\n     * @param {DataViewSortEvent} event - Custom sort event.\n     * @group Emits\n     */\n    onSort = new EventEmitter();\n    /**\n     * Callback to invoke when changing layout.\n     * @param {DataViewLayoutChangeEvent} event - Custom layout change event.\n     * @group Emits\n     */\n    onChangeLayout = new EventEmitter();\n    header;\n    footer;\n    templates;\n    _value;\n    listTemplate;\n    gridTemplate;\n    itemTemplate;\n    headerTemplate;\n    emptyMessageTemplate;\n    footerTemplate;\n    paginatorLeftTemplate;\n    paginatorRightTemplate;\n    paginatorDropdownItemTemplate;\n    loadingIconTemplate;\n    listIconTemplate;\n    gridIconTemplate;\n    filteredValue;\n    filterValue;\n    initialized;\n    _layout = 'list';\n    translationSubscription;\n    get emptyMessageLabel() {\n        return this.emptyMessage || this.config.getTranslation(TranslationKeys.EMPTY_MESSAGE);\n    }\n    constructor(el, cd, filterService, config) {\n        this.el = el;\n        this.cd = cd;\n        this.filterService = filterService;\n        this.config = config;\n    }\n    ngOnInit() {\n        if (this.lazy && this.lazyLoadOnInit) {\n            this.onLazyLoad.emit(this.createLazyLoadMetadata());\n        }\n        this.translationSubscription = this.config.translationObserver.subscribe(() => {\n            this.cd.markForCheck();\n        });\n        this.initialized = true;\n    }\n    ngOnChanges(simpleChanges) {\n        if (simpleChanges.value) {\n            this._value = simpleChanges.value.currentValue;\n            this.updateTotalRecords();\n            if (!this.lazy && this.hasFilter()) {\n                this.filter(this.filterValue);\n            }\n        }\n        if (simpleChanges.sortField || simpleChanges.sortOrder) {\n            //avoid triggering lazy load prior to lazy initialization at onInit\n            if (!this.lazy || this.initialized) {\n                this.sort();\n            }\n        }\n    }\n    ngAfterContentInit() {\n        this.templates.forEach((item) => {\n            switch (item.getType()) {\n                case 'listItem':\n                case 'list':\n                    this.listTemplate = item.template;\n                    break;\n                case 'gridItem':\n                case 'grid':\n                    this.gridTemplate = item.template;\n                    break;\n                case 'paginatorleft':\n                    this.paginatorLeftTemplate = item.template;\n                    break;\n                case 'paginatorright':\n                    this.paginatorRightTemplate = item.template;\n                    break;\n                case 'paginatordropdownitem':\n                    this.paginatorDropdownItemTemplate = item.template;\n                    break;\n                case 'empty':\n                    this.emptyMessageTemplate = item.template;\n                    break;\n                case 'header':\n                    this.headerTemplate = item.template;\n                    break;\n                case 'footer':\n                    this.footerTemplate = item.template;\n                    break;\n                case 'loadingicon':\n                    this.loadingIconTemplate = item.template;\n                    break;\n                case 'listicon':\n                    this.listIconTemplate = item.template;\n                    break;\n                case 'gridicon':\n                    this.gridIconTemplate = item.template;\n                    break;\n            }\n        });\n        this.updateItemTemplate();\n    }\n    updateItemTemplate() {\n        switch (this.layout) {\n            case 'list':\n                this.itemTemplate = this.listTemplate;\n                break;\n            case 'grid':\n                this.itemTemplate = this.gridTemplate;\n                break;\n        }\n    }\n    changeLayout(layout) {\n        this._layout = layout;\n        this.onChangeLayout.emit({\n            layout: this.layout\n        });\n        this.updateItemTemplate();\n        this.cd.markForCheck();\n    }\n    updateTotalRecords() {\n        this.totalRecords = this.lazy ? this.totalRecords : this._value ? this._value.length : 0;\n    }\n    paginate(event) {\n        this.first = event.first;\n        this.rows = event.rows;\n        if (this.lazy) {\n            this.onLazyLoad.emit(this.createLazyLoadMetadata());\n        }\n        this.onPage.emit({\n            first: this.first,\n            rows: this.rows\n        });\n    }\n    sort() {\n        this.first = 0;\n        if (this.lazy) {\n            this.onLazyLoad.emit(this.createLazyLoadMetadata());\n        }\n        else if (this.value) {\n            this.value.sort((data1, data2) => {\n                let value1 = ObjectUtils.resolveFieldData(data1, this.sortField);\n                let value2 = ObjectUtils.resolveFieldData(data2, this.sortField);\n                let result = null;\n                if (value1 == null && value2 != null)\n                    result = -1;\n                else if (value1 != null && value2 == null)\n                    result = 1;\n                else if (value1 == null && value2 == null)\n                    result = 0;\n                else if (typeof value1 === 'string' && typeof value2 === 'string')\n                    result = value1.localeCompare(value2);\n                else\n                    result = value1 < value2 ? -1 : value1 > value2 ? 1 : 0;\n                return this.sortOrder * result;\n            });\n            if (this.hasFilter()) {\n                this.filter(this.filterValue);\n            }\n        }\n        this.onSort.emit({\n            sortField: this.sortField,\n            sortOrder: this.sortOrder\n        });\n    }\n    isEmpty() {\n        let data = this.filteredValue || this.value;\n        return data == null || data.length == 0;\n    }\n    createLazyLoadMetadata() {\n        return {\n            first: this.first,\n            rows: this.rows,\n            sortField: this.sortField,\n            sortOrder: this.sortOrder\n        };\n    }\n    getBlockableElement() {\n        return this.el.nativeElement.children[0];\n    }\n    filter(filter, filterMatchMode = 'contains') {\n        this.filterValue = filter;\n        if (this.value && this.value.length) {\n            let searchFields = this.filterBy.split(',');\n            this.filteredValue = this.filterService.filter(this.value, searchFields, filter, filterMatchMode, this.filterLocale);\n            if (this.filteredValue.length === this.value.length) {\n                this.filteredValue = null;\n            }\n            if (this.paginator) {\n                this.first = 0;\n                this.totalRecords = this.filteredValue ? this.filteredValue.length : this.value ? this.value.length : 0;\n            }\n            this.cd.markForCheck();\n        }\n    }\n    hasFilter() {\n        return this.filterValue && this.filterValue.trim().length > 0;\n    }\n    ngOnDestroy() {\n        if (this.translationSubscription) {\n            this.translationSubscription.unsubscribe();\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: DataView, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i1.FilterService }, { token: i1.PrimeNGConfig }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.5\", type: DataView, selector: \"p-dataView\", inputs: { paginator: \"paginator\", rows: \"rows\", totalRecords: \"totalRecords\", pageLinks: \"pageLinks\", rowsPerPageOptions: \"rowsPerPageOptions\", paginatorPosition: \"paginatorPosition\", paginatorStyleClass: \"paginatorStyleClass\", alwaysShowPaginator: \"alwaysShowPaginator\", paginatorDropdownAppendTo: \"paginatorDropdownAppendTo\", paginatorDropdownScrollHeight: \"paginatorDropdownScrollHeight\", currentPageReportTemplate: \"currentPageReportTemplate\", showCurrentPageReport: \"showCurrentPageReport\", showJumpToPageDropdown: \"showJumpToPageDropdown\", showFirstLastIcon: \"showFirstLastIcon\", showPageLinks: \"showPageLinks\", lazy: \"lazy\", lazyLoadOnInit: \"lazyLoadOnInit\", emptyMessage: \"emptyMessage\", style: \"style\", styleClass: \"styleClass\", gridStyleClass: \"gridStyleClass\", trackBy: \"trackBy\", filterBy: \"filterBy\", filterLocale: \"filterLocale\", loading: \"loading\", loadingIcon: \"loadingIcon\", first: \"first\", sortField: \"sortField\", sortOrder: \"sortOrder\", value: \"value\", layout: \"layout\" }, outputs: { onLazyLoad: \"onLazyLoad\", onPage: \"onPage\", onSort: \"onSort\", onChangeLayout: \"onChangeLayout\" }, host: { classAttribute: \"p-element\" }, queries: [{ propertyName: \"header\", first: true, predicate: Header, descendants: true }, { propertyName: \"footer\", first: true, predicate: Footer, descendants: true }, { propertyName: \"templates\", predicate: PrimeTemplate }], usesOnChanges: true, ngImport: i0, template: `\n        <div [ngClass]=\"{ 'p-dataview p-component': true, 'p-dataview-list': layout === 'list', 'p-dataview-grid': layout === 'grid' }\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"p-dataview-loading\" *ngIf=\"loading\">\n                <div class=\"p-dataview-loading-overlay p-component-overlay\">\n                    <i *ngIf=\"loadingIcon\" [class]=\"'p-dataview-loading-icon pi-spin ' + loadingIcon\"></i>\n                    <ng-container *ngIf=\"!loadingIcon\">\n                        <SpinnerIcon *ngIf=\"!loadingIconTemplate\" [spin]=\"true\" [styleClass]=\"'p-dataview-loading-icon'\" />\n                        <ng-template *ngTemplateOutlet=\"loadingIconTemplate\"></ng-template>\n                    </ng-container>\n                </div>\n            </div>\n            <div class=\"p-dataview-header\" *ngIf=\"header || headerTemplate\">\n                <ng-content select=\"p-header\"></ng-content>\n                <ng-container *ngTemplateOutlet=\"headerTemplate\"></ng-container>\n            </div>\n            <p-paginator\n                [rows]=\"rows\"\n                [first]=\"first\"\n                [totalRecords]=\"totalRecords\"\n                [pageLinkSize]=\"pageLinks\"\n                [alwaysShow]=\"alwaysShowPaginator\"\n                (onPageChange)=\"paginate($event)\"\n                styleClass=\"p-paginator-top\"\n                [rowsPerPageOptions]=\"rowsPerPageOptions\"\n                *ngIf=\"paginator && (paginatorPosition === 'top' || paginatorPosition == 'both')\"\n                [dropdownAppendTo]=\"paginatorDropdownAppendTo\"\n                [dropdownScrollHeight]=\"paginatorDropdownScrollHeight\"\n                [templateLeft]=\"paginatorLeftTemplate\"\n                [templateRight]=\"paginatorRightTemplate\"\n                [currentPageReportTemplate]=\"currentPageReportTemplate\"\n                [showFirstLastIcon]=\"showFirstLastIcon\"\n                [dropdownItemTemplate]=\"paginatorDropdownItemTemplate\"\n                [showCurrentPageReport]=\"showCurrentPageReport\"\n                [showJumpToPageDropdown]=\"showJumpToPageDropdown\"\n                [showPageLinks]=\"showPageLinks\"\n                [styleClass]=\"paginatorStyleClass\"\n            ></p-paginator>\n\n            <div class=\"p-dataview-content\">\n                <ng-container *ngTemplateOutlet=\"itemTemplate; context: { $implicit: paginator ? (filteredValue || value | slice : (lazy ? 0 : first) : (lazy ? 0 : first) + rows) : filteredValue || value }\"></ng-container>\n\n                <div *ngIf=\"isEmpty() && !loading\">\n                    <div class=\"p-dataview-emptymessage\">\n                        <ng-container *ngIf=\"!emptyMessageTemplate; else empty\">\n                            {{ emptyMessageLabel }}\n                        </ng-container>\n                        <ng-container #empty *ngTemplateOutlet=\"emptyMessageTemplate\"></ng-container>\n                    </div>\n                </div>\n            </div>\n            <p-paginator\n                [rows]=\"rows\"\n                [first]=\"first\"\n                [totalRecords]=\"totalRecords\"\n                [pageLinkSize]=\"pageLinks\"\n                [alwaysShow]=\"alwaysShowPaginator\"\n                (onPageChange)=\"paginate($event)\"\n                styleClass=\"p-paginator-bottom\"\n                [rowsPerPageOptions]=\"rowsPerPageOptions\"\n                *ngIf=\"paginator && (paginatorPosition === 'bottom' || paginatorPosition == 'both')\"\n                [dropdownAppendTo]=\"paginatorDropdownAppendTo\"\n                [dropdownScrollHeight]=\"paginatorDropdownScrollHeight\"\n                [templateLeft]=\"paginatorLeftTemplate\"\n                [templateRight]=\"paginatorRightTemplate\"\n                [currentPageReportTemplate]=\"currentPageReportTemplate\"\n                [showFirstLastIcon]=\"showFirstLastIcon\"\n                [dropdownItemTemplate]=\"paginatorDropdownItemTemplate\"\n                [showCurrentPageReport]=\"showCurrentPageReport\"\n                [showJumpToPageDropdown]=\"showJumpToPageDropdown\"\n                [showPageLinks]=\"showPageLinks\"\n                [styleClass]=\"paginatorStyleClass\"\n            ></p-paginator>\n            <div class=\"p-dataview-footer\" *ngIf=\"footer || footerTemplate\">\n                <ng-content select=\"p-footer\"></ng-content>\n                <ng-container *ngTemplateOutlet=\"footerTemplate\"></ng-container>\n            </div>\n        </div>\n    `, isInline: true, styles: [\"@layer primeng{.p-dataview{position:relative}.p-dataview .p-dataview-loading-overlay{position:absolute;display:flex;align-items:center;justify-content:center;z-index:2}}\\n\"], dependencies: [{ kind: \"directive\", type: i0.forwardRef(() => i2.NgClass), selector: \"[ngClass]\", inputs: [\"class\", \"ngClass\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgIf), selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgTemplateOutlet), selector: \"[ngTemplateOutlet]\", inputs: [\"ngTemplateOutletContext\", \"ngTemplateOutlet\", \"ngTemplateOutletInjector\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgStyle), selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }, { kind: \"component\", type: i0.forwardRef(() => i3.Paginator), selector: \"p-paginator\", inputs: [\"pageLinkSize\", \"style\", \"styleClass\", \"alwaysShow\", \"dropdownAppendTo\", \"templateLeft\", \"templateRight\", \"appendTo\", \"dropdownScrollHeight\", \"currentPageReportTemplate\", \"showCurrentPageReport\", \"showFirstLastIcon\", \"totalRecords\", \"rows\", \"rowsPerPageOptions\", \"showJumpToPageDropdown\", \"showJumpToPageInput\", \"showPageLinks\", \"locale\", \"dropdownItemTemplate\", \"first\"], outputs: [\"onPageChange\"] }, { kind: \"component\", type: i0.forwardRef(() => SpinnerIcon), selector: \"SpinnerIcon\" }, { kind: \"pipe\", type: i0.forwardRef(() => i2.SlicePipe), name: \"slice\" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: DataView, decorators: [{\n            type: Component,\n            args: [{ selector: 'p-dataView', template: `\n        <div [ngClass]=\"{ 'p-dataview p-component': true, 'p-dataview-list': layout === 'list', 'p-dataview-grid': layout === 'grid' }\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <div class=\"p-dataview-loading\" *ngIf=\"loading\">\n                <div class=\"p-dataview-loading-overlay p-component-overlay\">\n                    <i *ngIf=\"loadingIcon\" [class]=\"'p-dataview-loading-icon pi-spin ' + loadingIcon\"></i>\n                    <ng-container *ngIf=\"!loadingIcon\">\n                        <SpinnerIcon *ngIf=\"!loadingIconTemplate\" [spin]=\"true\" [styleClass]=\"'p-dataview-loading-icon'\" />\n                        <ng-template *ngTemplateOutlet=\"loadingIconTemplate\"></ng-template>\n                    </ng-container>\n                </div>\n            </div>\n            <div class=\"p-dataview-header\" *ngIf=\"header || headerTemplate\">\n                <ng-content select=\"p-header\"></ng-content>\n                <ng-container *ngTemplateOutlet=\"headerTemplate\"></ng-container>\n            </div>\n            <p-paginator\n                [rows]=\"rows\"\n                [first]=\"first\"\n                [totalRecords]=\"totalRecords\"\n                [pageLinkSize]=\"pageLinks\"\n                [alwaysShow]=\"alwaysShowPaginator\"\n                (onPageChange)=\"paginate($event)\"\n                styleClass=\"p-paginator-top\"\n                [rowsPerPageOptions]=\"rowsPerPageOptions\"\n                *ngIf=\"paginator && (paginatorPosition === 'top' || paginatorPosition == 'both')\"\n                [dropdownAppendTo]=\"paginatorDropdownAppendTo\"\n                [dropdownScrollHeight]=\"paginatorDropdownScrollHeight\"\n                [templateLeft]=\"paginatorLeftTemplate\"\n                [templateRight]=\"paginatorRightTemplate\"\n                [currentPageReportTemplate]=\"currentPageReportTemplate\"\n                [showFirstLastIcon]=\"showFirstLastIcon\"\n                [dropdownItemTemplate]=\"paginatorDropdownItemTemplate\"\n                [showCurrentPageReport]=\"showCurrentPageReport\"\n                [showJumpToPageDropdown]=\"showJumpToPageDropdown\"\n                [showPageLinks]=\"showPageLinks\"\n                [styleClass]=\"paginatorStyleClass\"\n            ></p-paginator>\n\n            <div class=\"p-dataview-content\">\n                <ng-container *ngTemplateOutlet=\"itemTemplate; context: { $implicit: paginator ? (filteredValue || value | slice : (lazy ? 0 : first) : (lazy ? 0 : first) + rows) : filteredValue || value }\"></ng-container>\n\n                <div *ngIf=\"isEmpty() && !loading\">\n                    <div class=\"p-dataview-emptymessage\">\n                        <ng-container *ngIf=\"!emptyMessageTemplate; else empty\">\n                            {{ emptyMessageLabel }}\n                        </ng-container>\n                        <ng-container #empty *ngTemplateOutlet=\"emptyMessageTemplate\"></ng-container>\n                    </div>\n                </div>\n            </div>\n            <p-paginator\n                [rows]=\"rows\"\n                [first]=\"first\"\n                [totalRecords]=\"totalRecords\"\n                [pageLinkSize]=\"pageLinks\"\n                [alwaysShow]=\"alwaysShowPaginator\"\n                (onPageChange)=\"paginate($event)\"\n                styleClass=\"p-paginator-bottom\"\n                [rowsPerPageOptions]=\"rowsPerPageOptions\"\n                *ngIf=\"paginator && (paginatorPosition === 'bottom' || paginatorPosition == 'both')\"\n                [dropdownAppendTo]=\"paginatorDropdownAppendTo\"\n                [dropdownScrollHeight]=\"paginatorDropdownScrollHeight\"\n                [templateLeft]=\"paginatorLeftTemplate\"\n                [templateRight]=\"paginatorRightTemplate\"\n                [currentPageReportTemplate]=\"currentPageReportTemplate\"\n                [showFirstLastIcon]=\"showFirstLastIcon\"\n                [dropdownItemTemplate]=\"paginatorDropdownItemTemplate\"\n                [showCurrentPageReport]=\"showCurrentPageReport\"\n                [showJumpToPageDropdown]=\"showJumpToPageDropdown\"\n                [showPageLinks]=\"showPageLinks\"\n                [styleClass]=\"paginatorStyleClass\"\n            ></p-paginator>\n            <div class=\"p-dataview-footer\" *ngIf=\"footer || footerTemplate\">\n                <ng-content select=\"p-footer\"></ng-content>\n                <ng-container *ngTemplateOutlet=\"footerTemplate\"></ng-container>\n            </div>\n        </div>\n    `, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, host: {\n                        class: 'p-element'\n                    }, styles: [\"@layer primeng{.p-dataview{position:relative}.p-dataview .p-dataview-loading-overlay{position:absolute;display:flex;align-items:center;justify-content:center;z-index:2}}\\n\"] }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1.FilterService }, { type: i1.PrimeNGConfig }], propDecorators: { paginator: [{\n                type: Input\n            }], rows: [{\n                type: Input\n            }], totalRecords: [{\n                type: Input\n            }], pageLinks: [{\n                type: Input\n            }], rowsPerPageOptions: [{\n                type: Input\n            }], paginatorPosition: [{\n                type: Input\n            }], paginatorStyleClass: [{\n                type: Input\n            }], alwaysShowPaginator: [{\n                type: Input\n            }], paginatorDropdownAppendTo: [{\n                type: Input\n            }], paginatorDropdownScrollHeight: [{\n                type: Input\n            }], currentPageReportTemplate: [{\n                type: Input\n            }], showCurrentPageReport: [{\n                type: Input\n            }], showJumpToPageDropdown: [{\n                type: Input\n            }], showFirstLastIcon: [{\n                type: Input\n            }], showPageLinks: [{\n                type: Input\n            }], lazy: [{\n                type: Input\n            }], lazyLoadOnInit: [{\n                type: Input\n            }], emptyMessage: [{\n                type: Input\n            }], style: [{\n                type: Input\n            }], styleClass: [{\n                type: Input\n            }], gridStyleClass: [{\n                type: Input\n            }], trackBy: [{\n                type: Input\n            }], filterBy: [{\n                type: Input\n            }], filterLocale: [{\n                type: Input\n            }], loading: [{\n                type: Input\n            }], loadingIcon: [{\n                type: Input\n            }], first: [{\n                type: Input\n            }], sortField: [{\n                type: Input\n            }], sortOrder: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }], layout: [{\n                type: Input\n            }], onLazyLoad: [{\n                type: Output\n            }], onPage: [{\n                type: Output\n            }], onSort: [{\n                type: Output\n            }], onChangeLayout: [{\n                type: Output\n            }], header: [{\n                type: ContentChild,\n                args: [Header]\n            }], footer: [{\n                type: ContentChild,\n                args: [Footer]\n            }], templates: [{\n                type: ContentChildren,\n                args: [PrimeTemplate]\n            }] } });\nclass DataViewLayoutOptions {\n    dv;\n    style;\n    styleClass;\n    constructor(dv) {\n        this.dv = dv;\n    }\n    changeLayout(event, layout) {\n        this.dv.changeLayout(layout);\n        event.preventDefault();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: DataViewLayoutOptions, deps: [{ token: DataView }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.5\", type: DataViewLayoutOptions, selector: \"p-dataViewLayoutOptions\", inputs: { style: \"style\", styleClass: \"styleClass\" }, host: { classAttribute: \"p-element\" }, ngImport: i0, template: `\n        <div [ngClass]=\"'p-dataview-layout-options p-selectbutton p-buttonset'\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <button type=\"button\" class=\"p-button p-button-icon-only\" [ngClass]=\"{ 'p-highlight': dv.layout === 'list' }\" (click)=\"changeLayout($event, 'list')\" (keydown.enter)=\"changeLayout($event, 'list')\">\n                <BarsIcon *ngIf=\"!dv.listIconTemplate\" />\n                <ng-template *ngTemplateOutlet=\"dv.listIconTemplate\"></ng-template></button\n            ><button type=\"button\" class=\"p-button p-button-icon-only\" [ngClass]=\"{ 'p-highlight': dv.layout === 'grid' }\" (click)=\"changeLayout($event, 'grid')\" (keydown.enter)=\"changeLayout($event, 'grid')\">\n                <ThLargeIcon *ngIf=\"!dv.gridIconTemplate\" />\n                <ng-template *ngTemplateOutlet=\"dv.gridIconTemplate\"></ng-template>\n            </button>\n        </div>\n    `, isInline: true, dependencies: [{ kind: \"directive\", type: i0.forwardRef(() => i2.NgClass), selector: \"[ngClass]\", inputs: [\"class\", \"ngClass\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgIf), selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgTemplateOutlet), selector: \"[ngTemplateOutlet]\", inputs: [\"ngTemplateOutletContext\", \"ngTemplateOutlet\", \"ngTemplateOutletInjector\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgStyle), selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }, { kind: \"component\", type: i0.forwardRef(() => BarsIcon), selector: \"BarsIcon\" }, { kind: \"component\", type: i0.forwardRef(() => ThLargeIcon), selector: \"ThLargeIcon\" }], encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: DataViewLayoutOptions, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'p-dataViewLayoutOptions',\n                    template: `\n        <div [ngClass]=\"'p-dataview-layout-options p-selectbutton p-buttonset'\" [ngStyle]=\"style\" [class]=\"styleClass\">\n            <button type=\"button\" class=\"p-button p-button-icon-only\" [ngClass]=\"{ 'p-highlight': dv.layout === 'list' }\" (click)=\"changeLayout($event, 'list')\" (keydown.enter)=\"changeLayout($event, 'list')\">\n                <BarsIcon *ngIf=\"!dv.listIconTemplate\" />\n                <ng-template *ngTemplateOutlet=\"dv.listIconTemplate\"></ng-template></button\n            ><button type=\"button\" class=\"p-button p-button-icon-only\" [ngClass]=\"{ 'p-highlight': dv.layout === 'grid' }\" (click)=\"changeLayout($event, 'grid')\" (keydown.enter)=\"changeLayout($event, 'grid')\">\n                <ThLargeIcon *ngIf=\"!dv.gridIconTemplate\" />\n                <ng-template *ngTemplateOutlet=\"dv.gridIconTemplate\"></ng-template>\n            </button>\n        </div>\n    `,\n                    encapsulation: ViewEncapsulation.None,\n                    host: {\n                        class: 'p-element'\n                    }\n                }]\n        }], ctorParameters: () => [{ type: DataView }], propDecorators: { style: [{\n                type: Input\n            }], styleClass: [{\n                type: Input\n            }] } });\nclass DataViewModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: DataViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.5\", ngImport: i0, type: DataViewModule, declarations: [DataView, DataViewLayoutOptions], imports: [CommonModule, SharedModule, PaginatorModule, SpinnerIcon, BarsIcon, ThLargeIcon], exports: [DataView, SharedModule, DataViewLayoutOptions] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: DataViewModule, imports: [CommonModule, SharedModule, PaginatorModule, SpinnerIcon, BarsIcon, ThLargeIcon, SharedModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: DataViewModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule, SharedModule, PaginatorModule, SpinnerIcon, BarsIcon, ThLargeIcon],\n                    exports: [DataView, SharedModule, DataViewLayoutOptions],\n                    declarations: [DataView, DataViewLayoutOptions]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DataView, DataViewLayoutOptions, DataViewModule };\n","import { ElementRef } from '@angular/core';\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\nfunction coerceBooleanProperty(value) {\n    return value != null && `${value}` !== 'false';\n}\n\nfunction coerceNumberProperty(value, fallbackValue = 0) {\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nfunction _isNumberValue(value) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\n\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/** Coerces a value to a CSS pixel value. */\nfunction coerceCssPixelValue(value) {\n    if (value == null) {\n        return '';\n    }\n    return typeof value === 'string' ? value : `${value}px`;\n}\n\n/**\n * Coerces an ElementRef or an Element into an element.\n * Useful for APIs that can accept either a ref or the native element itself.\n */\nfunction coerceElement(elementOrRef) {\n    return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\n}\n\n/**\n * Coerces a value to an array of trimmed non-empty strings.\n * Any input that is not an array, `null` or `undefined` will be turned into a string\n * via `toString()` and subsequently split with the given separator.\n * `null` and `undefined` will result in an empty array.\n * This results in the following outcomes:\n * - `null` -&gt; `[]`\n * - `[null]` -&gt; `[\"null\"]`\n * - `[\"a\", \"b \", \" \"]` -&gt; `[\"a\", \"b\"]`\n * - `[1, [2, 3]]` -&gt; `[\"1\", \"2,3\"]`\n * - `[{ a: 0 }]` -&gt; `[\"[object Object]\"]`\n * - `{ a: 0 }` -&gt; `[\"[object\", \"Object]\"]`\n *\n * Useful for defining CSS classes or table columns.\n * @param value the value to coerce into an array of strings\n * @param separator split-separator if value isn't an array\n */\nfunction coerceStringArray(value, separator = /\\s+/) {\n    const result = [];\n    if (value != null) {\n        const sourceValues = Array.isArray(value) ? value : `${value}`.split(separator);\n        for (const sourceValue of sourceValues) {\n            const trimmedString = `${sourceValue}`.trim();\n            if (trimmedString) {\n                result.push(trimmedString);\n            }\n        }\n    }\n    return result;\n}\n\nexport { _isNumberValue, coerceArray, coerceBooleanProperty, coerceCssPixelValue, coerceElement, coerceNumberProperty, coerceStringArray };\n","import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'];\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'];\nconst jqueryMethods = ['on', 'off'];\nexport function fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));\n    }\n    const [add, remove] = isEventTarget(target)\n        ? eventTargetMethods.map((methodName) => (handler) => target[methodName](eventName, handler, options))\n        :\n            isNodeStyleEventEmitter(target)\n                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n                : isJQueryStyleEventEmitter(target)\n                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n                    : [];\n    if (!add) {\n        if (isArrayLike(target)) {\n            return mergeMap((subTarget) => fromEvent(subTarget, eventName, options))(innerFrom(target));\n        }\n    }\n    if (!add) {\n        throw new TypeError('Invalid event target');\n    }\n    return new Observable((subscriber) => {\n        const handler = (...args) => subscriber.next(1 < args.length ? args : args[0]);\n        add(handler);\n        return () => remove(handler);\n    });\n}\nfunction toCommonHandlerRegistry(target, eventName) {\n    return (methodName) => (handler) => target[methodName](eventName, handler);\n}\nfunction isNodeStyleEventEmitter(target) {\n    return isFunction(target.addListener) && isFunction(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n    return isFunction(target.on) && isFunction(target.off);\n}\nfunction isEventTarget(target) {\n    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n","import { Subscription } from '../Subscription';\nexport const animationFrameProvider = {\n    schedule(callback) {\n        let request = requestAnimationFrame;\n        let cancel = cancelAnimationFrame;\n        const { delegate } = animationFrameProvider;\n        if (delegate) {\n            request = delegate.requestAnimationFrame;\n            cancel = delegate.cancelAnimationFrame;\n        }\n        const handle = request((timestamp) => {\n            cancel = undefined;\n            callback(timestamp);\n        });\n        return new Subscription(() => cancel === null || cancel === void 0 ? void 0 : cancel(handle));\n    },\n    requestAnimationFrame(...args) {\n        const { delegate } = animationFrameProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame)(...args);\n    },\n    cancelAnimationFrame(...args) {\n        const { delegate } = animationFrameProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame)(...args);\n    },\n    delegate: undefined,\n};\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\nexport const animationFrame = animationFrameScheduler;\n","import { AsyncScheduler } from './AsyncScheduler';\nexport class AnimationFrameScheduler extends AsyncScheduler {\n    flush(action) {\n        this._active = true;\n        const flushId = this._scheduled;\n        this._scheduled = undefined;\n        const { actions } = this;\n        let error;\n        action = action || actions.shift();\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions[0]) && action.id === flushId && actions.shift());\n        this._active = false;\n        if (error) {\n            while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { animationFrameProvider } from './animationFrameProvider';\nexport class AnimationFrameAction extends AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        var _a;\n        if (delay != null ? delay > 0 : this.delay > 0) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        const { actions } = scheduler;\n        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {\n            animationFrameProvider.cancelAnimationFrame(id);\n            scheduler._scheduled = undefined;\n        }\n        return undefined;\n    }\n}\n","let nextHandle = 1;\nlet resolved;\nconst activeHandles = {};\nfunction findAndClearHandle(handle) {\n    if (handle in activeHandles) {\n        delete activeHandles[handle];\n        return true;\n    }\n    return false;\n}\nexport const Immediate = {\n    setImmediate(cb) {\n        const handle = nextHandle++;\n        activeHandles[handle] = true;\n        if (!resolved) {\n            resolved = Promise.resolve();\n        }\n        resolved.then(() => findAndClearHandle(handle) && cb());\n        return handle;\n    },\n    clearImmediate(handle) {\n        findAndClearHandle(handle);\n    },\n};\nexport const TestTools = {\n    pending() {\n        return Object.keys(activeHandles).length;\n    }\n};\n","import { Immediate } from '../util/Immediate';\nconst { setImmediate, clearImmediate } = Immediate;\nexport const immediateProvider = {\n    setImmediate(...args) {\n        const { delegate } = immediateProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate)(...args);\n    },\n    clearImmediate(handle) {\n        const { delegate } = immediateProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);\n    },\n    delegate: undefined,\n};\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\nexport const asapScheduler = new AsapScheduler(AsapAction);\nexport const asap = asapScheduler;\n","import { AsyncScheduler } from './AsyncScheduler';\nexport class AsapScheduler extends AsyncScheduler {\n    flush(action) {\n        this._active = true;\n        const flushId = this._scheduled;\n        this._scheduled = undefined;\n        const { actions } = this;\n        let error;\n        action = action || actions.shift();\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions[0]) && action.id === flushId && actions.shift());\n        this._active = false;\n        if (error) {\n            while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { immediateProvider } from './immediateProvider';\nexport class AsapAction extends AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        var _a;\n        if (delay != null ? delay > 0 : this.delay > 0) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        const { actions } = scheduler;\n        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {\n            immediateProvider.clearImmediate(id);\n            if (scheduler._scheduled === id) {\n                scheduler._scheduled = undefined;\n            }\n        }\n        return undefined;\n    }\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nexport function auditTime(duration, scheduler = asyncScheduler) {\n    return audit(() => timer(duration, scheduler));\n}\n","import { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function audit(durationSelector) {\n    return operate((source, subscriber) => {\n        let hasValue = false;\n        let lastValue = null;\n        let durationSubscriber = null;\n        let isComplete = false;\n        const endDuration = () => {\n            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n            durationSubscriber = null;\n            if (hasValue) {\n                hasValue = false;\n                const value = lastValue;\n                lastValue = null;\n                subscriber.next(value);\n            }\n            isComplete && subscriber.complete();\n        };\n        const cleanupDuration = () => {\n            durationSubscriber = null;\n            isComplete && subscriber.complete();\n        };\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            hasValue = true;\n            lastValue = value;\n            if (!durationSubscriber) {\n                innerFrom(durationSelector(value)).subscribe((durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration)));\n            }\n        }, () => {\n            isComplete = true;\n            (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();\n        }));\n    });\n}\n","import * as i0 from '@angular/core';\nimport { PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nlet hasV8BreakIterator;\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n    hasV8BreakIterator = typeof Intl !== 'undefined' && Intl.v8BreakIterator;\n}\ncatch {\n    hasV8BreakIterator = false;\n}\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nclass Platform {\n    constructor(_platformId) {\n        this._platformId = _platformId;\n        // We want to use the Angular platform check because if the Document is shimmed\n        // without the navigator, the following checks will fail. This is preferred because\n        // sometimes the Document may be shimmed without the user's knowledge or intention\n        /** Whether the Angular application is being rendered in the browser. */\n        this.isBrowser = this._platformId\n            ? isPlatformBrowser(this._platformId)\n            : typeof document === 'object' && !!document;\n        /** Whether the current browser is Microsoft Edge. */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /** Whether the current rendering engine is Microsoft Trident. */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n        /** Whether the current rendering engine is Blink. */\n        this.BLINK = this.isBrowser &&\n            !!(window.chrome || hasV8BreakIterator) &&\n            typeof CSS !== 'undefined' &&\n            !this.EDGE &&\n            !this.TRIDENT;\n        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n        // ensure that Webkit runs standalone and is not used as another engine's base.\n        /** Whether the current rendering engine is WebKit. */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) &&\n            !this.BLINK &&\n            !this.EDGE &&\n            !this.TRIDENT;\n        /** Whether the current platform is Apple iOS. */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n        // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n        // them self as Gecko-like browsers and modify the userAgent's according to that.\n        // Since we only cover one explicit Firefox case, we can simply check for Firefox\n        // instead of having an unstable check for Gecko.\n        /** Whether the current browser is Firefox. */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /** Whether the current platform is Android. */\n        // Trident on mobile adds the android platform to the userAgent to trick detections.\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n        // Safari browser should also use Webkit as its layout engine.\n        /** Whether the current browser is Safari. */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: Platform, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: Platform, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: Platform, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: Object, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }] });\n\nclass PlatformModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: PlatformModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.4\", ngImport: i0, type: PlatformModule }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: PlatformModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: PlatformModule, decorators: [{\n            type: NgModule,\n            args: [{}]\n        }] });\n\n/** Cached result Set of input types support by the current browser. */\nlet supportedInputTypes;\n/** Types of `<input>` that *might* be supported. */\nconst candidateInputTypes = [\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n    // first changing it to something else:\n    // The specified value \"\" does not conform to the required format.\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/** @returns The input types supported by this browser. */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    let featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(value => {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                get: () => (supportsPassiveEvents = true),\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nfunction normalizePassiveListenerOptions(options) {\n    return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\nlet rtlScrollAxisType;\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\nlet scrollBehaviorSupported;\n/** Check whether the browser supports scroll behaviors. */\nfunction supportsScrollBehavior() {\n    if (scrollBehaviorSupported == null) {\n        // If we're not in the browser, it can't be supported. Also check for `Element`, because\n        // some projects stub out the global `document` during SSR which can throw us off.\n        if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\n            scrollBehaviorSupported = false;\n            return scrollBehaviorSupported;\n        }\n        // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\n        if ('scrollBehavior' in document.documentElement.style) {\n            scrollBehaviorSupported = true;\n        }\n        else {\n            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\n            // supported but it doesn't handle scroll behavior, or it has been polyfilled.\n            const scrollToFunction = Element.prototype.scrollTo;\n            if (scrollToFunction) {\n                // We can detect if the function has been polyfilled by calling `toString` on it. Native\n                // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\n                // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\n                // polyfilled functions as supporting scroll behavior.\n                scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\n            }\n            else {\n                scrollBehaviorSupported = false;\n            }\n        }\n    }\n    return scrollBehaviorSupported;\n}\n/**\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n */\nfunction getRtlScrollAxisType() {\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\n    if (typeof document !== 'object' || !document) {\n        return 0 /* RtlScrollAxisType.NORMAL */;\n    }\n    if (rtlScrollAxisType == null) {\n        // Create a 1px wide scrolling container and a 2px wide content element.\n        const scrollContainer = document.createElement('div');\n        const containerStyle = scrollContainer.style;\n        scrollContainer.dir = 'rtl';\n        containerStyle.width = '1px';\n        containerStyle.overflow = 'auto';\n        containerStyle.visibility = 'hidden';\n        containerStyle.pointerEvents = 'none';\n        containerStyle.position = 'absolute';\n        const content = document.createElement('div');\n        const contentStyle = content.style;\n        contentStyle.width = '2px';\n        contentStyle.height = '1px';\n        scrollContainer.appendChild(content);\n        document.body.appendChild(scrollContainer);\n        rtlScrollAxisType = 0 /* RtlScrollAxisType.NORMAL */;\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\n        // dealing with one of the other two types of browsers.\n        if (scrollContainer.scrollLeft === 0) {\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\n            // return 0 when we read it again.\n            scrollContainer.scrollLeft = 1;\n            rtlScrollAxisType =\n                scrollContainer.scrollLeft === 0 ? 1 /* RtlScrollAxisType.NEGATED */ : 2 /* RtlScrollAxisType.INVERTED */;\n        }\n        scrollContainer.remove();\n    }\n    return rtlScrollAxisType;\n}\n\nlet shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\nfunction _supportsShadowDom() {\n    if (shadowDomIsSupported == null) {\n        const head = typeof document !== 'undefined' ? document.head : null;\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n    }\n    return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nfunction _getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        // Note that this should be caught by `_supportsShadowDom`, but some\n        // teams have been able to hit this code path on unsupported browsers.\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nfunction _getFocusedElementPierceShadowDom() {\n    let activeElement = typeof document !== 'undefined' && document\n        ? document.activeElement\n        : null;\n    while (activeElement && activeElement.shadowRoot) {\n        const newActiveElement = activeElement.shadowRoot.activeElement;\n        if (newActiveElement === activeElement) {\n            break;\n        }\n        else {\n            activeElement = newActiveElement;\n        }\n    }\n    return activeElement;\n}\n/** Gets the target of an event while accounting for Shadow DOM. */\nfunction _getEventTarget(event) {\n    // If an event is bound outside the Shadow DOM, the `event.target` will\n    // point to the shadow root so we have to use `composedPath` instead.\n    return (event.composedPath ? event.composedPath()[0] : event.target);\n}\n\n/** Gets whether the code is currently running in a test environment. */\nfunction _isTestEnvironment() {\n    // We can't use `declare const` because it causes conflicts inside Google with the real typings\n    // for these symbols and we can't read them off the global object, because they don't appear to\n    // be attached there for some runners like Jest.\n    // (see: https://github.com/angular/components/issues/23365#issuecomment-938146643)\n    return (\n    // @ts-ignore\n    (typeof __karma__ !== 'undefined' && !!__karma__) ||\n        // @ts-ignore\n        (typeof jasmine !== 'undefined' && !!jasmine) ||\n        // @ts-ignore\n        (typeof jest !== 'undefined' && !!jest) ||\n        // @ts-ignore\n        (typeof Mocha !== 'undefined' && !!Mocha));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Platform, PlatformModule, _getEventTarget, _getFocusedElementPierceShadowDom, _getShadowRoot, _isTestEnvironment, _supportsShadowDom, getRtlScrollAxisType, getSupportedInputTypes, normalizePassiveListenerOptions, supportsPassiveEventListeners, supportsScrollBehavior };\n","import { coerceNumberProperty, coerceElement } from '@angular/cdk/coercion';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, forwardRef, Directive, Input, Injectable, Optional, Inject, inject, booleanAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, Output, ViewChild, SkipSelf, ElementRef, NgModule } from '@angular/core';\nimport { Subject, of, Observable, fromEvent, animationFrameScheduler, asapScheduler, Subscription, isObservable } from 'rxjs';\nimport { distinctUntilChanged, auditTime, filter, takeUntil, startWith, pairwise, switchMap, shareReplay } from 'rxjs/operators';\nimport * as i1 from '@angular/cdk/platform';\nimport { getRtlScrollAxisType, supportsScrollBehavior, Platform } from '@angular/cdk/platform';\nimport { DOCUMENT } from '@angular/common';\nimport * as i2 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport * as i2$1 from '@angular/cdk/collections';\nimport { isDataSource, ArrayDataSource, _VIEW_REPEATER_STRATEGY, _RecycleViewRepeaterStrategy } from '@angular/cdk/collections';\n\n/** The injection token used to specify the virtual scrolling strategy. */\nconst VIRTUAL_SCROLL_STRATEGY = new InjectionToken('VIRTUAL_SCROLL_STRATEGY');\n\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nclass FixedSizeVirtualScrollStrategy {\n    /**\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    constructor(itemSize, minBufferPx, maxBufferPx) {\n        this._scrolledIndexChange = new Subject();\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());\n        /** The attached viewport. */\n        this._viewport = null;\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n    }\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport) {\n        this._viewport = viewport;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach() {\n        this._scrolledIndexChange.complete();\n        this._viewport = null;\n    }\n    /**\n     * Update the item size and buffer size.\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\n        if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n        }\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled() {\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged() {\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered() {\n        /* no-op */\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged() {\n        /* no-op */\n    }\n    /**\n     * Scroll to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling.\n     */\n    scrollToIndex(index, behavior) {\n        if (this._viewport) {\n            this._viewport.scrollToOffset(index * this._itemSize, behavior);\n        }\n    }\n    /** Update the viewport's total content size. */\n    _updateTotalContentSize() {\n        if (!this._viewport) {\n            return;\n        }\n        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n    }\n    /** Update the viewport's rendered range. */\n    _updateRenderedRange() {\n        if (!this._viewport) {\n            return;\n        }\n        const renderedRange = this._viewport.getRenderedRange();\n        const newRange = { start: renderedRange.start, end: renderedRange.end };\n        const viewportSize = this._viewport.getViewportSize();\n        const dataLength = this._viewport.getDataLength();\n        let scrollOffset = this._viewport.measureScrollOffset();\n        // Prevent NaN as result when dividing by zero.\n        let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;\n        // If user scrolls to the bottom of the list and data changes to a smaller list\n        if (newRange.end > dataLength) {\n            // We have to recalculate the first visible index based on new data length and viewport size.\n            const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n            const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\n            // If first visible index changed we must update scroll offset to handle start/end buffers\n            // Current range must also be adjusted to cover the new position (bottom of new list).\n            if (firstVisibleIndex != newVisibleIndex) {\n                firstVisibleIndex = newVisibleIndex;\n                scrollOffset = newVisibleIndex * this._itemSize;\n                newRange.start = Math.floor(firstVisibleIndex);\n            }\n            newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n        }\n        const startBuffer = scrollOffset - newRange.start * this._itemSize;\n        if (startBuffer < this._minBufferPx && newRange.start != 0) {\n            const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n            newRange.start = Math.max(0, newRange.start - expandStart);\n            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\n        }\n        else {\n            const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n                const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n                if (expandEnd > 0) {\n                    newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n                    newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\n                }\n            }\n        }\n        this._viewport.setRenderedRange(newRange);\n        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n    }\n}\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\n    return fixedSizeDir._scrollStrategy;\n}\n/** A virtual scroll strategy that supports fixed-size items. */\nclass CdkFixedSizeVirtualScroll {\n    constructor() {\n        this._itemSize = 20;\n        this._minBufferPx = 100;\n        this._maxBufferPx = 200;\n        /** The scroll strategy used by this directive. */\n        this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\n    }\n    /** The size of the items in the list (in pixels). */\n    get itemSize() {\n        return this._itemSize;\n    }\n    set itemSize(value) {\n        this._itemSize = coerceNumberProperty(value);\n    }\n    /**\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n     */\n    get minBufferPx() {\n        return this._minBufferPx;\n    }\n    set minBufferPx(value) {\n        this._minBufferPx = coerceNumberProperty(value);\n    }\n    /**\n     * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n     */\n    get maxBufferPx() {\n        return this._maxBufferPx;\n    }\n    set maxBufferPx(value) {\n        this._maxBufferPx = coerceNumberProperty(value);\n    }\n    ngOnChanges() {\n        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkFixedSizeVirtualScroll, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: CdkFixedSizeVirtualScroll, isStandalone: true, selector: \"cdk-virtual-scroll-viewport[itemSize]\", inputs: { itemSize: \"itemSize\", minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, providers: [\n            {\n                provide: VIRTUAL_SCROLL_STRATEGY,\n                useFactory: _fixedSizeVirtualScrollStrategyFactory,\n                deps: [forwardRef(() => CdkFixedSizeVirtualScroll)],\n            },\n        ], usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkFixedSizeVirtualScroll, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'cdk-virtual-scroll-viewport[itemSize]',\n                    standalone: true,\n                    providers: [\n                        {\n                            provide: VIRTUAL_SCROLL_STRATEGY,\n                            useFactory: _fixedSizeVirtualScrollStrategyFactory,\n                            deps: [forwardRef(() => CdkFixedSizeVirtualScroll)],\n                        },\n                    ],\n                }]\n        }], propDecorators: { itemSize: [{\n                type: Input\n            }], minBufferPx: [{\n                type: Input\n            }], maxBufferPx: [{\n                type: Input\n            }] } });\n\n/** Time in ms to throttle the scrolling events by default. */\nconst DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nclass ScrollDispatcher {\n    constructor(_ngZone, _platform, document) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n        this._scrolled = new Subject();\n        /** Keeps track of the global `scroll` and `resize` subscriptions. */\n        this._globalSubscription = null;\n        /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n        this._document = document;\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    register(scrollable) {\n        if (!this.scrollContainers.has(scrollable)) {\n            this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));\n        }\n    }\n    /**\n     * De-registers a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    deregister(scrollable) {\n        const scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    }\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\n        if (!this._platform.isBrowser) {\n            return of();\n        }\n        return new Observable((observer) => {\n            if (!this._globalSubscription) {\n                this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            const subscription = auditTimeInMs > 0\n                ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer)\n                : this._scrolled.subscribe(observer);\n            this._scrolledCount++;\n            return () => {\n                subscription.unsubscribe();\n                this._scrolledCount--;\n                if (!this._scrolledCount) {\n                    this._removeGlobalListener();\n                }\n            };\n        });\n    }\n    ngOnDestroy() {\n        this._removeGlobalListener();\n        this.scrollContainers.forEach((_, container) => this.deregister(container));\n        this._scrolled.complete();\n    }\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementOrElementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    ancestorScrolled(elementOrElementRef, auditTimeInMs) {\n        const ancestors = this.getAncestorScrollContainers(elementOrElementRef);\n        return this.scrolled(auditTimeInMs).pipe(filter(target => {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    }\n    /** Returns all registered Scrollables that contain the provided element. */\n    getAncestorScrollContainers(elementOrElementRef) {\n        const scrollingContainers = [];\n        this.scrollContainers.forEach((_subscription, scrollable) => {\n            if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    /** Returns true if the element is contained within the provided Scrollable. */\n    _scrollableContainsElement(scrollable, elementOrElementRef) {\n        let element = coerceElement(elementOrElementRef);\n        let scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while ((element = element.parentElement));\n        return false;\n    }\n    /** Sets up the global scroll listeners. */\n    _addGlobalListener() {\n        this._globalSubscription = this._ngZone.runOutsideAngular(() => {\n            const window = this._getWindow();\n            return fromEvent(window.document, 'scroll').subscribe(() => this._scrolled.next());\n        });\n    }\n    /** Cleans up the global scroll listener. */\n    _removeGlobalListener() {\n        if (this._globalSubscription) {\n            this._globalSubscription.unsubscribe();\n            this._globalSubscription = null;\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ScrollDispatcher, deps: [{ token: i0.NgZone }, { token: i1.Platform }, { token: DOCUMENT, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ScrollDispatcher, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ScrollDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i1.Platform }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nclass CdkScrollable {\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\n        this.elementRef = elementRef;\n        this.scrollDispatcher = scrollDispatcher;\n        this.ngZone = ngZone;\n        this.dir = dir;\n        this._destroyed = new Subject();\n        this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, 'scroll')\n            .pipe(takeUntil(this._destroyed))\n            .subscribe(observer)));\n    }\n    ngOnInit() {\n        this.scrollDispatcher.register(this);\n    }\n    ngOnDestroy() {\n        this.scrollDispatcher.deregister(this);\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** Returns observable that emits when a scroll event is fired on the host element. */\n    elementScrolled() {\n        return this._elementScrolled;\n    }\n    /** Gets the ElementRef for the viewport. */\n    getElementRef() {\n        return this.elementRef;\n    }\n    /**\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param options specified the offsets to scroll to.\n     */\n    scrollTo(options) {\n        const el = this.elementRef.nativeElement;\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        // Rewrite start & end offsets as right or left offsets.\n        if (options.left == null) {\n            options.left = isRtl ? options.end : options.start;\n        }\n        if (options.right == null) {\n            options.right = isRtl ? options.start : options.end;\n        }\n        // Rewrite the bottom offset as a top offset.\n        if (options.bottom != null) {\n            options.top =\n                el.scrollHeight - el.clientHeight - options.bottom;\n        }\n        // Rewrite the right offset as a left offset.\n        if (isRtl && getRtlScrollAxisType() != 0 /* RtlScrollAxisType.NORMAL */) {\n            if (options.left != null) {\n                options.right =\n                    el.scrollWidth - el.clientWidth - options.left;\n            }\n            if (getRtlScrollAxisType() == 2 /* RtlScrollAxisType.INVERTED */) {\n                options.left = options.right;\n            }\n            else if (getRtlScrollAxisType() == 1 /* RtlScrollAxisType.NEGATED */) {\n                options.left = options.right ? -options.right : options.right;\n            }\n        }\n        else {\n            if (options.right != null) {\n                options.left =\n                    el.scrollWidth - el.clientWidth - options.right;\n            }\n        }\n        this._applyScrollToOptions(options);\n    }\n    _applyScrollToOptions(options) {\n        const el = this.elementRef.nativeElement;\n        if (supportsScrollBehavior()) {\n            el.scrollTo(options);\n        }\n        else {\n            if (options.top != null) {\n                el.scrollTop = options.top;\n            }\n            if (options.left != null) {\n                el.scrollLeft = options.left;\n            }\n        }\n    }\n    /**\n     * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n     * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n     * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param from The edge to measure from.\n     */\n    measureScrollOffset(from) {\n        const LEFT = 'left';\n        const RIGHT = 'right';\n        const el = this.elementRef.nativeElement;\n        if (from == 'top') {\n            return el.scrollTop;\n        }\n        if (from == 'bottom') {\n            return el.scrollHeight - el.clientHeight - el.scrollTop;\n        }\n        // Rewrite start & end as left or right offsets.\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        if (from == 'start') {\n            from = isRtl ? RIGHT : LEFT;\n        }\n        else if (from == 'end') {\n            from = isRtl ? LEFT : RIGHT;\n        }\n        if (isRtl && getRtlScrollAxisType() == 2 /* RtlScrollAxisType.INVERTED */) {\n            // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n            // 0 when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\n            }\n            else {\n                return el.scrollLeft;\n            }\n        }\n        else if (isRtl && getRtlScrollAxisType() == 1 /* RtlScrollAxisType.NEGATED */) {\n            // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n            // 0 when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollLeft + el.scrollWidth - el.clientWidth;\n            }\n            else {\n                return -el.scrollLeft;\n            }\n        }\n        else {\n            // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n            // (scrollWidth - clientWidth) when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollLeft;\n            }\n            else {\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\n            }\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkScrollable, deps: [{ token: i0.ElementRef }, { token: ScrollDispatcher }, { token: i0.NgZone }, { token: i2.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: CdkScrollable, isStandalone: true, selector: \"[cdk-scrollable], [cdkScrollable]\", ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkScrollable, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]',\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: ScrollDispatcher }, { type: i0.NgZone }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }] });\n\n/** Time in ms to throttle the resize events by default. */\nconst DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * @docs-private\n */\nclass ViewportRuler {\n    constructor(_platform, ngZone, document) {\n        this._platform = _platform;\n        /** Stream of viewport change events. */\n        this._change = new Subject();\n        /** Event listener that will be used to handle the viewport change events. */\n        this._changeListener = (event) => {\n            this._change.next(event);\n        };\n        this._document = document;\n        ngZone.runOutsideAngular(() => {\n            if (_platform.isBrowser) {\n                const window = this._getWindow();\n                // Note that bind the events ourselves, rather than going through something like RxJS's\n                // `fromEvent` so that we can ensure that they're bound outside of the NgZone.\n                window.addEventListener('resize', this._changeListener);\n                window.addEventListener('orientationchange', this._changeListener);\n            }\n            // Clear the cached position so that the viewport is re-measured next time it is required.\n            // We don't need to keep track of the subscription, because it is completed on destroy.\n            this.change().subscribe(() => (this._viewportSize = null));\n        });\n    }\n    ngOnDestroy() {\n        if (this._platform.isBrowser) {\n            const window = this._getWindow();\n            window.removeEventListener('resize', this._changeListener);\n            window.removeEventListener('orientationchange', this._changeListener);\n        }\n        this._change.complete();\n    }\n    /** Returns the viewport's width and height. */\n    getViewportSize() {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        const output = { width: this._viewportSize.width, height: this._viewportSize.height };\n        // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n        if (!this._platform.isBrowser) {\n            this._viewportSize = null;\n        }\n        return output;\n    }\n    /** Gets a ClientRect for the viewport's bounds. */\n    getViewportRect() {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        const scrollPosition = this.getViewportScrollPosition();\n        const { width, height } = this.getViewportSize();\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height,\n            width,\n        };\n    }\n    /** Gets the (top, left) scroll position of the viewport. */\n    getViewportScrollPosition() {\n        // While we can get a reference to the fake document\n        // during SSR, it doesn't have getBoundingClientRect.\n        if (!this._platform.isBrowser) {\n            return { top: 0, left: 0 };\n        }\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        const document = this._document;\n        const window = this._getWindow();\n        const documentElement = document.documentElement;\n        const documentRect = documentElement.getBoundingClientRect();\n        const top = -documentRect.top ||\n            document.body.scrollTop ||\n            window.scrollY ||\n            documentElement.scrollTop ||\n            0;\n        const left = -documentRect.left ||\n            document.body.scrollLeft ||\n            window.scrollX ||\n            documentElement.scrollLeft ||\n            0;\n        return { top, left };\n    }\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * This stream emits outside of the Angular zone.\n     * @param throttleTime Time in milliseconds to throttle the stream.\n     */\n    change(throttleTime = DEFAULT_RESIZE_TIME) {\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    /** Updates the cached viewport size. */\n    _updateViewportSize() {\n        const window = this._getWindow();\n        this._viewportSize = this._platform.isBrowser\n            ? { width: window.innerWidth, height: window.innerHeight }\n            : { width: 0, height: 0 };\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ViewportRuler, deps: [{ token: i1.Platform }, { token: i0.NgZone }, { token: DOCUMENT, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ViewportRuler, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ViewportRuler, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.Platform }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n\nconst VIRTUAL_SCROLLABLE = new InjectionToken('VIRTUAL_SCROLLABLE');\n/**\n * Extending the {@link CdkScrollable} to be used as scrolling container for virtual scrolling.\n */\nclass CdkVirtualScrollable extends CdkScrollable {\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\n        super(elementRef, scrollDispatcher, ngZone, dir);\n    }\n    /**\n     * Measure the viewport size for the provided orientation.\n     *\n     * @param orientation The orientation to measure the size from.\n     */\n    measureViewportSize(orientation) {\n        const viewportEl = this.elementRef.nativeElement;\n        return orientation === 'horizontal' ? viewportEl.clientWidth : viewportEl.clientHeight;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkVirtualScrollable, deps: [{ token: i0.ElementRef }, { token: ScrollDispatcher }, { token: i0.NgZone }, { token: i2.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: CdkVirtualScrollable, usesInheritance: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkVirtualScrollable, decorators: [{\n            type: Directive\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: ScrollDispatcher }, { type: i0.NgZone }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }] });\n\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1, r2) {\n    return r1.start == r2.start && r1.end == r2.end;\n}\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\nclass CdkVirtualScrollViewport extends CdkVirtualScrollable {\n    /** The direction the viewport scrolls. */\n    get orientation() {\n        return this._orientation;\n    }\n    set orientation(orientation) {\n        if (this._orientation !== orientation) {\n            this._orientation = orientation;\n            this._calculateSpacerSize();\n        }\n    }\n    constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler, scrollable) {\n        super(elementRef, scrollDispatcher, ngZone, dir);\n        this.elementRef = elementRef;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._scrollStrategy = _scrollStrategy;\n        this.scrollable = scrollable;\n        this._platform = inject(Platform);\n        /** Emits when the viewport is detached from a CdkVirtualForOf. */\n        this._detachedSubject = new Subject();\n        /** Emits when the rendered range changes. */\n        this._renderedRangeSubject = new Subject();\n        this._orientation = 'vertical';\n        /**\n         * Whether rendered items should persist in the DOM after scrolling out of view. By default, items\n         * will be removed.\n         */\n        this.appendOnly = false;\n        // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n        // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n        // depending on how the strategy calculates the scrolled index, it may come at a cost to\n        // performance.\n        /** Emits when the index of the first element visible in the viewport changes. */\n        this.scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe(index => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\n        /** A stream that emits whenever the rendered range changes. */\n        this.renderedRangeStream = this._renderedRangeSubject;\n        /**\n         * The total size of all content (in pixels), including content that is not currently rendered.\n         */\n        this._totalContentSize = 0;\n        /** A string representing the `style.width` property value to be used for the spacer element. */\n        this._totalContentWidth = '';\n        /** A string representing the `style.height` property value to be used for the spacer element. */\n        this._totalContentHeight = '';\n        /** The currently rendered range of indices. */\n        this._renderedRange = { start: 0, end: 0 };\n        /** The length of the data bound to this viewport (in number of items). */\n        this._dataLength = 0;\n        /** The size of the viewport (in pixels). */\n        this._viewportSize = 0;\n        /** The last rendered content offset that was set. */\n        this._renderedContentOffset = 0;\n        /**\n         * Whether the last rendered content offset was to the end of the content (and therefore needs to\n         * be rewritten as an offset to the start of the content).\n         */\n        this._renderedContentOffsetNeedsRewrite = false;\n        /** Whether there is a pending change detection cycle. */\n        this._isChangeDetectionPending = false;\n        /** A list of functions to run after the next change detection cycle. */\n        this._runAfterChangeDetection = [];\n        /** Subscription to changes in the viewport size. */\n        this._viewportChanges = Subscription.EMPTY;\n        if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n        }\n        this._viewportChanges = viewportRuler.change().subscribe(() => {\n            this.checkViewportSize();\n        });\n        if (!this.scrollable) {\n            // No scrollable is provided, so the virtual-scroll-viewport needs to become a scrollable\n            this.elementRef.nativeElement.classList.add('cdk-virtual-scrollable');\n            this.scrollable = this;\n        }\n    }\n    ngOnInit() {\n        // Scrolling depends on the element dimensions which we can't get during SSR.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        if (this.scrollable === this) {\n            super.ngOnInit();\n        }\n        // It's still too early to measure the viewport at this point. Deferring with a promise allows\n        // the Viewport to be rendered with the correct size before we measure. We run this outside the\n        // zone to avoid causing more change detection cycles. We handle the change detection loop\n        // ourselves instead.\n        this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n            this._measureViewportSize();\n            this._scrollStrategy.attach(this);\n            this.scrollable\n                .elementScrolled()\n                .pipe(\n            // Start off with a fake scroll event so we properly detect our initial position.\n            startWith(null), \n            // Collect multiple events into one until the next animation frame. This way if\n            // there are multiple scroll events in the same frame we only need to recheck\n            // our layout once.\n            auditTime(0, SCROLL_SCHEDULER), \n            // Usually `elementScrolled` is completed when the scrollable is destroyed, but\n            // that may not be the case if a `CdkVirtualScrollableElement` is used so we have\n            // to unsubscribe here just in case.\n            takeUntil(this._destroyed))\n                .subscribe(() => this._scrollStrategy.onContentScrolled());\n            this._markChangeDetectionNeeded();\n        }));\n    }\n    ngOnDestroy() {\n        this.detach();\n        this._scrollStrategy.detach();\n        // Complete all subjects\n        this._renderedRangeSubject.complete();\n        this._detachedSubject.complete();\n        this._viewportChanges.unsubscribe();\n        super.ngOnDestroy();\n    }\n    /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\n    attach(forOf) {\n        if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('CdkVirtualScrollViewport is already attached.');\n        }\n        // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n        // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n        // change detection loop ourselves.\n        this.ngZone.runOutsideAngular(() => {\n            this._forOf = forOf;\n            this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\n                const newLength = data.length;\n                if (newLength !== this._dataLength) {\n                    this._dataLength = newLength;\n                    this._scrollStrategy.onDataLengthChanged();\n                }\n                this._doChangeDetection();\n            });\n        });\n    }\n    /** Detaches the current `CdkVirtualForOf`. */\n    detach() {\n        this._forOf = null;\n        this._detachedSubject.next();\n    }\n    /** Gets the length of the data bound to this viewport (in number of items). */\n    getDataLength() {\n        return this._dataLength;\n    }\n    /** Gets the size of the viewport (in pixels). */\n    getViewportSize() {\n        return this._viewportSize;\n    }\n    // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n    // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n    // setting it to something else, but its error prone and should probably be split into\n    // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n    /** Get the current rendered range of items. */\n    getRenderedRange() {\n        return this._renderedRange;\n    }\n    measureBoundingClientRectWithScrollOffset(from) {\n        return this.getElementRef().nativeElement.getBoundingClientRect()[from];\n    }\n    /**\n     * Sets the total size of all content (in pixels), including content that is not currently\n     * rendered.\n     */\n    setTotalContentSize(size) {\n        if (this._totalContentSize !== size) {\n            this._totalContentSize = size;\n            this._calculateSpacerSize();\n            this._markChangeDetectionNeeded();\n        }\n    }\n    /** Sets the currently rendered range of indices. */\n    setRenderedRange(range) {\n        if (!rangesEqual(this._renderedRange, range)) {\n            if (this.appendOnly) {\n                range = { start: 0, end: Math.max(this._renderedRange.end, range.end) };\n            }\n            this._renderedRangeSubject.next((this._renderedRange = range));\n            this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n        }\n    }\n    /**\n     * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n     */\n    getOffsetToRenderedContentStart() {\n        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n    }\n    /**\n     * Sets the offset from the start of the viewport to either the start or end of the rendered data\n     * (in pixels).\n     */\n    setRenderedContentOffset(offset, to = 'to-start') {\n        // In appendOnly, we always start from the top\n        offset = this.appendOnly && to === 'to-start' ? 0 : offset;\n        // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n        // in the negative direction.\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        const isHorizontal = this.orientation == 'horizontal';\n        const axis = isHorizontal ? 'X' : 'Y';\n        const axisDirection = isHorizontal && isRtl ? -1 : 1;\n        let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n        this._renderedContentOffset = offset;\n        if (to === 'to-end') {\n            transform += ` translate${axis}(-100%)`;\n            // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n            // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n            // expand upward).\n            this._renderedContentOffsetNeedsRewrite = true;\n        }\n        if (this._renderedContentTransform != transform) {\n            // We know this value is safe because we parse `offset` with `Number()` before passing it\n            // into the string.\n            this._renderedContentTransform = transform;\n            this._markChangeDetectionNeeded(() => {\n                if (this._renderedContentOffsetNeedsRewrite) {\n                    this._renderedContentOffset -= this.measureRenderedContentSize();\n                    this._renderedContentOffsetNeedsRewrite = false;\n                    this.setRenderedContentOffset(this._renderedContentOffset);\n                }\n                else {\n                    this._scrollStrategy.onRenderedOffsetChanged();\n                }\n            });\n        }\n    }\n    /**\n     * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n     * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n     * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n     * @param offset The offset to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToOffset(offset, behavior = 'auto') {\n        const options = { behavior };\n        if (this.orientation === 'horizontal') {\n            options.start = offset;\n        }\n        else {\n            options.top = offset;\n        }\n        this.scrollable.scrollTo(options);\n    }\n    /**\n     * Scrolls to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToIndex(index, behavior = 'auto') {\n        this._scrollStrategy.scrollToIndex(index, behavior);\n    }\n    /**\n     * Gets the current scroll offset from the start of the scrollable (in pixels).\n     * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n     *     in horizontal mode.\n     */\n    measureScrollOffset(from) {\n        // This is to break the call cycle\n        let measureScrollOffset;\n        if (this.scrollable == this) {\n            measureScrollOffset = (_from) => super.measureScrollOffset(_from);\n        }\n        else {\n            measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);\n        }\n        return Math.max(0, measureScrollOffset(from ?? (this.orientation === 'horizontal' ? 'start' : 'top')) -\n            this.measureViewportOffset());\n    }\n    /**\n     * Measures the offset of the viewport from the scrolling container\n     * @param from The edge to measure from.\n     */\n    measureViewportOffset(from) {\n        let fromRect;\n        const LEFT = 'left';\n        const RIGHT = 'right';\n        const isRtl = this.dir?.value == 'rtl';\n        if (from == 'start') {\n            fromRect = isRtl ? RIGHT : LEFT;\n        }\n        else if (from == 'end') {\n            fromRect = isRtl ? LEFT : RIGHT;\n        }\n        else if (from) {\n            fromRect = from;\n        }\n        else {\n            fromRect = this.orientation === 'horizontal' ? 'left' : 'top';\n        }\n        const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);\n        const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];\n        return viewportClientRect - scrollerClientRect;\n    }\n    /** Measure the combined size of all of the rendered items. */\n    measureRenderedContentSize() {\n        const contentEl = this._contentWrapper.nativeElement;\n        return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n    }\n    /**\n     * Measure the total combined size of the given range. Throws if the range includes items that are\n     * not rendered.\n     */\n    measureRangeSize(range) {\n        if (!this._forOf) {\n            return 0;\n        }\n        return this._forOf.measureRangeSize(range, this.orientation);\n    }\n    /** Update the viewport dimensions and re-render. */\n    checkViewportSize() {\n        // TODO: Cleanup later when add logic for handling content resize\n        this._measureViewportSize();\n        this._scrollStrategy.onDataLengthChanged();\n    }\n    /** Measure the viewport size. */\n    _measureViewportSize() {\n        this._viewportSize = this.scrollable.measureViewportSize(this.orientation);\n    }\n    /** Queue up change detection to run. */\n    _markChangeDetectionNeeded(runAfter) {\n        if (runAfter) {\n            this._runAfterChangeDetection.push(runAfter);\n        }\n        // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n        // properties sequentially we only have to run `_doChangeDetection` once at the end.\n        if (!this._isChangeDetectionPending) {\n            this._isChangeDetectionPending = true;\n            this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n                this._doChangeDetection();\n            }));\n        }\n    }\n    /** Run change detection. */\n    _doChangeDetection() {\n        this._isChangeDetectionPending = false;\n        // Apply the content transform. The transform can't be set via an Angular binding because\n        // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n        // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n        // the `Number` function first to coerce it to a numeric value.\n        this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n        // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n        // from the root, since the repeated items are content projected in. Calling `detectChanges`\n        // instead does not properly check the projected content.\n        this.ngZone.run(() => this._changeDetectorRef.markForCheck());\n        const runAfterChangeDetection = this._runAfterChangeDetection;\n        this._runAfterChangeDetection = [];\n        for (const fn of runAfterChangeDetection) {\n            fn();\n        }\n    }\n    /** Calculates the `style.width` and `style.height` for the spacer element. */\n    _calculateSpacerSize() {\n        this._totalContentHeight =\n            this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\n        this._totalContentWidth =\n            this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkVirtualScrollViewport, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: VIRTUAL_SCROLL_STRATEGY, optional: true }, { token: i2.Directionality, optional: true }, { token: ScrollDispatcher }, { token: ViewportRuler }, { token: VIRTUAL_SCROLLABLE, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"16.1.0\", version: \"17.0.4\", type: CdkVirtualScrollViewport, isStandalone: true, selector: \"cdk-virtual-scroll-viewport\", inputs: { orientation: \"orientation\", appendOnly: [\"appendOnly\", \"appendOnly\", booleanAttribute] }, outputs: { scrolledIndexChange: \"scrolledIndexChange\" }, host: { properties: { \"class.cdk-virtual-scroll-orientation-horizontal\": \"orientation === \\\"horizontal\\\"\", \"class.cdk-virtual-scroll-orientation-vertical\": \"orientation !== \\\"horizontal\\\"\" }, classAttribute: \"cdk-virtual-scroll-viewport\" }, providers: [\n            {\n                provide: CdkScrollable,\n                useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,\n                deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport],\n            },\n        ], viewQueries: [{ propertyName: \"_contentWrapper\", first: true, predicate: [\"contentWrapper\"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\", styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkVirtualScrollViewport, decorators: [{\n            type: Component,\n            args: [{ selector: 'cdk-virtual-scroll-viewport', host: {\n                        'class': 'cdk-virtual-scroll-viewport',\n                        '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\n                        '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"',\n                    }, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, providers: [\n                        {\n                            provide: CdkScrollable,\n                            useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,\n                            deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport],\n                        },\n                    ], template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\", styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\"] }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [VIRTUAL_SCROLL_STRATEGY]\n                }] }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }, { type: ScrollDispatcher }, { type: ViewportRuler }, { type: CdkVirtualScrollable, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [VIRTUAL_SCROLLABLE]\n                }] }], propDecorators: { orientation: [{\n                type: Input\n            }], appendOnly: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], scrolledIndexChange: [{\n                type: Output\n            }], _contentWrapper: [{\n                type: ViewChild,\n                args: ['contentWrapper', { static: true }]\n            }] } });\n\n/** Helper to extract the offset of a DOM Node in a certain direction. */\nfunction getOffset(orientation, direction, node) {\n    const el = node;\n    if (!el.getBoundingClientRect) {\n        return 0;\n    }\n    const rect = el.getBoundingClientRect();\n    if (orientation === 'horizontal') {\n        return direction === 'start' ? rect.left : rect.right;\n    }\n    return direction === 'start' ? rect.top : rect.bottom;\n}\n/**\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\n * container.\n */\nclass CdkVirtualForOf {\n    /** The DataSource to display. */\n    get cdkVirtualForOf() {\n        return this._cdkVirtualForOf;\n    }\n    set cdkVirtualForOf(value) {\n        this._cdkVirtualForOf = value;\n        if (isDataSource(value)) {\n            this._dataSourceChanges.next(value);\n        }\n        else {\n            // If value is an an NgIterable, convert it to an array.\n            this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));\n        }\n    }\n    /**\n     * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n     * the item and produces a value to be used as the item's identity when tracking changes.\n     */\n    get cdkVirtualForTrackBy() {\n        return this._cdkVirtualForTrackBy;\n    }\n    set cdkVirtualForTrackBy(fn) {\n        this._needsUpdate = true;\n        this._cdkVirtualForTrackBy = fn\n            ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item)\n            : undefined;\n    }\n    /** The template used to stamp out new elements. */\n    set cdkVirtualForTemplate(value) {\n        if (value) {\n            this._needsUpdate = true;\n            this._template = value;\n        }\n    }\n    /**\n     * The size of the cache used to store templates that are not being used for re-use later.\n     * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n     */\n    get cdkVirtualForTemplateCacheSize() {\n        return this._viewRepeater.viewCacheSize;\n    }\n    set cdkVirtualForTemplateCacheSize(size) {\n        this._viewRepeater.viewCacheSize = coerceNumberProperty(size);\n    }\n    constructor(\n    /** The view container to add items to. */\n    _viewContainerRef, \n    /** The template to use when stamping out new items. */\n    _template, \n    /** The set of available differs. */\n    _differs, \n    /** The strategy used to render items in the virtual scroll viewport. */\n    _viewRepeater, \n    /** The virtual scrolling viewport that these items are being rendered in. */\n    _viewport, ngZone) {\n        this._viewContainerRef = _viewContainerRef;\n        this._template = _template;\n        this._differs = _differs;\n        this._viewRepeater = _viewRepeater;\n        this._viewport = _viewport;\n        /** Emits when the rendered view of the data changes. */\n        this.viewChange = new Subject();\n        /** Subject that emits when a new DataSource instance is given. */\n        this._dataSourceChanges = new Subject();\n        /** Emits whenever the data in the current DataSource changes. */\n        this.dataStream = this._dataSourceChanges.pipe(\n        // Start off with null `DataSource`.\n        startWith(null), \n        // Bundle up the previous and current data sources so we can work with both.\n        pairwise(), \n        // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n        // new one, passing back a stream of data changes which we run through `switchMap` to give\n        // us a data stream that emits the latest data from whatever the current `DataSource` is.\n        switchMap(([prev, cur]) => this._changeDataSource(prev, cur)), \n        // Replay the last emitted data when someone subscribes.\n        shareReplay(1));\n        /** The differ used to calculate changes to the data. */\n        this._differ = null;\n        /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n        this._needsUpdate = false;\n        this._destroyed = new Subject();\n        this.dataStream.subscribe(data => {\n            this._data = data;\n            this._onRenderedDataChange();\n        });\n        this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(range => {\n            this._renderedRange = range;\n            if (this.viewChange.observers.length) {\n                ngZone.run(() => this.viewChange.next(this._renderedRange));\n            }\n            this._onRenderedDataChange();\n        });\n        this._viewport.attach(this);\n    }\n    /**\n     * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n     * in the specified range. Throws an error if the range includes items that are not currently\n     * rendered.\n     */\n    measureRangeSize(range, orientation) {\n        if (range.start >= range.end) {\n            return 0;\n        }\n        if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error(`Error: attempted to measure an item that isn't rendered.`);\n        }\n        // The index into the list of rendered views for the first item in the range.\n        const renderedStartIndex = range.start - this._renderedRange.start;\n        // The length of the range we're measuring.\n        const rangeLen = range.end - range.start;\n        // Loop over all the views, find the first and land node and compute the size by subtracting\n        // the top of the first node from the bottom of the last one.\n        let firstNode;\n        let lastNode;\n        // Find the first node by starting from the beginning and going forwards.\n        for (let i = 0; i < rangeLen; i++) {\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\n            if (view && view.rootNodes.length) {\n                firstNode = lastNode = view.rootNodes[0];\n                break;\n            }\n        }\n        // Find the last node by starting from the end and going backwards.\n        for (let i = rangeLen - 1; i > -1; i--) {\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\n            if (view && view.rootNodes.length) {\n                lastNode = view.rootNodes[view.rootNodes.length - 1];\n                break;\n            }\n        }\n        return firstNode && lastNode\n            ? getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode)\n            : 0;\n    }\n    ngDoCheck() {\n        if (this._differ && this._needsUpdate) {\n            // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n            // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n            // changing (need to do this diff).\n            const changes = this._differ.diff(this._renderedItems);\n            if (!changes) {\n                this._updateContext();\n            }\n            else {\n                this._applyChanges(changes);\n            }\n            this._needsUpdate = false;\n        }\n    }\n    ngOnDestroy() {\n        this._viewport.detach();\n        this._dataSourceChanges.next(undefined);\n        this._dataSourceChanges.complete();\n        this.viewChange.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._viewRepeater.detach();\n    }\n    /** React to scroll state changes in the viewport. */\n    _onRenderedDataChange() {\n        if (!this._renderedRange) {\n            return;\n        }\n        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n        if (!this._differ) {\n            // Use a wrapper function for the `trackBy` so any new values are\n            // picked up automatically without having to recreate the differ.\n            this._differ = this._differs.find(this._renderedItems).create((index, item) => {\n                return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;\n            });\n        }\n        this._needsUpdate = true;\n    }\n    /** Swap out one `DataSource` for another. */\n    _changeDataSource(oldDs, newDs) {\n        if (oldDs) {\n            oldDs.disconnect(this);\n        }\n        this._needsUpdate = true;\n        return newDs ? newDs.connect(this) : of();\n    }\n    /** Update the `CdkVirtualForOfContext` for all views. */\n    _updateContext() {\n        const count = this._data.length;\n        let i = this._viewContainerRef.length;\n        while (i--) {\n            const view = this._viewContainerRef.get(i);\n            view.context.index = this._renderedRange.start + i;\n            view.context.count = count;\n            this._updateComputedContextProperties(view.context);\n            view.detectChanges();\n        }\n    }\n    /** Apply changes to the DOM. */\n    _applyChanges(changes) {\n        this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), record => record.item);\n        // Update $implicit for any items that had an identity change.\n        changes.forEachIdentityChange((record) => {\n            const view = this._viewContainerRef.get(record.currentIndex);\n            view.context.$implicit = record.item;\n        });\n        // Update the context variables on all items.\n        const count = this._data.length;\n        let i = this._viewContainerRef.length;\n        while (i--) {\n            const view = this._viewContainerRef.get(i);\n            view.context.index = this._renderedRange.start + i;\n            view.context.count = count;\n            this._updateComputedContextProperties(view.context);\n        }\n    }\n    /** Update the computed properties on the `CdkVirtualForOfContext`. */\n    _updateComputedContextProperties(context) {\n        context.first = context.index === 0;\n        context.last = context.index === context.count - 1;\n        context.even = context.index % 2 === 0;\n        context.odd = !context.even;\n    }\n    _getEmbeddedViewArgs(record, index) {\n        // Note that it's important that we insert the item directly at the proper index,\n        // rather than inserting it and the moving it in place, because if there's a directive\n        // on the same node that injects the `ViewContainerRef`, Angular will insert another\n        // comment node which can throw off the move when it's being repeated for all items.\n        return {\n            templateRef: this._template,\n            context: {\n                $implicit: record.item,\n                // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n                // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n                cdkVirtualForOf: this._cdkVirtualForOf,\n                index: -1,\n                count: -1,\n                first: false,\n                last: false,\n                odd: false,\n                even: false,\n            },\n            index,\n        };\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkVirtualForOf, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i0.IterableDiffers }, { token: _VIEW_REPEATER_STRATEGY }, { token: CdkVirtualScrollViewport, skipSelf: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: CdkVirtualForOf, isStandalone: true, selector: \"[cdkVirtualFor][cdkVirtualForOf]\", inputs: { cdkVirtualForOf: \"cdkVirtualForOf\", cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\", cdkVirtualForTemplate: \"cdkVirtualForTemplate\", cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\" }, providers: [{ provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy }], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkVirtualForOf, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkVirtualFor][cdkVirtualForOf]',\n                    providers: [{ provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy }],\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i0.IterableDiffers }, { type: i2$1._RecycleViewRepeaterStrategy, decorators: [{\n                    type: Inject,\n                    args: [_VIEW_REPEATER_STRATEGY]\n                }] }, { type: CdkVirtualScrollViewport, decorators: [{\n                    type: SkipSelf\n                }] }, { type: i0.NgZone }], propDecorators: { cdkVirtualForOf: [{\n                type: Input\n            }], cdkVirtualForTrackBy: [{\n                type: Input\n            }], cdkVirtualForTemplate: [{\n                type: Input\n            }], cdkVirtualForTemplateCacheSize: [{\n                type: Input\n            }] } });\n\n/**\n * Provides a virtual scrollable for the element it is attached to.\n */\nclass CdkVirtualScrollableElement extends CdkVirtualScrollable {\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\n        super(elementRef, scrollDispatcher, ngZone, dir);\n    }\n    measureBoundingClientRectWithScrollOffset(from) {\n        return (this.getElementRef().nativeElement.getBoundingClientRect()[from] -\n            this.measureScrollOffset(from));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkVirtualScrollableElement, deps: [{ token: i0.ElementRef }, { token: ScrollDispatcher }, { token: i0.NgZone }, { token: i2.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: CdkVirtualScrollableElement, isStandalone: true, selector: \"[cdkVirtualScrollingElement]\", host: { classAttribute: \"cdk-virtual-scrollable\" }, providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableElement }], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkVirtualScrollableElement, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkVirtualScrollingElement]',\n                    providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableElement }],\n                    standalone: true,\n                    host: {\n                        'class': 'cdk-virtual-scrollable',\n                    },\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: ScrollDispatcher }, { type: i0.NgZone }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }] });\n\n/**\n * Provides as virtual scrollable for the global / window scrollbar.\n */\nclass CdkVirtualScrollableWindow extends CdkVirtualScrollable {\n    constructor(scrollDispatcher, ngZone, dir) {\n        super(new ElementRef(document.documentElement), scrollDispatcher, ngZone, dir);\n        this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(document, 'scroll').pipe(takeUntil(this._destroyed)).subscribe(observer)));\n    }\n    measureBoundingClientRectWithScrollOffset(from) {\n        return this.getElementRef().nativeElement.getBoundingClientRect()[from];\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkVirtualScrollableWindow, deps: [{ token: ScrollDispatcher }, { token: i0.NgZone }, { token: i2.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: CdkVirtualScrollableWindow, isStandalone: true, selector: \"cdk-virtual-scroll-viewport[scrollWindow]\", providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableWindow }], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkVirtualScrollableWindow, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'cdk-virtual-scroll-viewport[scrollWindow]',\n                    providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableWindow }],\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: ScrollDispatcher }, { type: i0.NgZone }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }] });\n\nclass CdkScrollableModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkScrollableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkScrollableModule, imports: [CdkScrollable], exports: [CdkScrollable] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkScrollableModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkScrollableModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [CdkScrollable],\n                    imports: [CdkScrollable],\n                }]\n        }] });\n/**\n * @docs-primary-export\n */\nclass ScrollingModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ScrollingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.4\", ngImport: i0, type: ScrollingModule, imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport,\n            CdkFixedSizeVirtualScroll,\n            CdkVirtualForOf,\n            CdkVirtualScrollableWindow,\n            CdkVirtualScrollableElement], exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll,\n            CdkVirtualForOf,\n            CdkVirtualScrollViewport,\n            CdkVirtualScrollableWindow,\n            CdkVirtualScrollableElement] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ScrollingModule, imports: [BidiModule,\n            CdkScrollableModule, BidiModule, CdkScrollableModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ScrollingModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        BidiModule,\n                        CdkScrollableModule,\n                        CdkVirtualScrollViewport,\n                        CdkFixedSizeVirtualScroll,\n                        CdkVirtualForOf,\n                        CdkVirtualScrollableWindow,\n                        CdkVirtualScrollableElement,\n                    ],\n                    exports: [\n                        BidiModule,\n                        CdkScrollableModule,\n                        CdkFixedSizeVirtualScroll,\n                        CdkVirtualForOf,\n                        CdkVirtualScrollViewport,\n                        CdkVirtualScrollableWindow,\n                        CdkVirtualScrollableElement,\n                    ],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkFixedSizeVirtualScroll, CdkScrollable, CdkScrollableModule, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollable, CdkVirtualScrollableElement, CdkVirtualScrollableWindow, DEFAULT_RESIZE_TIME, DEFAULT_SCROLL_TIME, FixedSizeVirtualScrollStrategy, ScrollDispatcher, ScrollingModule, VIRTUAL_SCROLLABLE, VIRTUAL_SCROLL_STRATEGY, ViewportRuler, _fixedSizeVirtualScrollStrategyFactory };\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, EventEmitter, Injectable, Optional, Inject, Directive, Output, Input, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-browser because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * @docs-private\n */\nconst DIR_DOCUMENT = new InjectionToken('cdk-dir-doc', {\n    providedIn: 'root',\n    factory: DIR_DOCUMENT_FACTORY,\n});\n/** @docs-private */\nfunction DIR_DOCUMENT_FACTORY() {\n    return inject(DOCUMENT);\n}\n\n/** Regex that matches locales with an RTL script. Taken from `goog.i18n.bidi.isRtlLanguage`. */\nconst RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;\n/** Resolves a string value to a specific direction. */\nfunction _resolveDirectionality(rawValue) {\n    const value = rawValue?.toLowerCase() || '';\n    if (value === 'auto' && typeof navigator !== 'undefined' && navigator?.language) {\n        return RTL_LOCALE_PATTERN.test(navigator.language) ? 'rtl' : 'ltr';\n    }\n    return value === 'rtl' ? 'rtl' : 'ltr';\n}\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nclass Directionality {\n    constructor(_document) {\n        /** The current 'ltr' or 'rtl' value. */\n        this.value = 'ltr';\n        /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\n        this.change = new EventEmitter();\n        if (_document) {\n            const bodyDir = _document.body ? _document.body.dir : null;\n            const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = _resolveDirectionality(bodyDir || htmlDir || 'ltr');\n        }\n    }\n    ngOnDestroy() {\n        this.change.complete();\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: Directionality, deps: [{ token: DIR_DOCUMENT, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: Directionality, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: Directionality, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DIR_DOCUMENT]\n                }] }] });\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nclass Dir {\n    constructor() {\n        /** Normalized direction that accounts for invalid/unsupported values. */\n        this._dir = 'ltr';\n        /** Whether the `value` has been set to its initial value. */\n        this._isInitialized = false;\n        /** Event emitted when the direction changes. */\n        this.change = new EventEmitter();\n    }\n    /** @docs-private */\n    get dir() {\n        return this._dir;\n    }\n    set dir(value) {\n        const previousValue = this._dir;\n        // Note: `_resolveDirectionality` resolves the language based on the browser's language,\n        // whereas the browser does it based on the content of the element. Since doing so based\n        // on the content can be expensive, for now we're doing the simpler matching.\n        this._dir = _resolveDirectionality(value);\n        this._rawDir = value;\n        if (previousValue !== this._dir && this._isInitialized) {\n            this.change.emit(this._dir);\n        }\n    }\n    /** Current layout direction of the element. */\n    get value() {\n        return this.dir;\n    }\n    /** Initialize once default value has been set. */\n    ngAfterContentInit() {\n        this._isInitialized = true;\n    }\n    ngOnDestroy() {\n        this.change.complete();\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: Dir, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: Dir, selector: \"[dir]\", inputs: { dir: \"dir\" }, outputs: { change: \"dirChange\" }, host: { properties: { \"attr.dir\": \"_rawDir\" } }, providers: [{ provide: Directionality, useExisting: Dir }], exportAs: [\"dir\"], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: Dir, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: Directionality, useExisting: Dir }],\n                    host: { '[attr.dir]': '_rawDir' },\n                    exportAs: 'dir',\n                }]\n        }], propDecorators: { change: [{\n                type: Output,\n                args: ['dirChange']\n            }], dir: [{\n                type: Input\n            }] } });\n\nclass BidiModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: BidiModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.4\", ngImport: i0, type: BidiModule, declarations: [Dir], exports: [Dir] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: BidiModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: BidiModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [Dir],\n                    declarations: [Dir],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BidiModule, DIR_DOCUMENT, Dir, Directionality };\n","import * as i0 from '@angular/core';\nimport { Injectable, Inject, InjectionToken, booleanAttribute, Directive, Optional, SkipSelf, Input, EventEmitter, Self, ContentChildren, ContentChild, Output, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport * as i1 from '@angular/cdk/scrolling';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport { _getEventTarget, normalizePassiveListenerOptions, _getShadowRoot } from '@angular/cdk/platform';\nimport { coerceElement, coerceNumberProperty, coerceArray } from '@angular/cdk/coercion';\nimport { isFakeTouchstartFromScreenReader, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { Subject, Subscription, interval, animationFrameScheduler, Observable, merge } from 'rxjs';\nimport { takeUntil, map, take, startWith, tap, switchMap } from 'rxjs/operators';\nimport * as i1$1 from '@angular/cdk/bidi';\n\n/**\n * Shallow-extends a stylesheet object with another stylesheet-like object.\n * Note that the keys in `source` have to be dash-cased.\n * @docs-private\n */\nfunction extendStyles(dest, source, importantProperties) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            const value = source[key];\n            if (value) {\n                dest.setProperty(key, value, importantProperties?.has(key) ? 'important' : '');\n            }\n            else {\n                dest.removeProperty(key);\n            }\n        }\n    }\n    return dest;\n}\n/**\n * Toggles whether the native drag interactions should be enabled for an element.\n * @param element Element on which to toggle the drag interactions.\n * @param enable Whether the drag interactions should be enabled.\n * @docs-private\n */\nfunction toggleNativeDragInteractions(element, enable) {\n    const userSelect = enable ? '' : 'none';\n    extendStyles(element.style, {\n        'touch-action': enable ? '' : 'none',\n        '-webkit-user-drag': enable ? '' : 'none',\n        '-webkit-tap-highlight-color': enable ? '' : 'transparent',\n        'user-select': userSelect,\n        '-ms-user-select': userSelect,\n        '-webkit-user-select': userSelect,\n        '-moz-user-select': userSelect,\n    });\n}\n/**\n * Toggles whether an element is visible while preserving its dimensions.\n * @param element Element whose visibility to toggle\n * @param enable Whether the element should be visible.\n * @param importantProperties Properties to be set as `!important`.\n * @docs-private\n */\nfunction toggleVisibility(element, enable, importantProperties) {\n    extendStyles(element.style, {\n        position: enable ? '' : 'fixed',\n        top: enable ? '' : '0',\n        opacity: enable ? '' : '0',\n        left: enable ? '' : '-999em',\n    }, importantProperties);\n}\n/**\n * Combines a transform string with an optional other transform\n * that exited before the base transform was applied.\n */\nfunction combineTransforms(transform, initialTransform) {\n    return initialTransform && initialTransform != 'none'\n        ? transform + ' ' + initialTransform\n        : transform;\n}\n\n/** Parses a CSS time value to milliseconds. */\nfunction parseCssTimeUnitsToMs(value) {\n    // Some browsers will return it in seconds, whereas others will return milliseconds.\n    const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n    return parseFloat(value) * multiplier;\n}\n/** Gets the transform transition duration, including the delay, of an element in milliseconds. */\nfunction getTransformTransitionDurationInMs(element) {\n    const computedStyle = getComputedStyle(element);\n    const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');\n    const property = transitionedProperties.find(prop => prop === 'transform' || prop === 'all');\n    // If there's no transition for `all` or `transform`, we shouldn't do anything.\n    if (!property) {\n        return 0;\n    }\n    // Get the index of the property that we're interested in and match\n    // it up to the same index in `transition-delay` and `transition-duration`.\n    const propertyIndex = transitionedProperties.indexOf(property);\n    const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');\n    const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');\n    return (parseCssTimeUnitsToMs(rawDurations[propertyIndex]) +\n        parseCssTimeUnitsToMs(rawDelays[propertyIndex]));\n}\n/** Parses out multiple values from a computed style into an array. */\nfunction parseCssPropertyValue(computedStyle, name) {\n    const value = computedStyle.getPropertyValue(name);\n    return value.split(',').map(part => part.trim());\n}\n\n/** Gets a mutable version of an element's bounding `ClientRect`. */\nfunction getMutableClientRect(element) {\n    const clientRect = element.getBoundingClientRect();\n    // We need to clone the `clientRect` here, because all the values on it are readonly\n    // and we need to be able to update them. Also we can't use a spread here, because\n    // the values on a `ClientRect` aren't own properties. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n    return {\n        top: clientRect.top,\n        right: clientRect.right,\n        bottom: clientRect.bottom,\n        left: clientRect.left,\n        width: clientRect.width,\n        height: clientRect.height,\n        x: clientRect.x,\n        y: clientRect.y,\n    };\n}\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param clientRect ClientRect that is being checked.\n * @param x Coordinates along the X axis.\n * @param y Coordinates along the Y axis.\n */\nfunction isInsideClientRect(clientRect, x, y) {\n    const { top, bottom, left, right } = clientRect;\n    return y >= top && y <= bottom && x >= left && x <= right;\n}\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param clientRect `ClientRect` that should be updated.\n * @param top Amount to add to the `top` position.\n * @param left Amount to add to the `left` position.\n */\nfunction adjustClientRect(clientRect, top, left) {\n    clientRect.top += top;\n    clientRect.bottom = clientRect.top + clientRect.height;\n    clientRect.left += left;\n    clientRect.right = clientRect.left + clientRect.width;\n}\n/**\n * Checks whether the pointer coordinates are close to a ClientRect.\n * @param rect ClientRect to check against.\n * @param threshold Threshold around the ClientRect.\n * @param pointerX Coordinates along the X axis.\n * @param pointerY Coordinates along the Y axis.\n */\nfunction isPointerNearClientRect(rect, threshold, pointerX, pointerY) {\n    const { top, right, bottom, left, width, height } = rect;\n    const xThreshold = width * threshold;\n    const yThreshold = height * threshold;\n    return (pointerY > top - yThreshold &&\n        pointerY < bottom + yThreshold &&\n        pointerX > left - xThreshold &&\n        pointerX < right + xThreshold);\n}\n\n/** Keeps track of the scroll position and dimensions of the parents of an element. */\nclass ParentPositionTracker {\n    constructor(_document) {\n        this._document = _document;\n        /** Cached positions of the scrollable parent elements. */\n        this.positions = new Map();\n    }\n    /** Clears the cached positions. */\n    clear() {\n        this.positions.clear();\n    }\n    /** Caches the positions. Should be called at the beginning of a drag sequence. */\n    cache(elements) {\n        this.clear();\n        this.positions.set(this._document, {\n            scrollPosition: this.getViewportScrollPosition(),\n        });\n        elements.forEach(element => {\n            this.positions.set(element, {\n                scrollPosition: { top: element.scrollTop, left: element.scrollLeft },\n                clientRect: getMutableClientRect(element),\n            });\n        });\n    }\n    /** Handles scrolling while a drag is taking place. */\n    handleScroll(event) {\n        const target = _getEventTarget(event);\n        const cachedPosition = this.positions.get(target);\n        if (!cachedPosition) {\n            return null;\n        }\n        const scrollPosition = cachedPosition.scrollPosition;\n        let newTop;\n        let newLeft;\n        if (target === this._document) {\n            const viewportScrollPosition = this.getViewportScrollPosition();\n            newTop = viewportScrollPosition.top;\n            newLeft = viewportScrollPosition.left;\n        }\n        else {\n            newTop = target.scrollTop;\n            newLeft = target.scrollLeft;\n        }\n        const topDifference = scrollPosition.top - newTop;\n        const leftDifference = scrollPosition.left - newLeft;\n        // Go through and update the cached positions of the scroll\n        // parents that are inside the element that was scrolled.\n        this.positions.forEach((position, node) => {\n            if (position.clientRect && target !== node && target.contains(node)) {\n                adjustClientRect(position.clientRect, topDifference, leftDifference);\n            }\n        });\n        scrollPosition.top = newTop;\n        scrollPosition.left = newLeft;\n        return { top: topDifference, left: leftDifference };\n    }\n    /**\n     * Gets the scroll position of the viewport. Note that we use the scrollX and scrollY directly,\n     * instead of going through the `ViewportRuler`, because the first value the ruler looks at is\n     * the top/left offset of the `document.documentElement` which works for most cases, but breaks\n     * if the element is offset by something like the `BlockScrollStrategy`.\n     */\n    getViewportScrollPosition() {\n        return { top: window.scrollY, left: window.scrollX };\n    }\n}\n\n/** Creates a deep clone of an element. */\nfunction deepCloneNode(node) {\n    const clone = node.cloneNode(true);\n    const descendantsWithId = clone.querySelectorAll('[id]');\n    const nodeName = node.nodeName.toLowerCase();\n    // Remove the `id` to avoid having multiple elements with the same id on the page.\n    clone.removeAttribute('id');\n    for (let i = 0; i < descendantsWithId.length; i++) {\n        descendantsWithId[i].removeAttribute('id');\n    }\n    if (nodeName === 'canvas') {\n        transferCanvasData(node, clone);\n    }\n    else if (nodeName === 'input' || nodeName === 'select' || nodeName === 'textarea') {\n        transferInputData(node, clone);\n    }\n    transferData('canvas', node, clone, transferCanvasData);\n    transferData('input, textarea, select', node, clone, transferInputData);\n    return clone;\n}\n/** Matches elements between an element and its clone and allows for their data to be cloned. */\nfunction transferData(selector, node, clone, callback) {\n    const descendantElements = node.querySelectorAll(selector);\n    if (descendantElements.length) {\n        const cloneElements = clone.querySelectorAll(selector);\n        for (let i = 0; i < descendantElements.length; i++) {\n            callback(descendantElements[i], cloneElements[i]);\n        }\n    }\n}\n// Counter for unique cloned radio button names.\nlet cloneUniqueId = 0;\n/** Transfers the data of one input element to another. */\nfunction transferInputData(source, clone) {\n    // Browsers throw an error when assigning the value of a file input programmatically.\n    if (clone.type !== 'file') {\n        clone.value = source.value;\n    }\n    // Radio button `name` attributes must be unique for radio button groups\n    // otherwise original radio buttons can lose their checked state\n    // once the clone is inserted in the DOM.\n    if (clone.type === 'radio' && clone.name) {\n        clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;\n    }\n}\n/** Transfers the data of one canvas element to another. */\nfunction transferCanvasData(source, clone) {\n    const context = clone.getContext('2d');\n    if (context) {\n        // In some cases `drawImage` can throw (e.g. if the canvas size is 0x0).\n        // We can't do much about it so just ignore the error.\n        try {\n            context.drawImage(source, 0, 0);\n        }\n        catch { }\n    }\n}\n\n/** Options that can be used to bind a passive event listener. */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n/** Options that can be used to bind an active event listener. */\nconst activeEventListenerOptions = normalizePassiveListenerOptions({ passive: false });\n/**\n * Time in milliseconds for which to ignore mouse events, after\n * receiving a touch event. Used to avoid doing double work for\n * touch devices where the browser fires fake mouse events, in\n * addition to touch events.\n */\nconst MOUSE_EVENT_IGNORE_TIME = 800;\n/** Inline styles to be set as `!important` while dragging. */\nconst dragImportantProperties = new Set([\n    // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.\n    'position',\n]);\n/**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n */\nclass DragRef {\n    /** Whether starting to drag this element is disabled. */\n    get disabled() {\n        return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);\n    }\n    set disabled(value) {\n        if (value !== this._disabled) {\n            this._disabled = value;\n            this._toggleNativeDragInteractions();\n            this._handles.forEach(handle => toggleNativeDragInteractions(handle, value));\n        }\n    }\n    constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._config = _config;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * CSS `transform` applied to the element when it isn't being dragged. We need a\n         * passive transform in order for the dragged element to retain its new position\n         * after the user has stopped dragging and because we need to know the relative\n         * position in case they start dragging again. This corresponds to `element.style.transform`.\n         */\n        this._passiveTransform = { x: 0, y: 0 };\n        /** CSS `transform` that is applied to the element while it's being dragged. */\n        this._activeTransform = { x: 0, y: 0 };\n        /**\n         * Whether the dragging sequence has been started. Doesn't\n         * necessarily mean that the element has been moved.\n         */\n        this._hasStartedDragging = false;\n        /** Emits when the item is being moved. */\n        this._moveEvents = new Subject();\n        /** Subscription to pointer movement events. */\n        this._pointerMoveSubscription = Subscription.EMPTY;\n        /** Subscription to the event that is dispatched when the user lifts their pointer. */\n        this._pointerUpSubscription = Subscription.EMPTY;\n        /** Subscription to the viewport being scrolled. */\n        this._scrollSubscription = Subscription.EMPTY;\n        /** Subscription to the viewport being resized. */\n        this._resizeSubscription = Subscription.EMPTY;\n        /** Cached reference to the boundary element. */\n        this._boundaryElement = null;\n        /** Whether the native dragging interactions have been enabled on the root element. */\n        this._nativeInteractionsEnabled = true;\n        /** Elements that can be used to drag the draggable item. */\n        this._handles = [];\n        /** Registered handles that are currently disabled. */\n        this._disabledHandles = new Set();\n        /** Layout direction of the item. */\n        this._direction = 'ltr';\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /** Emits as the drag sequence is being prepared. */\n        this.beforeStarted = new Subject();\n        /** Emits when the user starts dragging the item. */\n        this.started = new Subject();\n        /** Emits when the user has released a drag item, before any animations have started. */\n        this.released = new Subject();\n        /** Emits when the user stops dragging an item in the container. */\n        this.ended = new Subject();\n        /** Emits when the user has moved the item into a new container. */\n        this.entered = new Subject();\n        /** Emits when the user removes the item its container by dragging it into another container. */\n        this.exited = new Subject();\n        /** Emits when the user drops the item inside a container. */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = this._moveEvents;\n        /** Handler for the `mousedown`/`touchstart` events. */\n        this._pointerDown = (event) => {\n            this.beforeStarted.next();\n            // Delegate the event based on whether it started from a handle or the element itself.\n            if (this._handles.length) {\n                const targetHandle = this._getTargetHandle(event);\n                if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n                    this._initializeDragSequence(targetHandle, event);\n                }\n            }\n            else if (!this.disabled) {\n                this._initializeDragSequence(this._rootElement, event);\n            }\n        };\n        /** Handler that is invoked when the user moves their pointer after they've initiated a drag. */\n        this._pointerMove = (event) => {\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            if (!this._hasStartedDragging) {\n                const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);\n                const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);\n                const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;\n                // Only start dragging after the user has moved more than the minimum distance in either\n                // direction. Note that this is preferable over doing something like `skip(minimumDistance)`\n                // in the `pointerMove` subscription, because we're not guaranteed to have one move event\n                // per pixel of movement (e.g. if the user moves their pointer quickly).\n                if (isOverThreshold) {\n                    const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);\n                    const container = this._dropContainer;\n                    if (!isDelayElapsed) {\n                        this._endDragSequence(event);\n                        return;\n                    }\n                    // Prevent other drag sequences from starting while something in the container is still\n                    // being dragged. This can happen while we're waiting for the drop animation to finish\n                    // and can cause errors, because some elements might still be moving around.\n                    if (!container || (!container.isDragging() && !container.isReceiving())) {\n                        // Prevent the default action as soon as the dragging sequence is considered as\n                        // \"started\" since waiting for the next event can allow the device to begin scrolling.\n                        event.preventDefault();\n                        this._hasStartedDragging = true;\n                        this._ngZone.run(() => this._startDragSequence(event));\n                    }\n                }\n                return;\n            }\n            // We prevent the default action down here so that we know that dragging has started. This is\n            // important for touch devices where doing this too early can unnecessarily block scrolling,\n            // if there's a dragging delay.\n            event.preventDefault();\n            const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);\n            this._hasMoved = true;\n            this._lastKnownPointerPosition = pointerPosition;\n            this._updatePointerDirectionDelta(constrainedPointerPosition);\n            if (this._dropContainer) {\n                this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);\n            }\n            else {\n                // If there's a position constraint function, we want the element's top/left to be at the\n                // specific position on the page. Use the initial position as a reference if that's the case.\n                const offset = this.constrainPosition ? this._initialClientRect : this._pickupPositionOnPage;\n                const activeTransform = this._activeTransform;\n                activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;\n                activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;\n                this._applyRootElementTransform(activeTransform.x, activeTransform.y);\n            }\n            // Since this event gets fired for every pixel while dragging, we only\n            // want to fire it if the consumer opted into it. Also we have to\n            // re-enter the zone because we run all of the events on the outside.\n            if (this._moveEvents.observers.length) {\n                this._ngZone.run(() => {\n                    this._moveEvents.next({\n                        source: this,\n                        pointerPosition: constrainedPointerPosition,\n                        event,\n                        distance: this._getDragDistance(constrainedPointerPosition),\n                        delta: this._pointerDirectionDelta,\n                    });\n                });\n            }\n        };\n        /** Handler that is invoked when the user lifts their pointer up, after initiating a drag. */\n        this._pointerUp = (event) => {\n            this._endDragSequence(event);\n        };\n        /** Handles a native `dragstart` event. */\n        this._nativeDragStart = (event) => {\n            if (this._handles.length) {\n                const targetHandle = this._getTargetHandle(event);\n                if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n                    event.preventDefault();\n                }\n            }\n            else if (!this.disabled) {\n                // Usually this isn't necessary since the we prevent the default action in `pointerDown`,\n                // but some cases like dragging of links can slip through (see #24403).\n                event.preventDefault();\n            }\n        };\n        this.withRootElement(element).withParent(_config.parentDragRef || null);\n        this._parentPositions = new ParentPositionTracker(_document);\n        _dragDropRegistry.registerDragItem(this);\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     */\n    getPlaceholderElement() {\n        return this._placeholder;\n    }\n    /** Returns the root draggable element. */\n    getRootElement() {\n        return this._rootElement;\n    }\n    /**\n     * Gets the currently-visible element that represents the drag item.\n     * While dragging this is the placeholder, otherwise it's the root element.\n     */\n    getVisibleElement() {\n        return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();\n    }\n    /** Registers the handles that can be used to drag the element. */\n    withHandles(handles) {\n        this._handles = handles.map(handle => coerceElement(handle));\n        this._handles.forEach(handle => toggleNativeDragInteractions(handle, this.disabled));\n        this._toggleNativeDragInteractions();\n        // Delete any lingering disabled handles that may have been destroyed. Note that we re-create\n        // the set, rather than iterate over it and filter out the destroyed handles, because while\n        // the ES spec allows for sets to be modified while they're being iterated over, some polyfills\n        // use an array internally which may throw an error.\n        const disabledHandles = new Set();\n        this._disabledHandles.forEach(handle => {\n            if (this._handles.indexOf(handle) > -1) {\n                disabledHandles.add(handle);\n            }\n        });\n        this._disabledHandles = disabledHandles;\n        return this;\n    }\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @param template Template that from which to stamp out the preview.\n     */\n    withPreviewTemplate(template) {\n        this._previewTemplate = template;\n        return this;\n    }\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @param template Template that from which to stamp out the placeholder.\n     */\n    withPlaceholderTemplate(template) {\n        this._placeholderTemplate = template;\n        return this;\n    }\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     */\n    withRootElement(rootElement) {\n        const element = coerceElement(rootElement);\n        if (element !== this._rootElement) {\n            if (this._rootElement) {\n                this._removeRootElementListeners(this._rootElement);\n            }\n            this._ngZone.runOutsideAngular(() => {\n                element.addEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n                element.addEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n                element.addEventListener('dragstart', this._nativeDragStart, activeEventListenerOptions);\n            });\n            this._initialTransform = undefined;\n            this._rootElement = element;\n        }\n        if (typeof SVGElement !== 'undefined' && this._rootElement instanceof SVGElement) {\n            this._ownerSVGElement = this._rootElement.ownerSVGElement;\n        }\n        return this;\n    }\n    /**\n     * Element to which the draggable's position will be constrained.\n     */\n    withBoundaryElement(boundaryElement) {\n        this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;\n        this._resizeSubscription.unsubscribe();\n        if (boundaryElement) {\n            this._resizeSubscription = this._viewportRuler\n                .change(10)\n                .subscribe(() => this._containInsideBoundaryOnResize());\n        }\n        return this;\n    }\n    /** Sets the parent ref that the ref is nested in.  */\n    withParent(parent) {\n        this._parentDragRef = parent;\n        return this;\n    }\n    /** Removes the dragging functionality from the DOM element. */\n    dispose() {\n        this._removeRootElementListeners(this._rootElement);\n        // Do this check before removing from the registry since it'll\n        // stop being considered as dragged once it is removed.\n        if (this.isDragging()) {\n            // Since we move out the element to the end of the body while it's being\n            // dragged, we have to make sure that it's removed if it gets destroyed.\n            this._rootElement?.remove();\n        }\n        this._anchor?.remove();\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._dragDropRegistry.removeDragItem(this);\n        this._removeSubscriptions();\n        this.beforeStarted.complete();\n        this.started.complete();\n        this.released.complete();\n        this.ended.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this._moveEvents.complete();\n        this._handles = [];\n        this._disabledHandles.clear();\n        this._dropContainer = undefined;\n        this._resizeSubscription.unsubscribe();\n        this._parentPositions.clear();\n        this._boundaryElement =\n            this._rootElement =\n                this._ownerSVGElement =\n                    this._placeholderTemplate =\n                        this._previewTemplate =\n                            this._anchor =\n                                this._parentDragRef =\n                                    null;\n    }\n    /** Checks whether the element is currently being dragged. */\n    isDragging() {\n        return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);\n    }\n    /** Resets a standalone drag item to its initial position. */\n    reset() {\n        this._rootElement.style.transform = this._initialTransform || '';\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform = { x: 0, y: 0 };\n    }\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param handle Handle element that should be disabled.\n     */\n    disableHandle(handle) {\n        if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {\n            this._disabledHandles.add(handle);\n            toggleNativeDragInteractions(handle, true);\n        }\n    }\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param handle Handle element to be enabled.\n     */\n    enableHandle(handle) {\n        if (this._disabledHandles.has(handle)) {\n            this._disabledHandles.delete(handle);\n            toggleNativeDragInteractions(handle, this.disabled);\n        }\n    }\n    /** Sets the layout direction of the draggable item. */\n    withDirection(direction) {\n        this._direction = direction;\n        return this;\n    }\n    /** Sets the container that the item is part of. */\n    _withDropContainer(container) {\n        this._dropContainer = container;\n    }\n    /**\n     * Gets the current position in pixels the draggable outside of a drop container.\n     */\n    getFreeDragPosition() {\n        const position = this.isDragging() ? this._activeTransform : this._passiveTransform;\n        return { x: position.x, y: position.y };\n    }\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @param value New position to be set.\n     */\n    setFreeDragPosition(value) {\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform.x = value.x;\n        this._passiveTransform.y = value.y;\n        if (!this._dropContainer) {\n            this._applyRootElementTransform(value.x, value.y);\n        }\n        return this;\n    }\n    /**\n     * Sets the container into which to insert the preview element.\n     * @param value Container into which to insert the preview.\n     */\n    withPreviewContainer(value) {\n        this._previewContainer = value;\n        return this;\n    }\n    /** Updates the item's sort order based on the last-known pointer position. */\n    _sortFromLastPointerPosition() {\n        const position = this._lastKnownPointerPosition;\n        if (position && this._dropContainer) {\n            this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);\n        }\n    }\n    /** Unsubscribes from the global subscriptions. */\n    _removeSubscriptions() {\n        this._pointerMoveSubscription.unsubscribe();\n        this._pointerUpSubscription.unsubscribe();\n        this._scrollSubscription.unsubscribe();\n    }\n    /** Destroys the preview element and its ViewRef. */\n    _destroyPreview() {\n        this._preview?.remove();\n        this._previewRef?.destroy();\n        this._preview = this._previewRef = null;\n    }\n    /** Destroys the placeholder element and its ViewRef. */\n    _destroyPlaceholder() {\n        this._placeholder?.remove();\n        this._placeholderRef?.destroy();\n        this._placeholder = this._placeholderRef = null;\n    }\n    /**\n     * Clears subscriptions and stops the dragging sequence.\n     * @param event Browser event object that ended the sequence.\n     */\n    _endDragSequence(event) {\n        // Note that here we use `isDragging` from the service, rather than from `this`.\n        // The difference is that the one from the service reflects whether a dragging sequence\n        // has been initiated, whereas the one on `this` includes whether the user has passed\n        // the minimum dragging threshold.\n        if (!this._dragDropRegistry.isDragging(this)) {\n            return;\n        }\n        this._removeSubscriptions();\n        this._dragDropRegistry.stopDragging(this);\n        this._toggleNativeDragInteractions();\n        if (this._handles) {\n            this._rootElement.style.webkitTapHighlightColor =\n                this._rootElementTapHighlight;\n        }\n        if (!this._hasStartedDragging) {\n            return;\n        }\n        this.released.next({ source: this, event });\n        if (this._dropContainer) {\n            // Stop scrolling immediately, instead of waiting for the animation to finish.\n            this._dropContainer._stopScrolling();\n            this._animatePreviewToPlaceholder().then(() => {\n                this._cleanupDragArtifacts(event);\n                this._cleanupCachedDimensions();\n                this._dragDropRegistry.stopDragging(this);\n            });\n        }\n        else {\n            // Convert the active transform into a passive one. This means that next time\n            // the user starts dragging the item, its position will be calculated relatively\n            // to the new passive transform.\n            this._passiveTransform.x = this._activeTransform.x;\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            this._passiveTransform.y = this._activeTransform.y;\n            this._ngZone.run(() => {\n                this.ended.next({\n                    source: this,\n                    distance: this._getDragDistance(pointerPosition),\n                    dropPoint: pointerPosition,\n                    event,\n                });\n            });\n            this._cleanupCachedDimensions();\n            this._dragDropRegistry.stopDragging(this);\n        }\n    }\n    /** Starts the dragging sequence. */\n    _startDragSequence(event) {\n        if (isTouchEvent(event)) {\n            this._lastTouchEventTime = Date.now();\n        }\n        this._toggleNativeDragInteractions();\n        const dropContainer = this._dropContainer;\n        if (dropContainer) {\n            const element = this._rootElement;\n            const parent = element.parentNode;\n            const placeholder = (this._placeholder = this._createPlaceholderElement());\n            const anchor = (this._anchor = this._anchor || this._document.createComment(''));\n            // Needs to happen before the root element is moved.\n            const shadowRoot = this._getShadowRoot();\n            // Insert an anchor node so that we can restore the element's position in the DOM.\n            parent.insertBefore(anchor, element);\n            // There's no risk of transforms stacking when inside a drop container so\n            // we can keep the initial transform up to date any time dragging starts.\n            this._initialTransform = element.style.transform || '';\n            // Create the preview after the initial transform has\n            // been cached, because it can be affected by the transform.\n            this._preview = this._createPreviewElement();\n            // We move the element out at the end of the body and we make it hidden, because keeping it in\n            // place will throw off the consumer's `:last-child` selectors. We can't remove the element\n            // from the DOM completely, because iOS will stop firing all subsequent events in the chain.\n            toggleVisibility(element, false, dragImportantProperties);\n            this._document.body.appendChild(parent.replaceChild(placeholder, element));\n            this._getPreviewInsertionPoint(parent, shadowRoot).appendChild(this._preview);\n            this.started.next({ source: this, event }); // Emit before notifying the container.\n            dropContainer.start();\n            this._initialContainer = dropContainer;\n            this._initialIndex = dropContainer.getItemIndex(this);\n        }\n        else {\n            this.started.next({ source: this, event });\n            this._initialContainer = this._initialIndex = undefined;\n        }\n        // Important to run after we've called `start` on the parent container\n        // so that it has had time to resolve its scrollable parents.\n        this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);\n    }\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @param referenceElement Element that started the drag sequence.\n     * @param event Browser event object that started the sequence.\n     */\n    _initializeDragSequence(referenceElement, event) {\n        // Stop propagation if the item is inside another\n        // draggable so we don't start multiple drag sequences.\n        if (this._parentDragRef) {\n            event.stopPropagation();\n        }\n        const isDragging = this.isDragging();\n        const isTouchSequence = isTouchEvent(event);\n        const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;\n        const rootElement = this._rootElement;\n        const target = _getEventTarget(event);\n        const isSyntheticEvent = !isTouchSequence &&\n            this._lastTouchEventTime &&\n            this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();\n        const isFakeEvent = isTouchSequence\n            ? isFakeTouchstartFromScreenReader(event)\n            : isFakeMousedownFromScreenReader(event);\n        // If the event started from an element with the native HTML drag&drop, it'll interfere\n        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n        // events from firing on touch devices.\n        if (target && target.draggable && event.type === 'mousedown') {\n            event.preventDefault();\n        }\n        // Abort if the user is already dragging or is using a mouse button other than the primary one.\n        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {\n            return;\n        }\n        // If we've got handles, we need to disable the tap highlight on the entire root element,\n        // otherwise iOS will still add it, even though all the drag interactions on the handle\n        // are disabled.\n        if (this._handles.length) {\n            const rootStyles = rootElement.style;\n            this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || '';\n            rootStyles.webkitTapHighlightColor = 'transparent';\n        }\n        this._hasStartedDragging = this._hasMoved = false;\n        // Avoid multiple subscriptions and memory leaks when multi touch\n        // (isDragging check above isn't enough because of possible temporal and/or dimensional delays)\n        this._removeSubscriptions();\n        this._initialClientRect = this._rootElement.getBoundingClientRect();\n        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);\n        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);\n        this._scrollSubscription = this._dragDropRegistry\n            .scrolled(this._getShadowRoot())\n            .subscribe(scrollEvent => this._updateOnScroll(scrollEvent));\n        if (this._boundaryElement) {\n            this._boundaryRect = getMutableClientRect(this._boundaryElement);\n        }\n        // If we have a custom preview we can't know ahead of time how large it'll be so we position\n        // it next to the cursor. The exception is when the consumer has opted into making the preview\n        // the same size as the root element, in which case we do know the size.\n        const previewTemplate = this._previewTemplate;\n        this._pickupPositionInElement =\n            previewTemplate && previewTemplate.template && !previewTemplate.matchSize\n                ? { x: 0, y: 0 }\n                : this._getPointerPositionInElement(this._initialClientRect, referenceElement, event);\n        const pointerPosition = (this._pickupPositionOnPage =\n            this._lastKnownPointerPosition =\n                this._getPointerPositionOnPage(event));\n        this._pointerDirectionDelta = { x: 0, y: 0 };\n        this._pointerPositionAtLastDirectionChange = { x: pointerPosition.x, y: pointerPosition.y };\n        this._dragStartTime = Date.now();\n        this._dragDropRegistry.startDragging(this, event);\n    }\n    /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */\n    _cleanupDragArtifacts(event) {\n        // Restore the element's visibility and insert it at its old position in the DOM.\n        // It's important that we maintain the position, because moving the element around in the DOM\n        // can throw off `NgFor` which does smart diffing and re-creates elements only when necessary,\n        // while moving the existing elements in all other cases.\n        toggleVisibility(this._rootElement, true, dragImportantProperties);\n        this._anchor.parentNode.replaceChild(this._rootElement, this._anchor);\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._initialClientRect =\n            this._boundaryRect =\n                this._previewRect =\n                    this._initialTransform =\n                        undefined;\n        // Re-enter the NgZone since we bound `document` events on the outside.\n        this._ngZone.run(() => {\n            const container = this._dropContainer;\n            const currentIndex = container.getItemIndex(this);\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            const distance = this._getDragDistance(pointerPosition);\n            const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);\n            this.ended.next({ source: this, distance, dropPoint: pointerPosition, event });\n            this.dropped.next({\n                item: this,\n                currentIndex,\n                previousIndex: this._initialIndex,\n                container: container,\n                previousContainer: this._initialContainer,\n                isPointerOverContainer,\n                distance,\n                dropPoint: pointerPosition,\n                event,\n            });\n            container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);\n            this._dropContainer = this._initialContainer;\n        });\n    }\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     */\n    _updateActiveDropContainer({ x, y }, { x: rawX, y: rawY }) {\n        // Drop container that draggable has been moved into.\n        let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);\n        // If we couldn't find a new container to move the item into, and the item has left its\n        // initial container, check whether the it's over the initial container. This handles the\n        // case where two containers are connected one way and the user tries to undo dragging an\n        // item into a new container.\n        if (!newContainer &&\n            this._dropContainer !== this._initialContainer &&\n            this._initialContainer._isOverContainer(x, y)) {\n            newContainer = this._initialContainer;\n        }\n        if (newContainer && newContainer !== this._dropContainer) {\n            this._ngZone.run(() => {\n                // Notify the old container that the item has left.\n                this.exited.next({ item: this, container: this._dropContainer });\n                this._dropContainer.exit(this);\n                // Notify the new container that the item has entered.\n                this._dropContainer = newContainer;\n                this._dropContainer.enter(this, x, y, newContainer === this._initialContainer &&\n                    // If we're re-entering the initial container and sorting is disabled,\n                    // put item the into its starting index to begin with.\n                    newContainer.sortingDisabled\n                    ? this._initialIndex\n                    : undefined);\n                this.entered.next({\n                    item: this,\n                    container: newContainer,\n                    currentIndex: newContainer.getItemIndex(this),\n                });\n            });\n        }\n        // Dragging may have been interrupted as a result of the events above.\n        if (this.isDragging()) {\n            this._dropContainer._startScrollingIfNecessary(rawX, rawY);\n            this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);\n            if (this.constrainPosition) {\n                this._applyPreviewTransform(x, y);\n            }\n            else {\n                this._applyPreviewTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n            }\n        }\n    }\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     */\n    _createPreviewElement() {\n        const previewConfig = this._previewTemplate;\n        const previewClass = this.previewClass;\n        const previewTemplate = previewConfig ? previewConfig.template : null;\n        let preview;\n        if (previewTemplate && previewConfig) {\n            // Measure the element before we've inserted the preview\n            // since the insertion could throw off the measurement.\n            const rootRect = previewConfig.matchSize ? this._initialClientRect : null;\n            const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);\n            viewRef.detectChanges();\n            preview = getRootNode(viewRef, this._document);\n            this._previewRef = viewRef;\n            if (previewConfig.matchSize) {\n                matchElementSize(preview, rootRect);\n            }\n            else {\n                preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n            }\n        }\n        else {\n            preview = deepCloneNode(this._rootElement);\n            matchElementSize(preview, this._initialClientRect);\n            if (this._initialTransform) {\n                preview.style.transform = this._initialTransform;\n            }\n        }\n        extendStyles(preview.style, {\n            // It's important that we disable the pointer events on the preview, because\n            // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.\n            'pointer-events': 'none',\n            // We have to reset the margin, because it can throw off positioning relative to the viewport.\n            'margin': '0',\n            'position': 'fixed',\n            'top': '0',\n            'left': '0',\n            'z-index': `${this._config.zIndex || 1000}`,\n        }, dragImportantProperties);\n        toggleNativeDragInteractions(preview, false);\n        preview.classList.add('cdk-drag-preview');\n        preview.setAttribute('dir', this._direction);\n        if (previewClass) {\n            if (Array.isArray(previewClass)) {\n                previewClass.forEach(className => preview.classList.add(className));\n            }\n            else {\n                preview.classList.add(previewClass);\n            }\n        }\n        return preview;\n    }\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @returns Promise that resolves when the animation completes.\n     */\n    _animatePreviewToPlaceholder() {\n        // If the user hasn't moved yet, the transitionend event won't fire.\n        if (!this._hasMoved) {\n            return Promise.resolve();\n        }\n        const placeholderRect = this._placeholder.getBoundingClientRect();\n        // Apply the class that adds a transition to the preview.\n        this._preview.classList.add('cdk-drag-animating');\n        // Move the preview to the placeholder position.\n        this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);\n        // If the element doesn't have a `transition`, the `transitionend` event won't fire. Since\n        // we need to trigger a style recalculation in order for the `cdk-drag-animating` class to\n        // apply its style, we take advantage of the available info to figure out whether we need to\n        // bind the event in the first place.\n        const duration = getTransformTransitionDurationInMs(this._preview);\n        if (duration === 0) {\n            return Promise.resolve();\n        }\n        return this._ngZone.runOutsideAngular(() => {\n            return new Promise(resolve => {\n                const handler = ((event) => {\n                    if (!event ||\n                        (_getEventTarget(event) === this._preview && event.propertyName === 'transform')) {\n                        this._preview?.removeEventListener('transitionend', handler);\n                        resolve();\n                        clearTimeout(timeout);\n                    }\n                });\n                // If a transition is short enough, the browser might not fire the `transitionend` event.\n                // Since we know how long it's supposed to take, add a timeout with a 50% buffer that'll\n                // fire if the transition hasn't completed when it was supposed to.\n                const timeout = setTimeout(handler, duration * 1.5);\n                this._preview.addEventListener('transitionend', handler);\n            });\n        });\n    }\n    /** Creates an element that will be shown instead of the current element while dragging. */\n    _createPlaceholderElement() {\n        const placeholderConfig = this._placeholderTemplate;\n        const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;\n        let placeholder;\n        if (placeholderTemplate) {\n            this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);\n            this._placeholderRef.detectChanges();\n            placeholder = getRootNode(this._placeholderRef, this._document);\n        }\n        else {\n            placeholder = deepCloneNode(this._rootElement);\n        }\n        // Stop pointer events on the preview so the user can't\n        // interact with it while the preview is animating.\n        placeholder.style.pointerEvents = 'none';\n        placeholder.classList.add('cdk-drag-placeholder');\n        return placeholder;\n    }\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @param referenceElement Element that initiated the dragging.\n     * @param event Event that initiated the dragging.\n     */\n    _getPointerPositionInElement(elementRect, referenceElement, event) {\n        const handleElement = referenceElement === this._rootElement ? null : referenceElement;\n        const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n        const point = isTouchEvent(event) ? event.targetTouches[0] : event;\n        const scrollPosition = this._getViewportScrollPosition();\n        const x = point.pageX - referenceRect.left - scrollPosition.left;\n        const y = point.pageY - referenceRect.top - scrollPosition.top;\n        return {\n            x: referenceRect.left - elementRect.left + x,\n            y: referenceRect.top - elementRect.top + y,\n        };\n    }\n    /** Determines the point of the page that was touched by the user. */\n    _getPointerPositionOnPage(event) {\n        const scrollPosition = this._getViewportScrollPosition();\n        const point = isTouchEvent(event)\n            ? // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n                // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`\n                // to have a value, but Firefox in device emulation mode has a bug where both can be empty\n                // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid\n                // throwing an error. The value returned here will be incorrect, but since this only\n                // breaks inside a developer tool and the value is only used for secondary information,\n                // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.\n                event.touches[0] || event.changedTouches[0] || { pageX: 0, pageY: 0 }\n            : event;\n        const x = point.pageX - scrollPosition.left;\n        const y = point.pageY - scrollPosition.top;\n        // if dragging SVG element, try to convert from the screen coordinate system to the SVG\n        // coordinate system\n        if (this._ownerSVGElement) {\n            const svgMatrix = this._ownerSVGElement.getScreenCTM();\n            if (svgMatrix) {\n                const svgPoint = this._ownerSVGElement.createSVGPoint();\n                svgPoint.x = x;\n                svgPoint.y = y;\n                return svgPoint.matrixTransform(svgMatrix.inverse());\n            }\n        }\n        return { x, y };\n    }\n    /** Gets the pointer position on the page, accounting for any position constraints. */\n    _getConstrainedPointerPosition(point) {\n        const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;\n        let { x, y } = this.constrainPosition\n            ? this.constrainPosition(point, this, this._initialClientRect, this._pickupPositionInElement)\n            : point;\n        if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n            y =\n                this._pickupPositionOnPage.y -\n                    (this.constrainPosition ? this._pickupPositionInElement.y : 0);\n        }\n        else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n            x =\n                this._pickupPositionOnPage.x -\n                    (this.constrainPosition ? this._pickupPositionInElement.x : 0);\n        }\n        if (this._boundaryRect) {\n            // If not using a custom constrain we need to account for the pickup position in the element\n            // otherwise we do not need to do this, as it has already been accounted for\n            const { x: pickupX, y: pickupY } = !this.constrainPosition\n                ? this._pickupPositionInElement\n                : { x: 0, y: 0 };\n            const boundaryRect = this._boundaryRect;\n            const { width: previewWidth, height: previewHeight } = this._getPreviewRect();\n            const minY = boundaryRect.top + pickupY;\n            const maxY = boundaryRect.bottom - (previewHeight - pickupY);\n            const minX = boundaryRect.left + pickupX;\n            const maxX = boundaryRect.right - (previewWidth - pickupX);\n            x = clamp$1(x, minX, maxX);\n            y = clamp$1(y, minY, maxY);\n        }\n        return { x, y };\n    }\n    /** Updates the current drag delta, based on the user's current pointer position on the page. */\n    _updatePointerDirectionDelta(pointerPositionOnPage) {\n        const { x, y } = pointerPositionOnPage;\n        const delta = this._pointerDirectionDelta;\n        const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n        // Amount of pixels the user has dragged since the last time the direction changed.\n        const changeX = Math.abs(x - positionSinceLastChange.x);\n        const changeY = Math.abs(y - positionSinceLastChange.y);\n        // Because we handle pointer events on a per-pixel basis, we don't want the delta\n        // to change for every pixel, otherwise anything that depends on it can look erratic.\n        // To make the delta more consistent, we track how much the user has moved since the last\n        // delta change and we only update it after it has reached a certain threshold.\n        if (changeX > this._config.pointerDirectionChangeThreshold) {\n            delta.x = x > positionSinceLastChange.x ? 1 : -1;\n            positionSinceLastChange.x = x;\n        }\n        if (changeY > this._config.pointerDirectionChangeThreshold) {\n            delta.y = y > positionSinceLastChange.y ? 1 : -1;\n            positionSinceLastChange.y = y;\n        }\n        return delta;\n    }\n    /** Toggles the native drag interactions, based on how many handles are registered. */\n    _toggleNativeDragInteractions() {\n        if (!this._rootElement || !this._handles) {\n            return;\n        }\n        const shouldEnable = this._handles.length > 0 || !this.isDragging();\n        if (shouldEnable !== this._nativeInteractionsEnabled) {\n            this._nativeInteractionsEnabled = shouldEnable;\n            toggleNativeDragInteractions(this._rootElement, shouldEnable);\n        }\n    }\n    /** Removes the manually-added event listeners from the root element. */\n    _removeRootElementListeners(element) {\n        element.removeEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n        element.removeEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n        element.removeEventListener('dragstart', this._nativeDragStart, activeEventListenerOptions);\n    }\n    /**\n     * Applies a `transform` to the root element, taking into account any existing transforms on it.\n     * @param x New transform value along the X axis.\n     * @param y New transform value along the Y axis.\n     */\n    _applyRootElementTransform(x, y) {\n        const transform = getTransform(x, y);\n        const styles = this._rootElement.style;\n        // Cache the previous transform amount only after the first drag sequence, because\n        // we don't want our own transforms to stack on top of each other.\n        // Should be excluded none because none + translate3d(x, y, x) is invalid css\n        if (this._initialTransform == null) {\n            this._initialTransform =\n                styles.transform && styles.transform != 'none' ? styles.transform : '';\n        }\n        // Preserve the previous `transform` value, if there was one. Note that we apply our own\n        // transform before the user's, because things like rotation can affect which direction\n        // the element will be translated towards.\n        styles.transform = combineTransforms(transform, this._initialTransform);\n    }\n    /**\n     * Applies a `transform` to the preview, taking into account any existing transforms on it.\n     * @param x New transform value along the X axis.\n     * @param y New transform value along the Y axis.\n     */\n    _applyPreviewTransform(x, y) {\n        // Only apply the initial transform if the preview is a clone of the original element, otherwise\n        // it could be completely different and the transform might not make sense anymore.\n        const initialTransform = this._previewTemplate?.template ? undefined : this._initialTransform;\n        const transform = getTransform(x, y);\n        this._preview.style.transform = combineTransforms(transform, initialTransform);\n    }\n    /**\n     * Gets the distance that the user has dragged during the current drag sequence.\n     * @param currentPosition Current position of the user's pointer.\n     */\n    _getDragDistance(currentPosition) {\n        const pickupPosition = this._pickupPositionOnPage;\n        if (pickupPosition) {\n            return { x: currentPosition.x - pickupPosition.x, y: currentPosition.y - pickupPosition.y };\n        }\n        return { x: 0, y: 0 };\n    }\n    /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */\n    _cleanupCachedDimensions() {\n        this._boundaryRect = this._previewRect = undefined;\n        this._parentPositions.clear();\n    }\n    /**\n     * Checks whether the element is still inside its boundary after the viewport has been resized.\n     * If not, the position is adjusted so that the element fits again.\n     */\n    _containInsideBoundaryOnResize() {\n        let { x, y } = this._passiveTransform;\n        if ((x === 0 && y === 0) || this.isDragging() || !this._boundaryElement) {\n            return;\n        }\n        // Note: don't use `_clientRectAtStart` here, because we want the latest position.\n        const elementRect = this._rootElement.getBoundingClientRect();\n        const boundaryRect = this._boundaryElement.getBoundingClientRect();\n        // It's possible that the element got hidden away after dragging (e.g. by switching to a\n        // different tab). Don't do anything in this case so we don't clear the user's position.\n        if ((boundaryRect.width === 0 && boundaryRect.height === 0) ||\n            (elementRect.width === 0 && elementRect.height === 0)) {\n            return;\n        }\n        const leftOverflow = boundaryRect.left - elementRect.left;\n        const rightOverflow = elementRect.right - boundaryRect.right;\n        const topOverflow = boundaryRect.top - elementRect.top;\n        const bottomOverflow = elementRect.bottom - boundaryRect.bottom;\n        // If the element has become wider than the boundary, we can't\n        // do much to make it fit so we just anchor it to the left.\n        if (boundaryRect.width > elementRect.width) {\n            if (leftOverflow > 0) {\n                x += leftOverflow;\n            }\n            if (rightOverflow > 0) {\n                x -= rightOverflow;\n            }\n        }\n        else {\n            x = 0;\n        }\n        // If the element has become taller than the boundary, we can't\n        // do much to make it fit so we just anchor it to the top.\n        if (boundaryRect.height > elementRect.height) {\n            if (topOverflow > 0) {\n                y += topOverflow;\n            }\n            if (bottomOverflow > 0) {\n                y -= bottomOverflow;\n            }\n        }\n        else {\n            y = 0;\n        }\n        if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {\n            this.setFreeDragPosition({ y, x });\n        }\n    }\n    /** Gets the drag start delay, based on the event type. */\n    _getDragStartDelay(event) {\n        const value = this.dragStartDelay;\n        if (typeof value === 'number') {\n            return value;\n        }\n        else if (isTouchEvent(event)) {\n            return value.touch;\n        }\n        return value ? value.mouse : 0;\n    }\n    /** Updates the internal state of the draggable element when scrolling has occurred. */\n    _updateOnScroll(event) {\n        const scrollDifference = this._parentPositions.handleScroll(event);\n        if (scrollDifference) {\n            const target = _getEventTarget(event);\n            // ClientRect dimensions are based on the scroll position of the page and its parent\n            // node so we have to update the cached boundary ClientRect if the user has scrolled.\n            if (this._boundaryRect &&\n                target !== this._boundaryElement &&\n                target.contains(this._boundaryElement)) {\n                adjustClientRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);\n            }\n            this._pickupPositionOnPage.x += scrollDifference.left;\n            this._pickupPositionOnPage.y += scrollDifference.top;\n            // If we're in free drag mode, we have to update the active transform, because\n            // it isn't relative to the viewport like the preview inside a drop list.\n            if (!this._dropContainer) {\n                this._activeTransform.x -= scrollDifference.left;\n                this._activeTransform.y -= scrollDifference.top;\n                this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);\n            }\n        }\n    }\n    /** Gets the scroll position of the viewport. */\n    _getViewportScrollPosition() {\n        return (this._parentPositions.positions.get(this._document)?.scrollPosition ||\n            this._parentPositions.getViewportScrollPosition());\n    }\n    /**\n     * Lazily resolves and returns the shadow root of the element. We do this in a function, rather\n     * than saving it in property directly on init, because we want to resolve it as late as possible\n     * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the\n     * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.\n     */\n    _getShadowRoot() {\n        if (this._cachedShadowRoot === undefined) {\n            this._cachedShadowRoot = _getShadowRoot(this._rootElement);\n        }\n        return this._cachedShadowRoot;\n    }\n    /** Gets the element into which the drag preview should be inserted. */\n    _getPreviewInsertionPoint(initialParent, shadowRoot) {\n        const previewContainer = this._previewContainer || 'global';\n        if (previewContainer === 'parent') {\n            return initialParent;\n        }\n        if (previewContainer === 'global') {\n            const documentRef = this._document;\n            // We can't use the body if the user is in fullscreen mode,\n            // because the preview will render under the fullscreen element.\n            // TODO(crisbeto): dedupe this with the `FullscreenOverlayContainer` eventually.\n            return (shadowRoot ||\n                documentRef.fullscreenElement ||\n                documentRef.webkitFullscreenElement ||\n                documentRef.mozFullScreenElement ||\n                documentRef.msFullscreenElement ||\n                documentRef.body);\n        }\n        return coerceElement(previewContainer);\n    }\n    /** Lazily resolves and returns the dimensions of the preview. */\n    _getPreviewRect() {\n        // Cache the preview element rect if we haven't cached it already or if\n        // we cached it too early before the element dimensions were computed.\n        if (!this._previewRect || (!this._previewRect.width && !this._previewRect.height)) {\n            this._previewRect = this._preview\n                ? this._preview.getBoundingClientRect()\n                : this._initialClientRect;\n        }\n        return this._previewRect;\n    }\n    /** Gets a handle that is the target of an event. */\n    _getTargetHandle(event) {\n        return this._handles.find(handle => {\n            return event.target && (event.target === handle || handle.contains(event.target));\n        });\n    }\n}\n/**\n * Gets a 3d `transform` that can be applied to an element.\n * @param x Desired position of the element along the X axis.\n * @param y Desired position of the element along the Y axis.\n */\nfunction getTransform(x, y) {\n    // Round the transforms since some browsers will\n    // blur the elements for sub-pixel transforms.\n    return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;\n}\n/** Clamps a value between a minimum and a maximum. */\nfunction clamp$1(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/** Determines whether an event is a touch event. */\nfunction isTouchEvent(event) {\n    // This function is called for every pixel that the user has dragged so we need it to be\n    // as fast as possible. Since we only bind mouse events and touch events, we can assume\n    // that if the event's name starts with `t`, it's a touch event.\n    return event.type[0] === 't';\n}\n/**\n * Gets the root HTML element of an embedded view.\n * If the root is not an HTML element it gets wrapped in one.\n */\nfunction getRootNode(viewRef, _document) {\n    const rootNodes = viewRef.rootNodes;\n    if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {\n        return rootNodes[0];\n    }\n    const wrapper = _document.createElement('div');\n    rootNodes.forEach(node => wrapper.appendChild(node));\n    return wrapper;\n}\n/**\n * Matches the target element's size to the source's size.\n * @param target Element that needs to be resized.\n * @param sourceRect Dimensions of the source element.\n */\nfunction matchElementSize(target, sourceRect) {\n    target.style.width = `${sourceRect.width}px`;\n    target.style.height = `${sourceRect.height}px`;\n    target.style.transform = getTransform(sourceRect.left, sourceRect.top);\n}\n\n/**\n * Moves an item one index in an array to another.\n * @param array Array in which to move the item.\n * @param fromIndex Starting index of the item.\n * @param toIndex Index to which the item should be moved.\n */\nfunction moveItemInArray(array, fromIndex, toIndex) {\n    const from = clamp(fromIndex, array.length - 1);\n    const to = clamp(toIndex, array.length - 1);\n    if (from === to) {\n        return;\n    }\n    const target = array[from];\n    const delta = to < from ? -1 : 1;\n    for (let i = from; i !== to; i += delta) {\n        array[i] = array[i + delta];\n    }\n    array[to] = target;\n}\n/**\n * Moves an item from one array to another.\n * @param currentArray Array from which to transfer the item.\n * @param targetArray Array into which to put the item.\n * @param currentIndex Index of the item in its current array.\n * @param targetIndex Index at which to insert the item.\n */\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    const from = clamp(currentIndex, currentArray.length - 1);\n    const to = clamp(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n    }\n}\n/**\n * Copies an item from one array to another, leaving it in its\n * original position in current array.\n * @param currentArray Array from which to copy the item.\n * @param targetArray Array into which is copy the item.\n * @param currentIndex Index of the item in its current array.\n * @param targetIndex Index at which to insert the item.\n *\n */\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    const to = clamp(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray[currentIndex]);\n    }\n}\n/** Clamps a number between zero and a maximum. */\nfunction clamp(value, max) {\n    return Math.max(0, Math.min(max, value));\n}\n\n/**\n * Strategy that only supports sorting along a single axis.\n * Items are reordered using CSS transforms which allows for sorting to be animated.\n * @docs-private\n */\nclass SingleAxisSortStrategy {\n    constructor(_element, _dragDropRegistry) {\n        this._element = _element;\n        this._dragDropRegistry = _dragDropRegistry;\n        /** Cache of the dimensions of all the items inside the container. */\n        this._itemPositions = [];\n        /** Direction in which the list is oriented. */\n        this.orientation = 'vertical';\n        /**\n         * Keeps track of the item that was last swapped with the dragged item, as well as what direction\n         * the pointer was moving in when the swap occurred and whether the user's pointer continued to\n         * overlap with the swapped item after the swapping occurred.\n         */\n        this._previousSwap = {\n            drag: null,\n            delta: 0,\n            overlaps: false,\n        };\n    }\n    /**\n     * To be called when the drag sequence starts.\n     * @param items Items that are currently in the list.\n     */\n    start(items) {\n        this.withItems(items);\n    }\n    /**\n     * To be called when an item is being sorted.\n     * @param item Item to be sorted.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param pointerDelta Direction in which the pointer is moving along each axis.\n     */\n    sort(item, pointerX, pointerY, pointerDelta) {\n        const siblings = this._itemPositions;\n        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n        if (newIndex === -1 && siblings.length > 0) {\n            return null;\n        }\n        const isHorizontal = this.orientation === 'horizontal';\n        const currentIndex = siblings.findIndex(currentItem => currentItem.drag === item);\n        const siblingAtNewPosition = siblings[newIndex];\n        const currentPosition = siblings[currentIndex].clientRect;\n        const newPosition = siblingAtNewPosition.clientRect;\n        const delta = currentIndex > newIndex ? 1 : -1;\n        // How many pixels the item's placeholder should be offset.\n        const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n        // How many pixels all the other items should be offset.\n        const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n        // Save the previous order of the items before moving the item to its new index.\n        // We use this to check whether an item has been moved as a result of the sorting.\n        const oldOrder = siblings.slice();\n        // Shuffle the array in place.\n        moveItemInArray(siblings, currentIndex, newIndex);\n        siblings.forEach((sibling, index) => {\n            // Don't do anything if the position hasn't changed.\n            if (oldOrder[index] === sibling) {\n                return;\n            }\n            const isDraggedItem = sibling.drag === item;\n            const offset = isDraggedItem ? itemOffset : siblingOffset;\n            const elementToOffset = isDraggedItem\n                ? item.getPlaceholderElement()\n                : sibling.drag.getRootElement();\n            // Update the offset to reflect the new position.\n            sibling.offset += offset;\n            // Since we're moving the items with a `transform`, we need to adjust their cached\n            // client rects to reflect their new position, as well as swap their positions in the cache.\n            // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n            // elements may be mid-animation which will give us a wrong result.\n            if (isHorizontal) {\n                // Round the transforms since some browsers will\n                // blur the elements, for sub-pixel transforms.\n                elementToOffset.style.transform = combineTransforms(`translate3d(${Math.round(sibling.offset)}px, 0, 0)`, sibling.initialTransform);\n                adjustClientRect(sibling.clientRect, 0, offset);\n            }\n            else {\n                elementToOffset.style.transform = combineTransforms(`translate3d(0, ${Math.round(sibling.offset)}px, 0)`, sibling.initialTransform);\n                adjustClientRect(sibling.clientRect, offset, 0);\n            }\n        });\n        // Note that it's important that we do this after the client rects have been adjusted.\n        this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);\n        this._previousSwap.drag = siblingAtNewPosition.drag;\n        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n        return { previousIndex: currentIndex, currentIndex: newIndex };\n    }\n    /**\n     * Called when an item is being moved into the container.\n     * @param item Item that was moved into the container.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param index Index at which the item entered. If omitted, the container will try to figure it\n     *   out automatically.\n     */\n    enter(item, pointerX, pointerY, index) {\n        const newIndex = index == null || index < 0\n            ? // We use the coordinates of where the item entered the drop\n                // zone to figure out at which index it should be inserted.\n                this._getItemIndexFromPointerPosition(item, pointerX, pointerY)\n            : index;\n        const activeDraggables = this._activeDraggables;\n        const currentIndex = activeDraggables.indexOf(item);\n        const placeholder = item.getPlaceholderElement();\n        let newPositionReference = activeDraggables[newIndex];\n        // If the item at the new position is the same as the item that is being dragged,\n        // it means that we're trying to restore the item to its initial position. In this\n        // case we should use the next item from the list as the reference.\n        if (newPositionReference === item) {\n            newPositionReference = activeDraggables[newIndex + 1];\n        }\n        // If we didn't find a new position reference, it means that either the item didn't start off\n        // in this container, or that the item requested to be inserted at the end of the list.\n        if (!newPositionReference &&\n            (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) &&\n            this._shouldEnterAsFirstChild(pointerX, pointerY)) {\n            newPositionReference = activeDraggables[0];\n        }\n        // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n        // into another container and back again), we have to ensure that it isn't duplicated.\n        if (currentIndex > -1) {\n            activeDraggables.splice(currentIndex, 1);\n        }\n        // Don't use items that are being dragged as a reference, because\n        // their element has been moved down to the bottom of the body.\n        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n            const element = newPositionReference.getRootElement();\n            element.parentElement.insertBefore(placeholder, element);\n            activeDraggables.splice(newIndex, 0, item);\n        }\n        else {\n            coerceElement(this._element).appendChild(placeholder);\n            activeDraggables.push(item);\n        }\n        // The transform needs to be cleared so it doesn't throw off the measurements.\n        placeholder.style.transform = '';\n        // Note that usually `start` is called together with `enter` when an item goes into a new\n        // container. This will cache item positions, but we need to refresh them since the amount\n        // of items has changed.\n        this._cacheItemPositions();\n    }\n    /** Sets the items that are currently part of the list. */\n    withItems(items) {\n        this._activeDraggables = items.slice();\n        this._cacheItemPositions();\n    }\n    /** Assigns a sort predicate to the strategy. */\n    withSortPredicate(predicate) {\n        this._sortPredicate = predicate;\n    }\n    /** Resets the strategy to its initial state before dragging was started. */\n    reset() {\n        // TODO(crisbeto): may have to wait for the animations to finish.\n        this._activeDraggables.forEach(item => {\n            const rootElement = item.getRootElement();\n            if (rootElement) {\n                const initialTransform = this._itemPositions.find(p => p.drag === item)?.initialTransform;\n                rootElement.style.transform = initialTransform || '';\n            }\n        });\n        this._itemPositions = [];\n        this._activeDraggables = [];\n        this._previousSwap.drag = null;\n        this._previousSwap.delta = 0;\n        this._previousSwap.overlaps = false;\n    }\n    /**\n     * Gets a snapshot of items currently in the list.\n     * Can include items that we dragged in from another list.\n     */\n    getActiveItemsSnapshot() {\n        return this._activeDraggables;\n    }\n    /** Gets the index of a specific item. */\n    getItemIndex(item) {\n        // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n        // The rest of the logic still stands no matter what orientation we're in, however\n        // we need to invert the array when determining the index.\n        const items = this.orientation === 'horizontal' && this.direction === 'rtl'\n            ? this._itemPositions.slice().reverse()\n            : this._itemPositions;\n        return items.findIndex(currentItem => currentItem.drag === item);\n    }\n    /** Used to notify the strategy that the scroll position has changed. */\n    updateOnScroll(topDifference, leftDifference) {\n        // Since we know the amount that the user has scrolled we can shift all of the\n        // client rectangles ourselves. This is cheaper than re-measuring everything and\n        // we can avoid inconsistent behavior where we might be measuring the element before\n        // its position has changed.\n        this._itemPositions.forEach(({ clientRect }) => {\n            adjustClientRect(clientRect, topDifference, leftDifference);\n        });\n        // We need two loops for this, because we want all of the cached\n        // positions to be up-to-date before we re-sort the item.\n        this._itemPositions.forEach(({ drag }) => {\n            if (this._dragDropRegistry.isDragging(drag)) {\n                // We need to re-sort the item manually, because the pointer move\n                // events won't be dispatched while the user is scrolling.\n                drag._sortFromLastPointerPosition();\n            }\n        });\n    }\n    /** Refreshes the position cache of the items and sibling containers. */\n    _cacheItemPositions() {\n        const isHorizontal = this.orientation === 'horizontal';\n        this._itemPositions = this._activeDraggables\n            .map(drag => {\n            const elementToMeasure = drag.getVisibleElement();\n            return {\n                drag,\n                offset: 0,\n                initialTransform: elementToMeasure.style.transform || '',\n                clientRect: getMutableClientRect(elementToMeasure),\n            };\n        })\n            .sort((a, b) => {\n            return isHorizontal\n                ? a.clientRect.left - b.clientRect.left\n                : a.clientRect.top - b.clientRect.top;\n        });\n    }\n    /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @param currentPosition Current position of the item.\n     * @param newPosition Position of the item where the current item should be moved.\n     * @param delta Direction in which the user is moving.\n     */\n    _getItemOffsetPx(currentPosition, newPosition, delta) {\n        const isHorizontal = this.orientation === 'horizontal';\n        let itemOffset = isHorizontal\n            ? newPosition.left - currentPosition.left\n            : newPosition.top - currentPosition.top;\n        // Account for differences in the item width/height.\n        if (delta === -1) {\n            itemOffset += isHorizontal\n                ? newPosition.width - currentPosition.width\n                : newPosition.height - currentPosition.height;\n        }\n        return itemOffset;\n    }\n    /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @param currentIndex Index of the item currently being dragged.\n     * @param siblings All of the items in the list.\n     * @param delta Direction in which the user is moving.\n     */\n    _getSiblingOffsetPx(currentIndex, siblings, delta) {\n        const isHorizontal = this.orientation === 'horizontal';\n        const currentPosition = siblings[currentIndex].clientRect;\n        const immediateSibling = siblings[currentIndex + delta * -1];\n        let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n        if (immediateSibling) {\n            const start = isHorizontal ? 'left' : 'top';\n            const end = isHorizontal ? 'right' : 'bottom';\n            // Get the spacing between the start of the current item and the end of the one immediately\n            // after it in the direction in which the user is dragging, or vice versa. We add it to the\n            // offset in order to push the element to where it will be when it's inline and is influenced\n            // by the `margin` of its siblings.\n            if (delta === -1) {\n                siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n            }\n            else {\n                siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n            }\n        }\n        return siblingOffset;\n    }\n    /**\n     * Checks if pointer is entering in the first position\n     * @param pointerX Position of the user's pointer along the X axis.\n     * @param pointerY Position of the user's pointer along the Y axis.\n     */\n    _shouldEnterAsFirstChild(pointerX, pointerY) {\n        if (!this._activeDraggables.length) {\n            return false;\n        }\n        const itemPositions = this._itemPositions;\n        const isHorizontal = this.orientation === 'horizontal';\n        // `itemPositions` are sorted by position while `activeDraggables` are sorted by child index\n        // check if container is using some sort of \"reverse\" ordering (eg: flex-direction: row-reverse)\n        const reversed = itemPositions[0].drag !== this._activeDraggables[0];\n        if (reversed) {\n            const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;\n            return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;\n        }\n        else {\n            const firstItemRect = itemPositions[0].clientRect;\n            return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;\n        }\n    }\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @param item Item that is being sorted.\n     * @param pointerX Position of the user's pointer along the X axis.\n     * @param pointerY Position of the user's pointer along the Y axis.\n     * @param delta Direction in which the user is moving their pointer.\n     */\n    _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {\n        const isHorizontal = this.orientation === 'horizontal';\n        const index = this._itemPositions.findIndex(({ drag, clientRect }) => {\n            // Skip the item itself.\n            if (drag === item) {\n                return false;\n            }\n            if (delta) {\n                const direction = isHorizontal ? delta.x : delta.y;\n                // If the user is still hovering over the same item as last time, their cursor hasn't left\n                // the item after we made the swap, and they didn't change the direction in which they're\n                // dragging, we don't consider it a direction swap.\n                if (drag === this._previousSwap.drag &&\n                    this._previousSwap.overlaps &&\n                    direction === this._previousSwap.delta) {\n                    return false;\n                }\n            }\n            return isHorizontal\n                ? // Round these down since most browsers report client rects with\n                    // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n                    pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right)\n                : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);\n        });\n        return index === -1 || !this._sortPredicate(index, item) ? -1 : index;\n    }\n}\n\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n */\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling the drop list or the\n * viewport. The value comes from trying it out manually until it feels right.\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n */\nclass DropListRef {\n    constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {\n        this._dragDropRegistry = _dragDropRegistry;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        /** Whether starting a dragging sequence from this container is disabled. */\n        this.disabled = false;\n        /** Whether sorting items within the list is disabled. */\n        this.sortingDisabled = false;\n        /**\n         * Whether auto-scrolling the view when the user\n         * moves their pointer close to the edges is disabled.\n         */\n        this.autoScrollDisabled = false;\n        /** Number of pixels to scroll for each frame when auto-scrolling an element. */\n        this.autoScrollStep = 2;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = () => true;\n        /** Function that is used to determine whether an item can be sorted into a particular index. */\n        this.sortPredicate = () => true;\n        /** Emits right before dragging has started. */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /** Emits when the user drops an item inside the container. */\n        this.dropped = new Subject();\n        /** Emits as the user is swapping items while actively dragging. */\n        this.sorted = new Subject();\n        /** Emits when a dragging sequence is started in a list connected to the current one. */\n        this.receivingStarted = new Subject();\n        /** Emits when a dragging sequence is stopped from a list connected to the current one. */\n        this.receivingStopped = new Subject();\n        /** Whether an item in the list is being dragged. */\n        this._isDragging = false;\n        /** Draggable items in the container. */\n        this._draggables = [];\n        /** Drop lists that are connected to the current one. */\n        this._siblings = [];\n        /** Connected siblings that currently have a dragged item. */\n        this._activeSiblings = new Set();\n        /** Subscription to the window being scrolled. */\n        this._viewportScrollSubscription = Subscription.EMPTY;\n        /** Vertical direction in which the list is currently scrolling. */\n        this._verticalScrollDirection = 0 /* AutoScrollVerticalDirection.NONE */;\n        /** Horizontal direction in which the list is currently scrolling. */\n        this._horizontalScrollDirection = 0 /* AutoScrollHorizontalDirection.NONE */;\n        /** Used to signal to the current auto-scroll sequence when to stop. */\n        this._stopScrollTimers = new Subject();\n        /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */\n        this._cachedShadowRoot = null;\n        /** Starts the interval that'll auto-scroll the element. */\n        this._startScrollInterval = () => {\n            this._stopScrolling();\n            interval(0, animationFrameScheduler)\n                .pipe(takeUntil(this._stopScrollTimers))\n                .subscribe(() => {\n                const node = this._scrollNode;\n                const scrollStep = this.autoScrollStep;\n                if (this._verticalScrollDirection === 1 /* AutoScrollVerticalDirection.UP */) {\n                    node.scrollBy(0, -scrollStep);\n                }\n                else if (this._verticalScrollDirection === 2 /* AutoScrollVerticalDirection.DOWN */) {\n                    node.scrollBy(0, scrollStep);\n                }\n                if (this._horizontalScrollDirection === 1 /* AutoScrollHorizontalDirection.LEFT */) {\n                    node.scrollBy(-scrollStep, 0);\n                }\n                else if (this._horizontalScrollDirection === 2 /* AutoScrollHorizontalDirection.RIGHT */) {\n                    node.scrollBy(scrollStep, 0);\n                }\n            });\n        };\n        this.element = coerceElement(element);\n        this._document = _document;\n        this.withScrollableParents([this.element]);\n        _dragDropRegistry.registerDropContainer(this);\n        this._parentPositions = new ParentPositionTracker(_document);\n        this._sortStrategy = new SingleAxisSortStrategy(this.element, _dragDropRegistry);\n        this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));\n    }\n    /** Removes the drop list functionality from the DOM element. */\n    dispose() {\n        this._stopScrolling();\n        this._stopScrollTimers.complete();\n        this._viewportScrollSubscription.unsubscribe();\n        this.beforeStarted.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this.sorted.complete();\n        this.receivingStarted.complete();\n        this.receivingStopped.complete();\n        this._activeSiblings.clear();\n        this._scrollNode = null;\n        this._parentPositions.clear();\n        this._dragDropRegistry.removeDropContainer(this);\n    }\n    /** Whether an item from this list is currently being dragged. */\n    isDragging() {\n        return this._isDragging;\n    }\n    /** Starts dragging an item. */\n    start() {\n        this._draggingStarted();\n        this._notifyReceivingSiblings();\n    }\n    /**\n     * Attempts to move an item into the container.\n     * @param item Item that was moved into the container.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param index Index at which the item entered. If omitted, the container will try to figure it\n     *   out automatically.\n     */\n    enter(item, pointerX, pointerY, index) {\n        this._draggingStarted();\n        // If sorting is disabled, we want the item to return to its starting\n        // position if the user is returning it to its initial container.\n        if (index == null && this.sortingDisabled) {\n            index = this._draggables.indexOf(item);\n        }\n        this._sortStrategy.enter(item, pointerX, pointerY, index);\n        // Note that this usually happens inside `_draggingStarted` as well, but the dimensions\n        // can change when the sort strategy moves the item around inside `enter`.\n        this._cacheParentPositions();\n        // Notify siblings at the end so that the item has been inserted into the `activeDraggables`.\n        this._notifyReceivingSiblings();\n        this.entered.next({ item, container: this, currentIndex: this.getItemIndex(item) });\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param item Item that was dragged out.\n     */\n    exit(item) {\n        this._reset();\n        this.exited.next({ item, container: this });\n    }\n    /**\n     * Drops an item into this container.\n     * @param item Item being dropped into the container.\n     * @param currentIndex Index at which the item should be inserted.\n     * @param previousIndex Index of the item when dragging started.\n     * @param previousContainer Container from which the item got dragged in.\n     * @param isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @param distance Distance the user has dragged since the start of the dragging sequence.\n     * @param event Event that triggered the dropping sequence.\n     *\n     * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.\n     */\n    drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {\n        this._reset();\n        this.dropped.next({\n            item,\n            currentIndex,\n            previousIndex,\n            container: this,\n            previousContainer,\n            isPointerOverContainer,\n            distance,\n            dropPoint,\n            event,\n        });\n    }\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @param items Items that are a part of this list.\n     */\n    withItems(items) {\n        const previousItems = this._draggables;\n        this._draggables = items;\n        items.forEach(item => item._withDropContainer(this));\n        if (this.isDragging()) {\n            const draggedItems = previousItems.filter(item => item.isDragging());\n            // If all of the items being dragged were removed\n            // from the list, abort the current drag sequence.\n            if (draggedItems.every(item => items.indexOf(item) === -1)) {\n                this._reset();\n            }\n            else {\n                this._sortStrategy.withItems(this._draggables);\n            }\n        }\n        return this;\n    }\n    /** Sets the layout direction of the drop list. */\n    withDirection(direction) {\n        this._sortStrategy.direction = direction;\n        return this;\n    }\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @param connectedTo Other containers that the current containers should be connected to.\n     */\n    connectedTo(connectedTo) {\n        this._siblings = connectedTo.slice();\n        return this;\n    }\n    /**\n     * Sets the orientation of the container.\n     * @param orientation New orientation for the container.\n     */\n    withOrientation(orientation) {\n        // TODO(crisbeto): eventually we should be constructing the new sort strategy here based on\n        // the new orientation. For now we can assume that it'll always be `SingleAxisSortStrategy`.\n        this._sortStrategy.orientation = orientation;\n        return this;\n    }\n    /**\n     * Sets which parent elements are can be scrolled while the user is dragging.\n     * @param elements Elements that can be scrolled.\n     */\n    withScrollableParents(elements) {\n        const element = coerceElement(this.element);\n        // We always allow the current element to be scrollable\n        // so we need to ensure that it's in the array.\n        this._scrollableElements =\n            elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();\n        return this;\n    }\n    /** Gets the scrollable parents that are registered with this drop container. */\n    getScrollableParents() {\n        return this._scrollableElements;\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param item Item whose index should be determined.\n     */\n    getItemIndex(item) {\n        return this._isDragging\n            ? this._sortStrategy.getItemIndex(item)\n            : this._draggables.indexOf(item);\n    }\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     */\n    isReceiving() {\n        return this._activeSiblings.size > 0;\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param item Item to be sorted.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param pointerDelta Direction in which the pointer is moving along each axis.\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        // Don't sort the item if sorting is disabled or it's out of range.\n        if (this.sortingDisabled ||\n            !this._clientRect ||\n            !isPointerNearClientRect(this._clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {\n            return;\n        }\n        const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);\n        if (result) {\n            this.sorted.next({\n                previousIndex: result.previousIndex,\n                currentIndex: result.currentIndex,\n                container: this,\n                item,\n            });\n        }\n    }\n    /**\n     * Checks whether the user's pointer is close to the edges of either the\n     * viewport or the drop list and starts the auto-scroll sequence.\n     * @param pointerX User's pointer position along the x axis.\n     * @param pointerY User's pointer position along the y axis.\n     */\n    _startScrollingIfNecessary(pointerX, pointerY) {\n        if (this.autoScrollDisabled) {\n            return;\n        }\n        let scrollNode;\n        let verticalScrollDirection = 0 /* AutoScrollVerticalDirection.NONE */;\n        let horizontalScrollDirection = 0 /* AutoScrollHorizontalDirection.NONE */;\n        // Check whether we should start scrolling any of the parent containers.\n        this._parentPositions.positions.forEach((position, element) => {\n            // We have special handling for the `document` below. Also this would be\n            // nicer with a  for...of loop, but it requires changing a compiler flag.\n            if (element === this._document || !position.clientRect || scrollNode) {\n                return;\n            }\n            if (isPointerNearClientRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {\n                [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, pointerX, pointerY);\n                if (verticalScrollDirection || horizontalScrollDirection) {\n                    scrollNode = element;\n                }\n            }\n        });\n        // Otherwise check if we can start scrolling the viewport.\n        if (!verticalScrollDirection && !horizontalScrollDirection) {\n            const { width, height } = this._viewportRuler.getViewportSize();\n            const clientRect = {\n                width,\n                height,\n                top: 0,\n                right: width,\n                bottom: height,\n                left: 0,\n            };\n            verticalScrollDirection = getVerticalScrollDirection(clientRect, pointerY);\n            horizontalScrollDirection = getHorizontalScrollDirection(clientRect, pointerX);\n            scrollNode = window;\n        }\n        if (scrollNode &&\n            (verticalScrollDirection !== this._verticalScrollDirection ||\n                horizontalScrollDirection !== this._horizontalScrollDirection ||\n                scrollNode !== this._scrollNode)) {\n            this._verticalScrollDirection = verticalScrollDirection;\n            this._horizontalScrollDirection = horizontalScrollDirection;\n            this._scrollNode = scrollNode;\n            if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {\n                this._ngZone.runOutsideAngular(this._startScrollInterval);\n            }\n            else {\n                this._stopScrolling();\n            }\n        }\n    }\n    /** Stops any currently-running auto-scroll sequences. */\n    _stopScrolling() {\n        this._stopScrollTimers.next();\n    }\n    /** Starts the dragging sequence within the list. */\n    _draggingStarted() {\n        const styles = coerceElement(this.element).style;\n        this.beforeStarted.next();\n        this._isDragging = true;\n        // We need to disable scroll snapping while the user is dragging, because it breaks automatic\n        // scrolling. The browser seems to round the value based on the snapping points which means\n        // that we can't increment/decrement the scroll position.\n        this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || '';\n        styles.scrollSnapType = styles.msScrollSnapType = 'none';\n        this._sortStrategy.start(this._draggables);\n        this._cacheParentPositions();\n        this._viewportScrollSubscription.unsubscribe();\n        this._listenToScrollEvents();\n    }\n    /** Caches the positions of the configured scrollable parents. */\n    _cacheParentPositions() {\n        const element = coerceElement(this.element);\n        this._parentPositions.cache(this._scrollableElements);\n        // The list element is always in the `scrollableElements`\n        // so we can take advantage of the cached `ClientRect`.\n        this._clientRect = this._parentPositions.positions.get(element).clientRect;\n    }\n    /** Resets the container to its initial state. */\n    _reset() {\n        this._isDragging = false;\n        const styles = coerceElement(this.element).style;\n        styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;\n        this._siblings.forEach(sibling => sibling._stopReceiving(this));\n        this._sortStrategy.reset();\n        this._stopScrolling();\n        this._viewportScrollSubscription.unsubscribe();\n        this._parentPositions.clear();\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param x Pointer position along the X axis.\n     * @param y Pointer position along the Y axis.\n     */\n    _isOverContainer(x, y) {\n        return this._clientRect != null && isInsideClientRect(this._clientRect, x, y);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param item Drag item that is being moved.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        return this._siblings.find(sibling => sibling._canReceive(item, x, y));\n    }\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param item Item that is being dragged into the list.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    _canReceive(item, x, y) {\n        if (!this._clientRect ||\n            !isInsideClientRect(this._clientRect, x, y) ||\n            !this.enterPredicate(item, this)) {\n            return false;\n        }\n        const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);\n        // If there's no element at the pointer position, then\n        // the client rect is probably scrolled out of the view.\n        if (!elementFromPoint) {\n            return false;\n        }\n        const nativeElement = coerceElement(this.element);\n        // The `ClientRect`, that we're using to find the container over which the user is\n        // hovering, doesn't give us any information on whether the element has been scrolled\n        // out of the view or whether it's overlapping with other containers. This means that\n        // we could end up transferring the item into a container that's invisible or is positioned\n        // below another one. We use the result from `elementFromPoint` to get the top-most element\n        // at the pointer position and to find whether it's one of the intersecting drop containers.\n        return elementFromPoint === nativeElement || nativeElement.contains(elementFromPoint);\n    }\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param sibling Sibling in which dragging has started.\n     */\n    _startReceiving(sibling, items) {\n        const activeSiblings = this._activeSiblings;\n        if (!activeSiblings.has(sibling) &&\n            items.every(item => {\n                // Note that we have to add an exception to the `enterPredicate` for items that started off\n                // in this drop list. The drag ref has logic that allows an item to return to its initial\n                // container, if it has left the initial container and none of the connected containers\n                // allow it to enter. See `DragRef._updateActiveDropContainer` for more context.\n                return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;\n            })) {\n            activeSiblings.add(sibling);\n            this._cacheParentPositions();\n            this._listenToScrollEvents();\n            this.receivingStarted.next({\n                initiator: sibling,\n                receiver: this,\n                items,\n            });\n        }\n    }\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param sibling Sibling whose dragging has stopped.\n     */\n    _stopReceiving(sibling) {\n        this._activeSiblings.delete(sibling);\n        this._viewportScrollSubscription.unsubscribe();\n        this.receivingStopped.next({ initiator: sibling, receiver: this });\n    }\n    /**\n     * Starts listening to scroll events on the viewport.\n     * Used for updating the internal state of the list.\n     */\n    _listenToScrollEvents() {\n        this._viewportScrollSubscription = this._dragDropRegistry\n            .scrolled(this._getShadowRoot())\n            .subscribe(event => {\n            if (this.isDragging()) {\n                const scrollDifference = this._parentPositions.handleScroll(event);\n                if (scrollDifference) {\n                    this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);\n                }\n            }\n            else if (this.isReceiving()) {\n                this._cacheParentPositions();\n            }\n        });\n    }\n    /**\n     * Lazily resolves and returns the shadow root of the element. We do this in a function, rather\n     * than saving it in property directly on init, because we want to resolve it as late as possible\n     * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the\n     * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.\n     */\n    _getShadowRoot() {\n        if (!this._cachedShadowRoot) {\n            const shadowRoot = _getShadowRoot(coerceElement(this.element));\n            this._cachedShadowRoot = (shadowRoot || this._document);\n        }\n        return this._cachedShadowRoot;\n    }\n    /** Notifies any siblings that may potentially receive the item. */\n    _notifyReceivingSiblings() {\n        const draggedItems = this._sortStrategy\n            .getActiveItemsSnapshot()\n            .filter(item => item.isDragging());\n        this._siblings.forEach(sibling => sibling._startReceiving(this, draggedItems));\n    }\n}\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getVerticalScrollDirection(clientRect, pointerY) {\n    const { top, bottom, height } = clientRect;\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n        return 1 /* AutoScrollVerticalDirection.UP */;\n    }\n    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n        return 2 /* AutoScrollVerticalDirection.DOWN */;\n    }\n    return 0 /* AutoScrollVerticalDirection.NONE */;\n}\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerX Position of the user's pointer along the x axis.\n */\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\n    const { left, right, width } = clientRect;\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n        return 1 /* AutoScrollHorizontalDirection.LEFT */;\n    }\n    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n        return 2 /* AutoScrollHorizontalDirection.RIGHT */;\n    }\n    return 0 /* AutoScrollHorizontalDirection.NONE */;\n}\n/**\n * Gets the directions in which an element node should be scrolled,\n * assuming that the user's pointer is already within it scrollable region.\n * @param element Element for which we should calculate the scroll direction.\n * @param clientRect Bounding client rectangle of the element.\n * @param pointerX Position of the user's pointer along the x axis.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getElementScrollDirections(element, clientRect, pointerX, pointerY) {\n    const computedVertical = getVerticalScrollDirection(clientRect, pointerY);\n    const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);\n    let verticalScrollDirection = 0 /* AutoScrollVerticalDirection.NONE */;\n    let horizontalScrollDirection = 0 /* AutoScrollHorizontalDirection.NONE */;\n    // Note that we here we do some extra checks for whether the element is actually scrollable in\n    // a certain direction and we only assign the scroll direction if it is. We do this so that we\n    // can allow other elements to be scrolled, if the current element can't be scrolled anymore.\n    // This allows us to handle cases where the scroll regions of two scrollable elements overlap.\n    if (computedVertical) {\n        const scrollTop = element.scrollTop;\n        if (computedVertical === 1 /* AutoScrollVerticalDirection.UP */) {\n            if (scrollTop > 0) {\n                verticalScrollDirection = 1 /* AutoScrollVerticalDirection.UP */;\n            }\n        }\n        else if (element.scrollHeight - scrollTop > element.clientHeight) {\n            verticalScrollDirection = 2 /* AutoScrollVerticalDirection.DOWN */;\n        }\n    }\n    if (computedHorizontal) {\n        const scrollLeft = element.scrollLeft;\n        if (computedHorizontal === 1 /* AutoScrollHorizontalDirection.LEFT */) {\n            if (scrollLeft > 0) {\n                horizontalScrollDirection = 1 /* AutoScrollHorizontalDirection.LEFT */;\n            }\n        }\n        else if (element.scrollWidth - scrollLeft > element.clientWidth) {\n            horizontalScrollDirection = 2 /* AutoScrollHorizontalDirection.RIGHT */;\n        }\n    }\n    return [verticalScrollDirection, horizontalScrollDirection];\n}\n\n/** Event options that can be used to bind an active, capturing event. */\nconst activeCapturingEventOptions = normalizePassiveListenerOptions({\n    passive: false,\n    capture: true,\n});\n/**\n * Service that keeps track of all the drag item and drop container\n * instances, and manages global event listeners on the `document`.\n * @docs-private\n */\n// Note: this class is generic, rather than referencing CdkDrag and CdkDropList directly, in order\n// to avoid circular imports. If we were to reference them here, importing the registry into the\n// classes that are registering themselves will introduce a circular import.\nclass DragDropRegistry {\n    constructor(_ngZone, _document) {\n        this._ngZone = _ngZone;\n        /** Registered drop container instances. */\n        this._dropInstances = new Set();\n        /** Registered drag item instances. */\n        this._dragInstances = new Set();\n        /** Drag item instances that are currently being dragged. */\n        this._activeDragInstances = [];\n        /** Keeps track of the event listeners that we've bound to the `document`. */\n        this._globalListeners = new Map();\n        /**\n         * Predicate function to check if an item is being dragged.  Moved out into a property,\n         * because it'll be called a lot and we don't want to create a new function every time.\n         */\n        this._draggingPredicate = (item) => item.isDragging();\n        /**\n         * Emits the `touchmove` or `mousemove` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerMove = new Subject();\n        /**\n         * Emits the `touchend` or `mouseup` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerUp = new Subject();\n        /**\n         * Emits when the viewport has been scrolled while the user is dragging an item.\n         * @deprecated To be turned into a private member. Use the `scrolled` method instead.\n         * @breaking-change 13.0.0\n         */\n        this.scroll = new Subject();\n        /**\n         * Event listener that will prevent the default browser action while the user is dragging.\n         * @param event Event whose default action should be prevented.\n         */\n        this._preventDefaultWhileDragging = (event) => {\n            if (this._activeDragInstances.length > 0) {\n                event.preventDefault();\n            }\n        };\n        /** Event listener for `touchmove` that is bound even if no dragging is happening. */\n        this._persistentTouchmoveListener = (event) => {\n            if (this._activeDragInstances.length > 0) {\n                // Note that we only want to prevent the default action after dragging has actually started.\n                // Usually this is the same time at which the item is added to the `_activeDragInstances`,\n                // but it could be pushed back if the user has set up a drag delay or threshold.\n                if (this._activeDragInstances.some(this._draggingPredicate)) {\n                    event.preventDefault();\n                }\n                this.pointerMove.next(event);\n            }\n        };\n        this._document = _document;\n    }\n    /** Adds a drop container to the registry. */\n    registerDropContainer(drop) {\n        if (!this._dropInstances.has(drop)) {\n            this._dropInstances.add(drop);\n        }\n    }\n    /** Adds a drag item instance to the registry. */\n    registerDragItem(drag) {\n        this._dragInstances.add(drag);\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        if (this._dragInstances.size === 1) {\n            this._ngZone.runOutsideAngular(() => {\n                // The event handler has to be explicitly active,\n                // because newer browsers make it passive by default.\n                this._document.addEventListener('touchmove', this._persistentTouchmoveListener, activeCapturingEventOptions);\n            });\n        }\n    }\n    /** Removes a drop container from the registry. */\n    removeDropContainer(drop) {\n        this._dropInstances.delete(drop);\n    }\n    /** Removes a drag item instance from the registry. */\n    removeDragItem(drag) {\n        this._dragInstances.delete(drag);\n        this.stopDragging(drag);\n        if (this._dragInstances.size === 0) {\n            this._document.removeEventListener('touchmove', this._persistentTouchmoveListener, activeCapturingEventOptions);\n        }\n    }\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param drag Drag instance which is being dragged.\n     * @param event Event that initiated the dragging.\n     */\n    startDragging(drag, event) {\n        // Do not process the same drag twice to avoid memory leaks and redundant listeners\n        if (this._activeDragInstances.indexOf(drag) > -1) {\n            return;\n        }\n        this._activeDragInstances.push(drag);\n        if (this._activeDragInstances.length === 1) {\n            const isTouchEvent = event.type.startsWith('touch');\n            // We explicitly bind __active__ listeners here, because newer browsers will default to\n            // passive ones for `mousemove` and `touchmove`. The events need to be active, because we\n            // use `preventDefault` to prevent the page from scrolling while the user is dragging.\n            this._globalListeners\n                .set(isTouchEvent ? 'touchend' : 'mouseup', {\n                handler: (e) => this.pointerUp.next(e),\n                options: true,\n            })\n                .set('scroll', {\n                handler: (e) => this.scroll.next(e),\n                // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't\n                // the document. See https://github.com/angular/components/issues/17144.\n                options: true,\n            })\n                // Preventing the default action on `mousemove` isn't enough to disable text selection\n                // on Safari so we need to prevent the selection event as well. Alternatively this can\n                // be done by setting `user-select: none` on the `body`, however it has causes a style\n                // recalculation which can be expensive on pages with a lot of elements.\n                .set('selectstart', {\n                handler: this._preventDefaultWhileDragging,\n                options: activeCapturingEventOptions,\n            });\n            // We don't have to bind a move event for touch drag sequences, because\n            // we already have a persistent global one bound from `registerDragItem`.\n            if (!isTouchEvent) {\n                this._globalListeners.set('mousemove', {\n                    handler: (e) => this.pointerMove.next(e),\n                    options: activeCapturingEventOptions,\n                });\n            }\n            this._ngZone.runOutsideAngular(() => {\n                this._globalListeners.forEach((config, name) => {\n                    this._document.addEventListener(name, config.handler, config.options);\n                });\n            });\n        }\n    }\n    /** Stops dragging a drag item instance. */\n    stopDragging(drag) {\n        const index = this._activeDragInstances.indexOf(drag);\n        if (index > -1) {\n            this._activeDragInstances.splice(index, 1);\n            if (this._activeDragInstances.length === 0) {\n                this._clearGlobalListeners();\n            }\n        }\n    }\n    /** Gets whether a drag item instance is currently being dragged. */\n    isDragging(drag) {\n        return this._activeDragInstances.indexOf(drag) > -1;\n    }\n    /**\n     * Gets a stream that will emit when any element on the page is scrolled while an item is being\n     * dragged.\n     * @param shadowRoot Optional shadow root that the current dragging sequence started from.\n     *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can\n     *   be used to include an additional top-level listener at the shadow root level.\n     */\n    scrolled(shadowRoot) {\n        const streams = [this.scroll];\n        if (shadowRoot && shadowRoot !== this._document) {\n            // Note that this is basically the same as `fromEvent` from rxjs, but we do it ourselves,\n            // because we want to guarantee that the event is bound outside of the `NgZone`. With\n            // `fromEvent` it'll only happen if the subscription is outside the `NgZone`.\n            streams.push(new Observable((observer) => {\n                return this._ngZone.runOutsideAngular(() => {\n                    const eventOptions = true;\n                    const callback = (event) => {\n                        if (this._activeDragInstances.length) {\n                            observer.next(event);\n                        }\n                    };\n                    shadowRoot.addEventListener('scroll', callback, eventOptions);\n                    return () => {\n                        shadowRoot.removeEventListener('scroll', callback, eventOptions);\n                    };\n                });\n            }));\n        }\n        return merge(...streams);\n    }\n    ngOnDestroy() {\n        this._dragInstances.forEach(instance => this.removeDragItem(instance));\n        this._dropInstances.forEach(instance => this.removeDropContainer(instance));\n        this._clearGlobalListeners();\n        this.pointerMove.complete();\n        this.pointerUp.complete();\n    }\n    /** Clears out the global event listeners from the `document`. */\n    _clearGlobalListeners() {\n        this._globalListeners.forEach((config, name) => {\n            this._document.removeEventListener(name, config.handler, config.options);\n        });\n        this._globalListeners.clear();\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: DragDropRegistry, deps: [{ token: i0.NgZone }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: DragDropRegistry, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: DragDropRegistry, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n\n/** Default configuration to be used when creating a `DragRef`. */\nconst DEFAULT_CONFIG = {\n    dragStartThreshold: 5,\n    pointerDirectionChangeThreshold: 5,\n};\n/**\n * Service that allows for drag-and-drop functionality to be attached to DOM elements.\n */\nclass DragDrop {\n    constructor(_document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n    }\n    /**\n     * Turns an element into a draggable item.\n     * @param element Element to which to attach the dragging functionality.\n     * @param config Object used to configure the dragging behavior.\n     */\n    createDrag(element, config = DEFAULT_CONFIG) {\n        return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);\n    }\n    /**\n     * Turns an element into a drop list.\n     * @param element Element to which to attach the drop list functionality.\n     */\n    createDropList(element) {\n        return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: DragDrop, deps: [{ token: DOCUMENT }, { token: i0.NgZone }, { token: i1.ViewportRuler }, { token: DragDropRegistry }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: DragDrop, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: DragDrop, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i0.NgZone }, { type: i1.ViewportRuler }, { type: DragDropRegistry }] });\n\n/**\n * Injection token that can be used for a `CdkDrag` to provide itself as a parent to the\n * drag-specific child directive (`CdkDragHandle`, `CdkDragPreview` etc.). Used primarily\n * to avoid circular imports.\n * @docs-private\n */\nconst CDK_DRAG_PARENT = new InjectionToken('CDK_DRAG_PARENT');\n\n/**\n * Asserts that a particular node is an element.\n * @param node Node to be checked.\n * @param name Name to attach to the error message.\n */\nfunction assertElementNode(node, name) {\n    if (node.nodeType !== 1) {\n        throw Error(`${name} must be attached to an element node. ` + `Currently attached to \"${node.nodeName}\".`);\n    }\n}\n\n/**\n * Injection token that can be used to reference instances of `CdkDragHandle`. It serves as\n * alternative token to the actual `CdkDragHandle` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DRAG_HANDLE = new InjectionToken('CdkDragHandle');\n/** Handle that can be used to drag a CdkDrag instance. */\nclass CdkDragHandle {\n    /** Whether starting to drag through this handle is disabled. */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = value;\n        this._stateChanges.next(this);\n    }\n    constructor(element, parentDrag) {\n        this.element = element;\n        /** Emits when the state of the handle has changed. */\n        this._stateChanges = new Subject();\n        this._disabled = false;\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            assertElementNode(element.nativeElement, 'cdkDragHandle');\n        }\n        this._parentDrag = parentDrag;\n    }\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDragHandle, deps: [{ token: i0.ElementRef }, { token: CDK_DRAG_PARENT, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"17.0.4\", type: CdkDragHandle, isStandalone: true, selector: \"[cdkDragHandle]\", inputs: { disabled: [\"cdkDragHandleDisabled\", \"disabled\", booleanAttribute] }, host: { classAttribute: \"cdk-drag-handle\" }, providers: [{ provide: CDK_DRAG_HANDLE, useExisting: CdkDragHandle }], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDragHandle, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkDragHandle]',\n                    standalone: true,\n                    host: {\n                        'class': 'cdk-drag-handle',\n                    },\n                    providers: [{ provide: CDK_DRAG_HANDLE, useExisting: CdkDragHandle }],\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [CDK_DRAG_PARENT]\n                }, {\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }], propDecorators: { disabled: [{\n                type: Input,\n                args: [{ alias: 'cdkDragHandleDisabled', transform: booleanAttribute }]\n            }] } });\n\n/**\n * Injection token that can be used to reference instances of `CdkDragPlaceholder`. It serves as\n * alternative token to the actual `CdkDragPlaceholder` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DRAG_PLACEHOLDER = new InjectionToken('CdkDragPlaceholder');\n/**\n * Element that will be used as a template for the placeholder of a CdkDrag when\n * it is being dragged. The placeholder is displayed in place of the element being dragged.\n */\nclass CdkDragPlaceholder {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDragPlaceholder, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: CdkDragPlaceholder, isStandalone: true, selector: \"ng-template[cdkDragPlaceholder]\", inputs: { data: \"data\" }, providers: [{ provide: CDK_DRAG_PLACEHOLDER, useExisting: CdkDragPlaceholder }], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDragPlaceholder, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'ng-template[cdkDragPlaceholder]',\n                    standalone: true,\n                    providers: [{ provide: CDK_DRAG_PLACEHOLDER, useExisting: CdkDragPlaceholder }],\n                }]\n        }], ctorParameters: () => [{ type: i0.TemplateRef }], propDecorators: { data: [{\n                type: Input\n            }] } });\n\n/**\n * Injection token that can be used to reference instances of `CdkDragPreview`. It serves as\n * alternative token to the actual `CdkDragPreview` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DRAG_PREVIEW = new InjectionToken('CdkDragPreview');\n/**\n * Element that will be used as a template for the preview\n * of a CdkDrag when it is being dragged.\n */\nclass CdkDragPreview {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n        /** Whether the preview should preserve the same size as the item that is being dragged. */\n        this.matchSize = false;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDragPreview, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"17.0.4\", type: CdkDragPreview, isStandalone: true, selector: \"ng-template[cdkDragPreview]\", inputs: { data: \"data\", matchSize: [\"matchSize\", \"matchSize\", booleanAttribute] }, providers: [{ provide: CDK_DRAG_PREVIEW, useExisting: CdkDragPreview }], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDragPreview, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'ng-template[cdkDragPreview]',\n                    standalone: true,\n                    providers: [{ provide: CDK_DRAG_PREVIEW, useExisting: CdkDragPreview }],\n                }]\n        }], ctorParameters: () => [{ type: i0.TemplateRef }], propDecorators: { data: [{\n                type: Input\n            }], matchSize: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }] } });\n\n/**\n * Injection token that can be used to configure the\n * behavior of the drag&drop-related components.\n */\nconst CDK_DRAG_CONFIG = new InjectionToken('CDK_DRAG_CONFIG');\n\nconst DRAG_HOST_CLASS = 'cdk-drag';\n/**\n * Injection token that can be used to reference instances of `CdkDropList`. It serves as\n * alternative token to the actual `CdkDropList` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DROP_LIST = new InjectionToken('CdkDropList');\n/** Element that can be moved inside a CdkDropList container. */\nclass CdkDrag {\n    static { this._dragInstances = []; }\n    /** Whether starting to drag this element is disabled. */\n    get disabled() {\n        return this._disabled || (this.dropContainer && this.dropContainer.disabled);\n    }\n    set disabled(value) {\n        this._disabled = value;\n        this._dragRef.disabled = this._disabled;\n    }\n    constructor(\n    /** Element that the draggable is attached to. */\n    element, \n    /** Droppable container that the draggable is a part of. */\n    dropContainer, \n    /**\n     * @deprecated `_document` parameter no longer being used and will be removed.\n     * @breaking-change 12.0.0\n     */\n    _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef, _selfHandle, _parentDrag) {\n        this.element = element;\n        this.dropContainer = dropContainer;\n        this._ngZone = _ngZone;\n        this._viewContainerRef = _viewContainerRef;\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._selfHandle = _selfHandle;\n        this._parentDrag = _parentDrag;\n        this._destroyed = new Subject();\n        /** Emits when the user starts dragging the item. */\n        this.started = new EventEmitter();\n        /** Emits when the user has released a drag item, before any animations have started. */\n        this.released = new EventEmitter();\n        /** Emits when the user stops dragging an item in the container. */\n        this.ended = new EventEmitter();\n        /** Emits when the user has moved the item into a new container. */\n        this.entered = new EventEmitter();\n        /** Emits when the user removes the item its container by dragging it into another container. */\n        this.exited = new EventEmitter();\n        /** Emits when the user drops the item inside a container. */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = new Observable((observer) => {\n            const subscription = this._dragRef.moved\n                .pipe(map(movedEvent => ({\n                source: this,\n                pointerPosition: movedEvent.pointerPosition,\n                event: movedEvent.event,\n                delta: movedEvent.delta,\n                distance: movedEvent.distance,\n            })))\n                .subscribe(observer);\n            return () => {\n                subscription.unsubscribe();\n            };\n        });\n        this._dragRef = dragDrop.createDrag(element, {\n            dragStartThreshold: config && config.dragStartThreshold != null ? config.dragStartThreshold : 5,\n            pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null\n                ? config.pointerDirectionChangeThreshold\n                : 5,\n            zIndex: config?.zIndex,\n        });\n        this._dragRef.data = this;\n        // We have to keep track of the drag instances in order to be able to match an element to\n        // a drag instance. We can't go through the global registry of `DragRef`, because the root\n        // element could be different.\n        CdkDrag._dragInstances.push(this);\n        if (config) {\n            this._assignDefaults(config);\n        }\n        // Note that usually the container is assigned when the drop list is picks up the item, but in\n        // some cases (mainly transplanted views with OnPush, see #18341) we may end up in a situation\n        // where there are no items on the first change detection pass, but the items get picked up as\n        // soon as the user triggers another pass by dragging. This is a problem, because the item would\n        // have to switch from standalone mode to drag mode in the middle of the dragging sequence which\n        // is too late since the two modes save different kinds of information. We work around it by\n        // assigning the drop container both from here and the list.\n        if (dropContainer) {\n            this._dragRef._withDropContainer(dropContainer._dropListRef);\n            dropContainer.addItem(this);\n        }\n        this._syncInputs(this._dragRef);\n        this._handleEvents(this._dragRef);\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     */\n    getPlaceholderElement() {\n        return this._dragRef.getPlaceholderElement();\n    }\n    /** Returns the root draggable element. */\n    getRootElement() {\n        return this._dragRef.getRootElement();\n    }\n    /** Resets a standalone drag item to its initial position. */\n    reset() {\n        this._dragRef.reset();\n    }\n    /**\n     * Gets the pixel coordinates of the draggable outside of a drop container.\n     */\n    getFreeDragPosition() {\n        return this._dragRef.getFreeDragPosition();\n    }\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @param value New position to be set.\n     */\n    setFreeDragPosition(value) {\n        this._dragRef.setFreeDragPosition(value);\n    }\n    ngAfterViewInit() {\n        // Normally this isn't in the zone, but it can cause major performance regressions for apps\n        // using `zone-patch-rxjs` because it'll trigger a change detection when it unsubscribes.\n        this._ngZone.runOutsideAngular(() => {\n            // We need to wait for the zone to stabilize, in order for the reference\n            // element to be in the proper place in the DOM. This is mostly relevant\n            // for draggable elements inside portals since they get stamped out in\n            // their original DOM position and then they get transferred to the portal.\n            this._ngZone.onStable.pipe(take(1), takeUntil(this._destroyed)).subscribe(() => {\n                this._updateRootElement();\n                this._setupHandlesListener();\n                if (this.freeDragPosition) {\n                    this._dragRef.setFreeDragPosition(this.freeDragPosition);\n                }\n            });\n        });\n    }\n    ngOnChanges(changes) {\n        const rootSelectorChange = changes['rootElementSelector'];\n        const positionChange = changes['freeDragPosition'];\n        // We don't have to react to the first change since it's being\n        // handled in `ngAfterViewInit` where it needs to be deferred.\n        if (rootSelectorChange && !rootSelectorChange.firstChange) {\n            this._updateRootElement();\n        }\n        // Skip the first change since it's being handled in `ngAfterViewInit`.\n        if (positionChange && !positionChange.firstChange && this.freeDragPosition) {\n            this._dragRef.setFreeDragPosition(this.freeDragPosition);\n        }\n    }\n    ngOnDestroy() {\n        if (this.dropContainer) {\n            this.dropContainer.removeItem(this);\n        }\n        const index = CdkDrag._dragInstances.indexOf(this);\n        if (index > -1) {\n            CdkDrag._dragInstances.splice(index, 1);\n        }\n        // Unnecessary in most cases, but used to avoid extra change detections with `zone-paths-rxjs`.\n        this._ngZone.runOutsideAngular(() => {\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._dragRef.dispose();\n        });\n    }\n    /** Syncs the root element with the `DragRef`. */\n    _updateRootElement() {\n        const element = this.element.nativeElement;\n        let rootElement = element;\n        if (this.rootElementSelector) {\n            rootElement =\n                element.closest !== undefined\n                    ? element.closest(this.rootElementSelector)\n                    : // Comment tag doesn't have closest method, so use parent's one.\n                        element.parentElement?.closest(this.rootElementSelector);\n        }\n        if (rootElement && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            assertElementNode(rootElement, 'cdkDrag');\n        }\n        this._dragRef.withRootElement(rootElement || element);\n    }\n    /** Gets the boundary element, based on the `boundaryElement` value. */\n    _getBoundaryElement() {\n        const boundary = this.boundaryElement;\n        if (!boundary) {\n            return null;\n        }\n        if (typeof boundary === 'string') {\n            return this.element.nativeElement.closest(boundary);\n        }\n        return coerceElement(boundary);\n    }\n    /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */\n    _syncInputs(ref) {\n        ref.beforeStarted.subscribe(() => {\n            if (!ref.isDragging()) {\n                const dir = this._dir;\n                const dragStartDelay = this.dragStartDelay;\n                const placeholder = this._placeholderTemplate\n                    ? {\n                        template: this._placeholderTemplate.templateRef,\n                        context: this._placeholderTemplate.data,\n                        viewContainer: this._viewContainerRef,\n                    }\n                    : null;\n                const preview = this._previewTemplate\n                    ? {\n                        template: this._previewTemplate.templateRef,\n                        context: this._previewTemplate.data,\n                        matchSize: this._previewTemplate.matchSize,\n                        viewContainer: this._viewContainerRef,\n                    }\n                    : null;\n                ref.disabled = this.disabled;\n                ref.lockAxis = this.lockAxis;\n                ref.dragStartDelay =\n                    typeof dragStartDelay === 'object' && dragStartDelay\n                        ? dragStartDelay\n                        : coerceNumberProperty(dragStartDelay);\n                ref.constrainPosition = this.constrainPosition;\n                ref.previewClass = this.previewClass;\n                ref\n                    .withBoundaryElement(this._getBoundaryElement())\n                    .withPlaceholderTemplate(placeholder)\n                    .withPreviewTemplate(preview)\n                    .withPreviewContainer(this.previewContainer || 'global');\n                if (dir) {\n                    ref.withDirection(dir.value);\n                }\n            }\n        });\n        // This only needs to be resolved once.\n        ref.beforeStarted.pipe(take(1)).subscribe(() => {\n            // If we managed to resolve a parent through DI, use it.\n            if (this._parentDrag) {\n                ref.withParent(this._parentDrag._dragRef);\n                return;\n            }\n            // Otherwise fall back to resolving the parent by looking up the DOM. This can happen if\n            // the item was projected into another item by something like `ngTemplateOutlet`.\n            let parent = this.element.nativeElement.parentElement;\n            while (parent) {\n                if (parent.classList.contains(DRAG_HOST_CLASS)) {\n                    ref.withParent(CdkDrag._dragInstances.find(drag => {\n                        return drag.element.nativeElement === parent;\n                    })?._dragRef || null);\n                    break;\n                }\n                parent = parent.parentElement;\n            }\n        });\n    }\n    /** Handles the events from the underlying `DragRef`. */\n    _handleEvents(ref) {\n        ref.started.subscribe(startEvent => {\n            this.started.emit({ source: this, event: startEvent.event });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        });\n        ref.released.subscribe(releaseEvent => {\n            this.released.emit({ source: this, event: releaseEvent.event });\n        });\n        ref.ended.subscribe(endEvent => {\n            this.ended.emit({\n                source: this,\n                distance: endEvent.distance,\n                dropPoint: endEvent.dropPoint,\n                event: endEvent.event,\n            });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        });\n        ref.entered.subscribe(enterEvent => {\n            this.entered.emit({\n                container: enterEvent.container.data,\n                item: this,\n                currentIndex: enterEvent.currentIndex,\n            });\n        });\n        ref.exited.subscribe(exitEvent => {\n            this.exited.emit({\n                container: exitEvent.container.data,\n                item: this,\n            });\n        });\n        ref.dropped.subscribe(dropEvent => {\n            this.dropped.emit({\n                previousIndex: dropEvent.previousIndex,\n                currentIndex: dropEvent.currentIndex,\n                previousContainer: dropEvent.previousContainer.data,\n                container: dropEvent.container.data,\n                isPointerOverContainer: dropEvent.isPointerOverContainer,\n                item: this,\n                distance: dropEvent.distance,\n                dropPoint: dropEvent.dropPoint,\n                event: dropEvent.event,\n            });\n        });\n    }\n    /** Assigns the default input values based on a provided config object. */\n    _assignDefaults(config) {\n        const { lockAxis, dragStartDelay, constrainPosition, previewClass, boundaryElement, draggingDisabled, rootElementSelector, previewContainer, } = config;\n        this.disabled = draggingDisabled == null ? false : draggingDisabled;\n        this.dragStartDelay = dragStartDelay || 0;\n        if (lockAxis) {\n            this.lockAxis = lockAxis;\n        }\n        if (constrainPosition) {\n            this.constrainPosition = constrainPosition;\n        }\n        if (previewClass) {\n            this.previewClass = previewClass;\n        }\n        if (boundaryElement) {\n            this.boundaryElement = boundaryElement;\n        }\n        if (rootElementSelector) {\n            this.rootElementSelector = rootElementSelector;\n        }\n        if (previewContainer) {\n            this.previewContainer = previewContainer;\n        }\n    }\n    /** Sets up the listener that syncs the handles with the drag ref. */\n    _setupHandlesListener() {\n        // Listen for any newly-added handles.\n        this._handles.changes\n            .pipe(startWith(this._handles), \n        // Sync the new handles with the DragRef.\n        tap((handles) => {\n            const childHandleElements = handles\n                .filter(handle => handle._parentDrag === this)\n                .map(handle => handle.element);\n            // Usually handles are only allowed to be a descendant of the drag element, but if\n            // the consumer defined a different drag root, we should allow the drag element\n            // itself to be a handle too.\n            if (this._selfHandle && this.rootElementSelector) {\n                childHandleElements.push(this.element);\n            }\n            this._dragRef.withHandles(childHandleElements);\n        }), \n        // Listen if the state of any of the handles changes.\n        switchMap((handles) => {\n            return merge(...handles.map(item => {\n                return item._stateChanges.pipe(startWith(item));\n            }));\n        }), takeUntil(this._destroyed))\n            .subscribe(handleInstance => {\n            // Enabled/disable the handle that changed in the DragRef.\n            const dragRef = this._dragRef;\n            const handle = handleInstance.element.nativeElement;\n            handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);\n        });\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDrag, deps: [{ token: i0.ElementRef }, { token: CDK_DROP_LIST, optional: true, skipSelf: true }, { token: DOCUMENT }, { token: i0.NgZone }, { token: i0.ViewContainerRef }, { token: CDK_DRAG_CONFIG, optional: true }, { token: i1$1.Directionality, optional: true }, { token: DragDrop }, { token: i0.ChangeDetectorRef }, { token: CDK_DRAG_HANDLE, optional: true, self: true }, { token: CDK_DRAG_PARENT, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"17.0.4\", type: CdkDrag, isStandalone: true, selector: \"[cdkDrag]\", inputs: { data: [\"cdkDragData\", \"data\"], lockAxis: [\"cdkDragLockAxis\", \"lockAxis\"], rootElementSelector: [\"cdkDragRootElement\", \"rootElementSelector\"], boundaryElement: [\"cdkDragBoundary\", \"boundaryElement\"], dragStartDelay: [\"cdkDragStartDelay\", \"dragStartDelay\"], freeDragPosition: [\"cdkDragFreeDragPosition\", \"freeDragPosition\"], disabled: [\"cdkDragDisabled\", \"disabled\", booleanAttribute], constrainPosition: [\"cdkDragConstrainPosition\", \"constrainPosition\"], previewClass: [\"cdkDragPreviewClass\", \"previewClass\"], previewContainer: [\"cdkDragPreviewContainer\", \"previewContainer\"] }, outputs: { started: \"cdkDragStarted\", released: \"cdkDragReleased\", ended: \"cdkDragEnded\", entered: \"cdkDragEntered\", exited: \"cdkDragExited\", dropped: \"cdkDragDropped\", moved: \"cdkDragMoved\" }, host: { properties: { \"class.cdk-drag-disabled\": \"disabled\", \"class.cdk-drag-dragging\": \"_dragRef.isDragging()\" }, classAttribute: \"cdk-drag\" }, providers: [{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }], queries: [{ propertyName: \"_previewTemplate\", first: true, predicate: CDK_DRAG_PREVIEW, descendants: true }, { propertyName: \"_placeholderTemplate\", first: true, predicate: CDK_DRAG_PLACEHOLDER, descendants: true }, { propertyName: \"_handles\", predicate: CDK_DRAG_HANDLE, descendants: true }], exportAs: [\"cdkDrag\"], usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDrag, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkDrag]',\n                    exportAs: 'cdkDrag',\n                    standalone: true,\n                    host: {\n                        'class': DRAG_HOST_CLASS,\n                        '[class.cdk-drag-disabled]': 'disabled',\n                        '[class.cdk-drag-dragging]': '_dragRef.isDragging()',\n                    },\n                    providers: [{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }],\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [CDK_DROP_LIST]\n                }, {\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i0.NgZone }, { type: i0.ViewContainerRef }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [CDK_DRAG_CONFIG]\n                }] }, { type: i1$1.Directionality, decorators: [{\n                    type: Optional\n                }] }, { type: DragDrop }, { type: i0.ChangeDetectorRef }, { type: CdkDragHandle, decorators: [{\n                    type: Optional\n                }, {\n                    type: Self\n                }, {\n                    type: Inject,\n                    args: [CDK_DRAG_HANDLE]\n                }] }, { type: CdkDrag, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }, {\n                    type: Inject,\n                    args: [CDK_DRAG_PARENT]\n                }] }], propDecorators: { _handles: [{\n                type: ContentChildren,\n                args: [CDK_DRAG_HANDLE, { descendants: true }]\n            }], _previewTemplate: [{\n                type: ContentChild,\n                args: [CDK_DRAG_PREVIEW]\n            }], _placeholderTemplate: [{\n                type: ContentChild,\n                args: [CDK_DRAG_PLACEHOLDER]\n            }], data: [{\n                type: Input,\n                args: ['cdkDragData']\n            }], lockAxis: [{\n                type: Input,\n                args: ['cdkDragLockAxis']\n            }], rootElementSelector: [{\n                type: Input,\n                args: ['cdkDragRootElement']\n            }], boundaryElement: [{\n                type: Input,\n                args: ['cdkDragBoundary']\n            }], dragStartDelay: [{\n                type: Input,\n                args: ['cdkDragStartDelay']\n            }], freeDragPosition: [{\n                type: Input,\n                args: ['cdkDragFreeDragPosition']\n            }], disabled: [{\n                type: Input,\n                args: [{ alias: 'cdkDragDisabled', transform: booleanAttribute }]\n            }], constrainPosition: [{\n                type: Input,\n                args: ['cdkDragConstrainPosition']\n            }], previewClass: [{\n                type: Input,\n                args: ['cdkDragPreviewClass']\n            }], previewContainer: [{\n                type: Input,\n                args: ['cdkDragPreviewContainer']\n            }], started: [{\n                type: Output,\n                args: ['cdkDragStarted']\n            }], released: [{\n                type: Output,\n                args: ['cdkDragReleased']\n            }], ended: [{\n                type: Output,\n                args: ['cdkDragEnded']\n            }], entered: [{\n                type: Output,\n                args: ['cdkDragEntered']\n            }], exited: [{\n                type: Output,\n                args: ['cdkDragExited']\n            }], dropped: [{\n                type: Output,\n                args: ['cdkDragDropped']\n            }], moved: [{\n                type: Output,\n                args: ['cdkDragMoved']\n            }] } });\n\n/**\n * Injection token that can be used to reference instances of `CdkDropListGroup`. It serves as\n * alternative token to the actual `CdkDropListGroup` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DROP_LIST_GROUP = new InjectionToken('CdkDropListGroup');\n/**\n * Declaratively connects sibling `cdkDropList` instances together. All of the `cdkDropList`\n * elements that are placed inside a `cdkDropListGroup` will be connected to each other\n * automatically. Can be used as an alternative to the `cdkDropListConnectedTo` input\n * from `cdkDropList`.\n */\nclass CdkDropListGroup {\n    constructor() {\n        /** Drop lists registered inside the group. */\n        this._items = new Set();\n        /** Whether starting a dragging sequence from inside this group is disabled. */\n        this.disabled = false;\n    }\n    ngOnDestroy() {\n        this._items.clear();\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDropListGroup, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"17.0.4\", type: CdkDropListGroup, isStandalone: true, selector: \"[cdkDropListGroup]\", inputs: { disabled: [\"cdkDropListGroupDisabled\", \"disabled\", booleanAttribute] }, providers: [{ provide: CDK_DROP_LIST_GROUP, useExisting: CdkDropListGroup }], exportAs: [\"cdkDropListGroup\"], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDropListGroup, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkDropListGroup]',\n                    exportAs: 'cdkDropListGroup',\n                    standalone: true,\n                    providers: [{ provide: CDK_DROP_LIST_GROUP, useExisting: CdkDropListGroup }],\n                }]\n        }], propDecorators: { disabled: [{\n                type: Input,\n                args: [{ alias: 'cdkDropListGroupDisabled', transform: booleanAttribute }]\n            }] } });\n\n/** Counter used to generate unique ids for drop zones. */\nlet _uniqueIdCounter = 0;\n/** Container that wraps a set of draggable items. */\nclass CdkDropList {\n    /** Keeps track of the drop lists that are currently on the page. */\n    static { this._dropLists = []; }\n    /** Whether starting a dragging sequence from this container is disabled. */\n    get disabled() {\n        return this._disabled || (!!this._group && this._group.disabled);\n    }\n    set disabled(value) {\n        // Usually we sync the directive and ref state right before dragging starts, in order to have\n        // a single point of failure and to avoid having to use setters for everything. `disabled` is\n        // a special case, because it can prevent the `beforeStarted` event from firing, which can lock\n        // the user in a disabled state, so we also need to sync it as it's being set.\n        this._dropListRef.disabled = this._disabled = value;\n    }\n    constructor(\n    /** Element that the drop list is attached to. */\n    element, dragDrop, _changeDetectorRef, _scrollDispatcher, _dir, _group, config) {\n        this.element = element;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._dir = _dir;\n        this._group = _group;\n        /** Emits when the list has been destroyed. */\n        this._destroyed = new Subject();\n        /**\n         * Other draggable containers that this container is connected to and into which the\n         * container's items can be transferred. Can either be references to other drop containers,\n         * or their unique IDs.\n         */\n        this.connectedTo = [];\n        /**\n         * Unique ID for the drop zone. Can be used as a reference\n         * in the `connectedTo` of another `CdkDropList`.\n         */\n        this.id = `cdk-drop-list-${_uniqueIdCounter++}`;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = () => true;\n        /** Functions that is used to determine whether an item can be sorted into a particular index. */\n        this.sortPredicate = () => true;\n        /** Emits when the user drops an item inside the container. */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /** Emits as the user is swapping items while actively dragging. */\n        this.sorted = new EventEmitter();\n        /**\n         * Keeps track of the items that are registered with this container. Historically we used to\n         * do this with a `ContentChildren` query, however queries don't handle transplanted views very\n         * well which means that we can't handle cases like dragging the headers of a `mat-table`\n         * correctly. What we do instead is to have the items register themselves with the container\n         * and then we sort them based on their position in the DOM.\n         */\n        this._unsortedItems = new Set();\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            assertElementNode(element.nativeElement, 'cdkDropList');\n        }\n        this._dropListRef = dragDrop.createDropList(element);\n        this._dropListRef.data = this;\n        if (config) {\n            this._assignDefaults(config);\n        }\n        this._dropListRef.enterPredicate = (drag, drop) => {\n            return this.enterPredicate(drag.data, drop.data);\n        };\n        this._dropListRef.sortPredicate = (index, drag, drop) => {\n            return this.sortPredicate(index, drag.data, drop.data);\n        };\n        this._setupInputSyncSubscription(this._dropListRef);\n        this._handleEvents(this._dropListRef);\n        CdkDropList._dropLists.push(this);\n        if (_group) {\n            _group._items.add(this);\n        }\n    }\n    /** Registers an items with the drop list. */\n    addItem(item) {\n        this._unsortedItems.add(item);\n        if (this._dropListRef.isDragging()) {\n            this._syncItemsWithRef();\n        }\n    }\n    /** Removes an item from the drop list. */\n    removeItem(item) {\n        this._unsortedItems.delete(item);\n        if (this._dropListRef.isDragging()) {\n            this._syncItemsWithRef();\n        }\n    }\n    /** Gets the registered items in the list, sorted by their position in the DOM. */\n    getSortedItems() {\n        return Array.from(this._unsortedItems).sort((a, b) => {\n            const documentPosition = a._dragRef\n                .getVisibleElement()\n                .compareDocumentPosition(b._dragRef.getVisibleElement());\n            // `compareDocumentPosition` returns a bitmask so we have to use a bitwise operator.\n            // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n            // tslint:disable-next-line:no-bitwise\n            return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;\n        });\n    }\n    ngOnDestroy() {\n        const index = CdkDropList._dropLists.indexOf(this);\n        if (index > -1) {\n            CdkDropList._dropLists.splice(index, 1);\n        }\n        if (this._group) {\n            this._group._items.delete(this);\n        }\n        this._unsortedItems.clear();\n        this._dropListRef.dispose();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */\n    _setupInputSyncSubscription(ref) {\n        if (this._dir) {\n            this._dir.change\n                .pipe(startWith(this._dir.value), takeUntil(this._destroyed))\n                .subscribe(value => ref.withDirection(value));\n        }\n        ref.beforeStarted.subscribe(() => {\n            const siblings = coerceArray(this.connectedTo).map(drop => {\n                if (typeof drop === 'string') {\n                    const correspondingDropList = CdkDropList._dropLists.find(list => list.id === drop);\n                    if (!correspondingDropList && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                        console.warn(`CdkDropList could not find connected drop list with id \"${drop}\"`);\n                    }\n                    return correspondingDropList;\n                }\n                return drop;\n            });\n            if (this._group) {\n                this._group._items.forEach(drop => {\n                    if (siblings.indexOf(drop) === -1) {\n                        siblings.push(drop);\n                    }\n                });\n            }\n            // Note that we resolve the scrollable parents here so that we delay the resolution\n            // as long as possible, ensuring that the element is in its final place in the DOM.\n            if (!this._scrollableParentsResolved) {\n                const scrollableParents = this._scrollDispatcher\n                    .getAncestorScrollContainers(this.element)\n                    .map(scrollable => scrollable.getElementRef().nativeElement);\n                this._dropListRef.withScrollableParents(scrollableParents);\n                // Only do this once since it involves traversing the DOM and the parents\n                // shouldn't be able to change without the drop list being destroyed.\n                this._scrollableParentsResolved = true;\n            }\n            ref.disabled = this.disabled;\n            ref.lockAxis = this.lockAxis;\n            ref.sortingDisabled = this.sortingDisabled;\n            ref.autoScrollDisabled = this.autoScrollDisabled;\n            ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);\n            ref\n                .connectedTo(siblings.filter(drop => drop && drop !== this).map(list => list._dropListRef))\n                .withOrientation(this.orientation);\n        });\n    }\n    /** Handles events from the underlying DropListRef. */\n    _handleEvents(ref) {\n        ref.beforeStarted.subscribe(() => {\n            this._syncItemsWithRef();\n            this._changeDetectorRef.markForCheck();\n        });\n        ref.entered.subscribe(event => {\n            this.entered.emit({\n                container: this,\n                item: event.item.data,\n                currentIndex: event.currentIndex,\n            });\n        });\n        ref.exited.subscribe(event => {\n            this.exited.emit({\n                container: this,\n                item: event.item.data,\n            });\n            this._changeDetectorRef.markForCheck();\n        });\n        ref.sorted.subscribe(event => {\n            this.sorted.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                container: this,\n                item: event.item.data,\n            });\n        });\n        ref.dropped.subscribe(dropEvent => {\n            this.dropped.emit({\n                previousIndex: dropEvent.previousIndex,\n                currentIndex: dropEvent.currentIndex,\n                previousContainer: dropEvent.previousContainer.data,\n                container: dropEvent.container.data,\n                item: dropEvent.item.data,\n                isPointerOverContainer: dropEvent.isPointerOverContainer,\n                distance: dropEvent.distance,\n                dropPoint: dropEvent.dropPoint,\n                event: dropEvent.event,\n            });\n            // Mark for check since all of these events run outside of change\n            // detection and we're not guaranteed for something else to have triggered it.\n            this._changeDetectorRef.markForCheck();\n        });\n        merge(ref.receivingStarted, ref.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());\n    }\n    /** Assigns the default input values based on a provided config object. */\n    _assignDefaults(config) {\n        const { lockAxis, draggingDisabled, sortingDisabled, listAutoScrollDisabled, listOrientation } = config;\n        this.disabled = draggingDisabled == null ? false : draggingDisabled;\n        this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;\n        this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;\n        this.orientation = listOrientation || 'vertical';\n        if (lockAxis) {\n            this.lockAxis = lockAxis;\n        }\n    }\n    /** Syncs up the registered drag items with underlying drop list ref. */\n    _syncItemsWithRef() {\n        this._dropListRef.withItems(this.getSortedItems().map(item => item._dragRef));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDropList, deps: [{ token: i0.ElementRef }, { token: DragDrop }, { token: i0.ChangeDetectorRef }, { token: i1.ScrollDispatcher }, { token: i1$1.Directionality, optional: true }, { token: CDK_DROP_LIST_GROUP, optional: true, skipSelf: true }, { token: CDK_DRAG_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"17.0.4\", type: CdkDropList, isStandalone: true, selector: \"[cdkDropList], cdk-drop-list\", inputs: { connectedTo: [\"cdkDropListConnectedTo\", \"connectedTo\"], data: [\"cdkDropListData\", \"data\"], orientation: [\"cdkDropListOrientation\", \"orientation\"], id: \"id\", lockAxis: [\"cdkDropListLockAxis\", \"lockAxis\"], disabled: [\"cdkDropListDisabled\", \"disabled\", booleanAttribute], sortingDisabled: [\"cdkDropListSortingDisabled\", \"sortingDisabled\", booleanAttribute], enterPredicate: [\"cdkDropListEnterPredicate\", \"enterPredicate\"], sortPredicate: [\"cdkDropListSortPredicate\", \"sortPredicate\"], autoScrollDisabled: [\"cdkDropListAutoScrollDisabled\", \"autoScrollDisabled\", booleanAttribute], autoScrollStep: [\"cdkDropListAutoScrollStep\", \"autoScrollStep\"] }, outputs: { dropped: \"cdkDropListDropped\", entered: \"cdkDropListEntered\", exited: \"cdkDropListExited\", sorted: \"cdkDropListSorted\" }, host: { properties: { \"attr.id\": \"id\", \"class.cdk-drop-list-disabled\": \"disabled\", \"class.cdk-drop-list-dragging\": \"_dropListRef.isDragging()\", \"class.cdk-drop-list-receiving\": \"_dropListRef.isReceiving()\" }, classAttribute: \"cdk-drop-list\" }, providers: [\n            // Prevent child drop lists from picking up the same group as their parent.\n            { provide: CDK_DROP_LIST_GROUP, useValue: undefined },\n            { provide: CDK_DROP_LIST, useExisting: CdkDropList },\n        ], exportAs: [\"cdkDropList\"], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkDropList, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkDropList], cdk-drop-list',\n                    exportAs: 'cdkDropList',\n                    standalone: true,\n                    providers: [\n                        // Prevent child drop lists from picking up the same group as their parent.\n                        { provide: CDK_DROP_LIST_GROUP, useValue: undefined },\n                        { provide: CDK_DROP_LIST, useExisting: CdkDropList },\n                    ],\n                    host: {\n                        'class': 'cdk-drop-list',\n                        '[attr.id]': 'id',\n                        '[class.cdk-drop-list-disabled]': 'disabled',\n                        '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',\n                        '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',\n                    },\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: DragDrop }, { type: i0.ChangeDetectorRef }, { type: i1.ScrollDispatcher }, { type: i1$1.Directionality, decorators: [{\n                    type: Optional\n                }] }, { type: CdkDropListGroup, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [CDK_DROP_LIST_GROUP]\n                }, {\n                    type: SkipSelf\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [CDK_DRAG_CONFIG]\n                }] }], propDecorators: { connectedTo: [{\n                type: Input,\n                args: ['cdkDropListConnectedTo']\n            }], data: [{\n                type: Input,\n                args: ['cdkDropListData']\n            }], orientation: [{\n                type: Input,\n                args: ['cdkDropListOrientation']\n            }], id: [{\n                type: Input\n            }], lockAxis: [{\n                type: Input,\n                args: ['cdkDropListLockAxis']\n            }], disabled: [{\n                type: Input,\n                args: [{ alias: 'cdkDropListDisabled', transform: booleanAttribute }]\n            }], sortingDisabled: [{\n                type: Input,\n                args: [{ alias: 'cdkDropListSortingDisabled', transform: booleanAttribute }]\n            }], enterPredicate: [{\n                type: Input,\n                args: ['cdkDropListEnterPredicate']\n            }], sortPredicate: [{\n                type: Input,\n                args: ['cdkDropListSortPredicate']\n            }], autoScrollDisabled: [{\n                type: Input,\n                args: [{ alias: 'cdkDropListAutoScrollDisabled', transform: booleanAttribute }]\n            }], autoScrollStep: [{\n                type: Input,\n                args: ['cdkDropListAutoScrollStep']\n            }], dropped: [{\n                type: Output,\n                args: ['cdkDropListDropped']\n            }], entered: [{\n                type: Output,\n                args: ['cdkDropListEntered']\n            }], exited: [{\n                type: Output,\n                args: ['cdkDropListExited']\n            }], sorted: [{\n                type: Output,\n                args: ['cdkDropListSorted']\n            }] } });\n\nconst DRAG_DROP_DIRECTIVES = [\n    CdkDropList,\n    CdkDropListGroup,\n    CdkDrag,\n    CdkDragHandle,\n    CdkDragPreview,\n    CdkDragPlaceholder,\n];\nclass DragDropModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: DragDropModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.4\", ngImport: i0, type: DragDropModule, imports: [CdkDropList,\n            CdkDropListGroup,\n            CdkDrag,\n            CdkDragHandle,\n            CdkDragPreview,\n            CdkDragPlaceholder], exports: [CdkScrollableModule, CdkDropList,\n            CdkDropListGroup,\n            CdkDrag,\n            CdkDragHandle,\n            CdkDragPreview,\n            CdkDragPlaceholder] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: DragDropModule, providers: [DragDrop], imports: [CdkScrollableModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: DragDropModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: DRAG_DROP_DIRECTIVES,\n                    exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],\n                    providers: [DragDrop],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CDK_DRAG_CONFIG, CDK_DRAG_HANDLE, CDK_DRAG_PARENT, CDK_DRAG_PLACEHOLDER, CDK_DRAG_PREVIEW, CDK_DROP_LIST, CDK_DROP_LIST_GROUP, CdkDrag, CdkDragHandle, CdkDragPlaceholder, CdkDragPreview, CdkDropList, CdkDropListGroup, DragDrop, DragDropModule, DragDropRegistry, DragRef, DropListRef, copyArrayItem, moveItemInArray, transferArrayItem };\n","import { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { inject, APP_ID, Injectable, Inject, QueryList, booleanAttribute, Directive, Input, InjectionToken, Optional, EventEmitter, Output, NgModule } from '@angular/core';\nimport * as i1 from '@angular/cdk/platform';\nimport { _getFocusedElementPierceShadowDom, normalizePassiveListenerOptions, _getEventTarget, _getShadowRoot } from '@angular/cdk/platform';\nimport { Subject, Subscription, BehaviorSubject, of } from 'rxjs';\nimport { hasModifierKey, A, Z, ZERO, NINE, PAGE_DOWN, PAGE_UP, END, HOME, LEFT_ARROW, RIGHT_ARROW, UP_ARROW, DOWN_ARROW, TAB, ALT, CONTROL, MAC_META, META, SHIFT } from '@angular/cdk/keycodes';\nimport { tap, debounceTime, filter, map, take, skip, distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport * as i1$1 from '@angular/cdk/observers';\nimport { ObserversModule } from '@angular/cdk/observers';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { BreakpointObserver } from '@angular/cdk/layout';\n\n/** IDs are delimited by an empty space, as per the spec. */\nconst ID_DELIMITER = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction addAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    if (ids.some(existingId => existingId.trim() == id.trim())) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMITER));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    const filteredIds = ids.filter(val => val != id.trim());\n    if (filteredIds.length) {\n        el.setAttribute(attr, filteredIds.join(ID_DELIMITER));\n    }\n    else {\n        el.removeAttribute(attr);\n    }\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace delimited) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * ID used for the body container where all messages are appended.\n * @deprecated No longer being used. To be removed.\n * @breaking-change 14.0.0\n */\nconst MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n * @deprecated To be turned into a private variable.\n * @breaking-change 14.0.0\n */\nconst CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n * @deprecated To be turned into a private variable.\n * @breaking-change 14.0.0\n */\nconst CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/** Global incremental identifier for each registered message element. */\nlet nextId = 0;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n */\nclass AriaDescriber {\n    constructor(_document, \n    /**\n     * @deprecated To be turned into a required parameter.\n     * @breaking-change 14.0.0\n     */\n    _platform) {\n        this._platform = _platform;\n        /** Map of all registered message elements that have been placed into the document. */\n        this._messageRegistry = new Map();\n        /** Container for all registered messages. */\n        this._messagesContainer = null;\n        /** Unique ID for the service. */\n        this._id = `${nextId++}`;\n        this._document = _document;\n        this._id = inject(APP_ID) + '-' + nextId++;\n    }\n    describe(hostElement, message, role) {\n        if (!this._canBeDescribed(hostElement, message)) {\n            return;\n        }\n        const key = getKey(message, role);\n        if (typeof message !== 'string') {\n            // We need to ensure that the element has an ID.\n            setMessageId(message, this._id);\n            this._messageRegistry.set(key, { messageElement: message, referenceCount: 0 });\n        }\n        else if (!this._messageRegistry.has(key)) {\n            this._createMessageElement(message, role);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, key)) {\n            this._addMessageReference(hostElement, key);\n        }\n    }\n    removeDescription(hostElement, message, role) {\n        if (!message || !this._isElementNode(hostElement)) {\n            return;\n        }\n        const key = getKey(message, role);\n        if (this._isElementDescribedByMessage(hostElement, key)) {\n            this._removeMessageReference(hostElement, key);\n        }\n        // If the message is a string, it means that it's one that we created for the\n        // consumer so we can remove it safely, otherwise we should leave it in place.\n        if (typeof message === 'string') {\n            const registeredMessage = this._messageRegistry.get(key);\n            if (registeredMessage && registeredMessage.referenceCount === 0) {\n                this._deleteMessageElement(key);\n            }\n        }\n        if (this._messagesContainer?.childNodes.length === 0) {\n            this._messagesContainer.remove();\n            this._messagesContainer = null;\n        }\n    }\n    /** Unregisters all created message elements and removes the message container. */\n    ngOnDestroy() {\n        const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}=\"${this._id}\"]`);\n        for (let i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        this._messagesContainer?.remove();\n        this._messagesContainer = null;\n        this._messageRegistry.clear();\n    }\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     */\n    _createMessageElement(message, role) {\n        const messageElement = this._document.createElement('div');\n        setMessageId(messageElement, this._id);\n        messageElement.textContent = message;\n        if (role) {\n            messageElement.setAttribute('role', role);\n        }\n        this._createMessagesContainer();\n        this._messagesContainer.appendChild(messageElement);\n        this._messageRegistry.set(getKey(message, role), { messageElement, referenceCount: 0 });\n    }\n    /** Deletes the message element from the global messages container. */\n    _deleteMessageElement(key) {\n        this._messageRegistry.get(key)?.messageElement?.remove();\n        this._messageRegistry.delete(key);\n    }\n    /** Creates the global container for all aria-describedby messages. */\n    _createMessagesContainer() {\n        if (this._messagesContainer) {\n            return;\n        }\n        const containerClassName = 'cdk-describedby-message-container';\n        const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform=\"server\"]`);\n        for (let i = 0; i < serverContainers.length; i++) {\n            // When going from the server to the client, we may end up in a situation where there's\n            // already a container on the page, but we don't have a reference to it. Clear the\n            // old container so we don't get duplicates. Doing this, instead of emptying the previous\n            // container, should be slightly faster.\n            serverContainers[i].remove();\n        }\n        const messagesContainer = this._document.createElement('div');\n        // We add `visibility: hidden` in order to prevent text in this container from\n        // being searchable by the browser's Ctrl + F functionality.\n        // Screen-readers will still read the description for elements with aria-describedby even\n        // when the description element is not visible.\n        messagesContainer.style.visibility = 'hidden';\n        // Even though we use `visibility: hidden`, we still apply `cdk-visually-hidden` so that\n        // the description element doesn't impact page layout.\n        messagesContainer.classList.add(containerClassName);\n        messagesContainer.classList.add('cdk-visually-hidden');\n        // @breaking-change 14.0.0 Remove null check for `_platform`.\n        if (this._platform && !this._platform.isBrowser) {\n            messagesContainer.setAttribute('platform', 'server');\n        }\n        this._document.body.appendChild(messagesContainer);\n        this._messagesContainer = messagesContainer;\n    }\n    /** Removes all cdk-describedby messages that are hosted through the element. */\n    _removeCdkDescribedByReferenceIds(element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        const originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby').filter(id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    }\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     */\n    _addMessageReference(element, key) {\n        const registeredMessage = this._messageRegistry.get(key);\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);\n        registeredMessage.referenceCount++;\n    }\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     */\n    _removeMessageReference(element, key) {\n        const registeredMessage = this._messageRegistry.get(key);\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    }\n    /** Returns true if the element has been described by the provided message ID. */\n    _isElementDescribedByMessage(element, key) {\n        const referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        const registeredMessage = this._messageRegistry.get(key);\n        const messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    }\n    /** Determines whether a message can be described on a particular element. */\n    _canBeDescribed(element, message) {\n        if (!this._isElementNode(element)) {\n            return false;\n        }\n        if (message && typeof message === 'object') {\n            // We'd have to make some assumptions about the description element's text, if the consumer\n            // passed in an element. Assume that if an element is passed in, the consumer has verified\n            // that it can be used as a description.\n            return true;\n        }\n        const trimmedMessage = message == null ? '' : `${message}`.trim();\n        const ariaLabel = element.getAttribute('aria-label');\n        // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\n        // element, because screen readers will end up reading out the same text twice in a row.\n        return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;\n    }\n    /** Checks whether a node is an Element node. */\n    _isElementNode(element) {\n        return element.nodeType === this._document.ELEMENT_NODE;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: AriaDescriber, deps: [{ token: DOCUMENT }, { token: i1.Platform }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: AriaDescriber, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: AriaDescriber, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i1.Platform }] });\n/** Gets a key that can be used to look messages up in the registry. */\nfunction getKey(message, role) {\n    return typeof message === 'string' ? `${role || ''}/${message}` : message;\n}\n/** Assigns a unique ID to an element, if it doesn't have one already. */\nfunction setMessageId(element, serviceId) {\n    if (!element.id) {\n        element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;\n    }\n}\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass ListKeyManager {\n    constructor(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._activeItem = null;\n        this._wrap = false;\n        this._letterKeyStream = new Subject();\n        this._typeaheadSubscription = Subscription.EMPTY;\n        this._vertical = true;\n        this._allowedModifierKeys = [];\n        this._homeAndEnd = false;\n        this._pageUpAndDown = { enabled: false, delta: 10 };\n        /**\n         * Predicate function that can be used to check whether an item should be skipped\n         * by the key manager. By default, disabled items are skipped.\n         */\n        this._skipPredicateFn = (item) => item.disabled;\n        // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject();\n        /** Stream that emits whenever the active item of the list manager changes. */\n        this.change = new Subject();\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof QueryList) {\n            this._itemChangesSubscription = _items.changes.subscribe((newItems) => {\n                if (this._activeItem) {\n                    const itemArray = newItems.toArray();\n                    const newIndex = itemArray.indexOf(this._activeItem);\n                    if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n                        this._activeItemIndex = newIndex;\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    skipPredicate(predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    }\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    withWrap(shouldWrap = true) {\n        this._wrap = shouldWrap;\n        return this;\n    }\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled = true) {\n        this._vertical = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction) {\n        this._horizontal = direction;\n        return this;\n    }\n    /**\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n     */\n    withAllowedModifierKeys(keys) {\n        this._allowedModifierKeys = keys;\n        return this;\n    }\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval = 200) {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n            this._items.length &&\n            this._items.some(item => typeof item.getLabel !== 'function')) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream\n            .pipe(tap(letter => this._pressedLetters.push(letter)), debounceTime(debounceInterval), filter(() => this._pressedLetters.length > 0), map(() => this._pressedLetters.join('')))\n            .subscribe(inputString => {\n            const items = this._getItemsArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (let i = 1; i < items.length + 1; i++) {\n                const index = (this._activeItemIndex + i) % items.length;\n                const item = items[index];\n                if (!this._skipPredicateFn(item) &&\n                    item.getLabel().toUpperCase().trim().indexOf(inputString) === 0) {\n                    this.setActiveItem(index);\n                    break;\n                }\n            }\n            this._pressedLetters = [];\n        });\n        return this;\n    }\n    /** Cancels the current typeahead sequence. */\n    cancelTypeahead() {\n        this._pressedLetters = [];\n        return this;\n    }\n    /**\n     * Configures the key manager to activate the first and last items\n     * respectively when the Home or End key is pressed.\n     * @param enabled Whether pressing the Home or End key activates the first/last item.\n     */\n    withHomeAndEnd(enabled = true) {\n        this._homeAndEnd = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n     * respectively when the Page-Up or Page-Down key is pressed.\n     * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n     * @param delta Whether pressing the Home or End key activates the first/last item.\n     */\n    withPageUpDown(enabled = true, delta = 10) {\n        this._pageUpAndDown = { enabled, delta };\n        return this;\n    }\n    setActiveItem(item) {\n        const previousActiveItem = this._activeItem;\n        this.updateActiveItem(item);\n        if (this._activeItem !== previousActiveItem) {\n            this.change.next(this._activeItemIndex);\n        }\n    }\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event) {\n        const keyCode = event.keyCode;\n        const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n        const isModifierAllowed = modifiers.every(modifier => {\n            return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n        });\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case HOME:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setFirstItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case END:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setLastItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case PAGE_UP:\n                if (this._pageUpAndDown.enabled && isModifierAllowed) {\n                    const targetIndex = this._activeItemIndex - this._pageUpAndDown.delta;\n                    this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n                    break;\n                }\n                else {\n                    return;\n                }\n            case PAGE_DOWN:\n                if (this._pageUpAndDown.enabled && isModifierAllowed) {\n                    const targetIndex = this._activeItemIndex + this._pageUpAndDown.delta;\n                    const itemsLength = this._getItemsArray().length;\n                    this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n                    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                    // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                    if (event.key && event.key.length === 1) {\n                        this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                    }\n                    else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                        this._letterKeyStream.next(String.fromCharCode(keyCode));\n                    }\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    }\n    /** Index of the currently active item. */\n    get activeItemIndex() {\n        return this._activeItemIndex;\n    }\n    /** The active item. */\n    get activeItem() {\n        return this._activeItem;\n    }\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping() {\n        return this._pressedLetters.length > 0;\n    }\n    /** Sets the active item to the first enabled item in the list. */\n    setFirstItemActive() {\n        this._setActiveItemByIndex(0, 1);\n    }\n    /** Sets the active item to the last enabled item in the list. */\n    setLastItemActive() {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    }\n    /** Sets the active item to the next enabled item in the list. */\n    setNextItemActive() {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    }\n    /** Sets the active item to a previous enabled item in the list. */\n    setPreviousItemActive() {\n        this._activeItemIndex < 0 && this._wrap\n            ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    }\n    updateActiveItem(item) {\n        const itemArray = this._getItemsArray();\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n        const activeItem = itemArray[index];\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\n        this._activeItem = activeItem == null ? null : activeItem;\n        this._activeItemIndex = index;\n    }\n    /** Cleans up the key manager. */\n    destroy() {\n        this._typeaheadSubscription.unsubscribe();\n        this._itemChangesSubscription?.unsubscribe();\n        this._letterKeyStream.complete();\n        this.tabOut.complete();\n        this.change.complete();\n        this._pressedLetters = [];\n    }\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    _setActiveItemByDelta(delta) {\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n    }\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    _setActiveInWrapMode(delta) {\n        const items = this._getItemsArray();\n        for (let i = 1; i <= items.length; i++) {\n            const index = (this._activeItemIndex + delta * i + items.length) % items.length;\n            const item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    }\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    _setActiveInDefaultMode(delta) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n    }\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    _setActiveItemByIndex(index, fallbackDelta) {\n        const items = this._getItemsArray();\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    }\n    /** Returns the items as an array. */\n    _getItemsArray() {\n        return this._items instanceof QueryList ? this._items.toArray() : this._items;\n    }\n}\n\nclass ActiveDescendantKeyManager extends ListKeyManager {\n    setActiveItem(index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        super.setActiveItem(index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    }\n}\n\nclass FocusKeyManager extends ListKeyManager {\n    constructor() {\n        super(...arguments);\n        this._origin = 'program';\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    setFocusOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    setActiveItem(item) {\n        super.setActiveItem(item);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    }\n}\n\n/**\n * Configuration for the isFocusable method.\n */\nclass IsFocusableConfig {\n    constructor() {\n        /**\n         * Whether to count an element as focusable even if it is not currently visible.\n         */\n        this.ignoreVisibility = false;\n    }\n}\n// The InteractivityChecker leans heavily on the ally.js accessibility utilities.\n// Methods like `isTabbable` are only covering specific edge-cases for the browsers which are\n// supported.\n/**\n * Utility for checking the interactivity of an element, such as whether it is focusable or\n * tabbable.\n */\nclass InteractivityChecker {\n    constructor(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    isDisabled(element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    }\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    isVisible(element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    }\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    isTabbable(element) {\n        // Nothing is tabbable on the server 😎\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        const frameElement = getFrameElement(getWindow(element));\n        if (frameElement) {\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Browsers disable tabbing to an element inside of an invisible frame.\n            if (!this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        let nodeName = element.nodeName.toLowerCase();\n        let tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe' || nodeName === 'object') {\n            // The frame or object's content may be tabbable depending on the content, but it's\n            // not possibly to reliably detect the content of the frames. We always consider such\n            // elements as non-tabbable.\n            return false;\n        }\n        // In iOS, the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        if (nodeName === 'audio') {\n            // Audio elements without controls enabled are never tabbable, regardless\n            // of the tabindex attribute explicitly being set.\n            if (!element.hasAttribute('controls')) {\n                return false;\n            }\n            // Audio elements with controls are by default tabbable unless the\n            // tabindex attribute is set to `-1` explicitly.\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'video') {\n            // For all video elements, if the tabindex attribute is set to `-1`, the video\n            // is not tabbable. Note: We cannot rely on the default `HTMLElement.tabIndex`\n            // property as that one is set to `-1` in Chrome, Edge and Safari v13.1. The\n            // tabindex attribute is the source of truth here.\n            if (tabIndexValue === -1) {\n                return false;\n            }\n            // If the tabindex is explicitly set, and not `-1` (as per check before), the\n            // video element is always tabbable (regardless of whether it has controls or not).\n            if (tabIndexValue !== null) {\n                return true;\n            }\n            // Otherwise (when no explicit tabindex is set), a video is only tabbable if it\n            // has controls enabled. Firefox is special as videos are always tabbable regardless\n            // of whether there are controls or not.\n            return this._platform.FIREFOX || element.hasAttribute('controls');\n        }\n        return element.tabIndex >= 0;\n    }\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @param config The config object with options to customize this method's behavior\n     * @returns Whether the element is focusable.\n     */\n    isFocusable(element, config) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return (isPotentiallyFocusable(element) &&\n            !this.isDisabled(element) &&\n            (config?.ignoreVisibility || this.isVisible(element)));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: InteractivityChecker, deps: [{ token: i1.Platform }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: InteractivityChecker, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: InteractivityChecker, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.Platform }] });\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n */\nfunction getFrameElement(window) {\n    try {\n        return window.frameElement;\n    }\n    catch {\n        return null;\n    }\n}\n/** Checks whether the specified element has any geometry / rectangles. */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth ||\n        element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/** Gets whether an element's  */\nfunction isNativeFormElement(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    return (nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea');\n}\n/** Gets whether an element is an `<input type=\"hidden\">`. */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/** Gets whether an element is an anchor that has an href attribute. */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/** Gets whether an element is an input element. */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/** Gets whether an element is an anchor element. */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/** Gets whether an element has a valid tabindex. */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    let tabIndex = element.getAttribute('tabindex');\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    const tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/** Checks whether the specified element is potentially tabbable on iOS */\nfunction isPotentiallyTabbableIOS(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    let inputType = nodeName === 'input' && element.type;\n    return (inputType === 'text' ||\n        inputType === 'password' ||\n        nodeName === 'select' ||\n        nodeName === 'textarea');\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return (isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element));\n}\n/** Gets the parent window of a DOM node with regards of being inside of an iframe. */\nfunction getWindow(node) {\n    // ownerDocument is null if `node` itself *is* a document.\n    return (node.ownerDocument && node.ownerDocument.defaultView) || window;\n}\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause the two to be misaligned.\n *\n * @deprecated Use `ConfigurableFocusTrap` instead.\n * @breaking-change 11.0.0\n */\nclass FocusTrap {\n    /** Whether the focus trap is active. */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(value, this._startAnchor);\n            this._toggleAnchorTabIndex(value, this._endAnchor);\n        }\n    }\n    constructor(_element, _checker, _ngZone, _document, deferAnchors = false) {\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._hasAttached = false;\n        // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n        this.startAnchorListener = () => this.focusLastTabbableElement();\n        this.endAnchorListener = () => this.focusFirstTabbableElement();\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    /** Destroys the focus trap by cleaning up the anchors. */\n    destroy() {\n        const startAnchor = this._startAnchor;\n        const endAnchor = this._endAnchor;\n        if (startAnchor) {\n            startAnchor.removeEventListener('focus', this.startAnchorListener);\n            startAnchor.remove();\n        }\n        if (endAnchor) {\n            endAnchor.removeEventListener('focus', this.endAnchorListener);\n            endAnchor.remove();\n        }\n        this._startAnchor = this._endAnchor = null;\n        this._hasAttached = false;\n    }\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfully. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    attachAnchors() {\n        // If we're not on the browser, there can be no focus to trap.\n        if (this._hasAttached) {\n            return true;\n        }\n        this._ngZone.runOutsideAngular(() => {\n            if (!this._startAnchor) {\n                this._startAnchor = this._createAnchor();\n                this._startAnchor.addEventListener('focus', this.startAnchorListener);\n            }\n            if (!this._endAnchor) {\n                this._endAnchor = this._createAnchor();\n                this._endAnchor.addEventListener('focus', this.endAnchorListener);\n            }\n        });\n        if (this._element.parentNode) {\n            this._element.parentNode.insertBefore(this._startAnchor, this._element);\n            this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);\n            this._hasAttached = true;\n        }\n        return this._hasAttached;\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusInitialElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusInitialElement(options)));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusFirstTabbableElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusLastTabbableElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));\n        });\n    }\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param bound The boundary to get (start or end of trapped region).\n     * @returns The boundary element.\n     */\n    _getRegionBoundary(bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` + `[cdkFocusRegion${bound}], ` + `[cdk-focus-${bound}]`);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            for (let i = 0; i < markers.length; i++) {\n                // @breaking-change 8.0.0\n                if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\n                    console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', ` +\n                        `use 'cdkFocusRegion${bound}' instead. The deprecated ` +\n                        `attribute will be removed in 8.0.0.`, markers[i]);\n                }\n                else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {\n                    console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', ` +\n                        `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` +\n                        `will be removed in 8.0.0.`, markers[i]);\n                }\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length\n            ? markers[markers.length - 1]\n            : this._getLastTabbableElement(this._element);\n    }\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfully.\n     */\n    focusInitialElement(options) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const redirectToElement = this._element.querySelector(`[cdk-focus-initial], ` + `[cdkFocusInitial]`);\n        if (redirectToElement) {\n            // @breaking-change 8.0.0\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                redirectToElement.hasAttribute(`cdk-focus-initial`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-initial', ` +\n                    `use 'cdkFocusInitial' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0`, redirectToElement);\n            }\n            // Warn the consumer if the element they've pointed to\n            // isn't focusable, when not in production mode.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                !this._checker.isFocusable(redirectToElement)) {\n                console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);\n            }\n            if (!this._checker.isFocusable(redirectToElement)) {\n                const focusableChild = this._getFirstTabbableElement(redirectToElement);\n                focusableChild?.focus(options);\n                return !!focusableChild;\n            }\n            redirectToElement.focus(options);\n            return true;\n        }\n        return this.focusFirstTabbableElement(options);\n    }\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusFirstTabbableElement(options) {\n        const redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus(options);\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusLastTabbableElement(options) {\n        const redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus(options);\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Checks whether the focus trap has successfully been attached.\n     */\n    hasAttached() {\n        return this._hasAttached;\n    }\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    _getFirstTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        const children = root.children;\n        for (let i = 0; i < children.length; i++) {\n            const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE\n                ? this._getFirstTabbableElement(children[i])\n                : null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\n    _getLastTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        const children = root.children;\n        for (let i = children.length - 1; i >= 0; i--) {\n            const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE\n                ? this._getLastTabbableElement(children[i])\n                : null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Creates an anchor element. */\n    _createAnchor() {\n        const anchor = this._document.createElement('div');\n        this._toggleAnchorTabIndex(this._enabled, anchor);\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        anchor.setAttribute('aria-hidden', 'true');\n        return anchor;\n    }\n    /**\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n     * @param isEnabled Whether the focus trap is enabled.\n     * @param anchor Anchor on which to toggle the tabindex.\n     */\n    _toggleAnchorTabIndex(isEnabled, anchor) {\n        // Remove the tabindex completely, rather than setting it to -1, because if the\n        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n        isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n    }\n    /**\n     * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.\n     * @param enabled: Whether the anchors should trap Tab.\n     */\n    toggleAnchors(enabled) {\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(enabled, this._startAnchor);\n            this._toggleAnchorTabIndex(enabled, this._endAnchor);\n        }\n    }\n    /** Executes a function when the zone is stable. */\n    _executeOnStable(fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.pipe(take(1)).subscribe(fn);\n        }\n    }\n}\n/**\n * Factory that allows easy instantiation of focus traps.\n * @deprecated Use `ConfigurableFocusTrapFactory` instead.\n * @breaking-change 11.0.0\n */\nclass FocusTrapFactory {\n    constructor(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    create(element, deferCaptureElements = false) {\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: FocusTrapFactory, deps: [{ token: InteractivityChecker }, { token: i0.NgZone }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: FocusTrapFactory, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: FocusTrapFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: InteractivityChecker }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n/** Directive for trapping focus within a region. */\nclass CdkTrapFocus {\n    /** Whether the focus trap is active. */\n    get enabled() {\n        return this.focusTrap.enabled;\n    }\n    set enabled(value) {\n        this.focusTrap.enabled = value;\n    }\n    constructor(_elementRef, _focusTrapFactory, \n    /**\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 13.0.0\n     */\n    _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n        this._previouslyFocusedElement = null;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    ngOnDestroy() {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    }\n    ngAfterContentInit() {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._captureFocus();\n        }\n    }\n    ngDoCheck() {\n        if (!this.focusTrap.hasAttached()) {\n            this.focusTrap.attachAnchors();\n        }\n    }\n    ngOnChanges(changes) {\n        const autoCaptureChange = changes['autoCapture'];\n        if (autoCaptureChange &&\n            !autoCaptureChange.firstChange &&\n            this.autoCapture &&\n            this.focusTrap.hasAttached()) {\n            this._captureFocus();\n        }\n    }\n    _captureFocus() {\n        this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();\n        this.focusTrap.focusInitialElementWhenReady();\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkTrapFocus, deps: [{ token: i0.ElementRef }, { token: FocusTrapFactory }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"17.0.4\", type: CdkTrapFocus, selector: \"[cdkTrapFocus]\", inputs: { enabled: [\"cdkTrapFocus\", \"enabled\", booleanAttribute], autoCapture: [\"cdkTrapFocusAutoCapture\", \"autoCapture\", booleanAttribute] }, exportAs: [\"cdkTrapFocus\"], usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkTrapFocus, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: FocusTrapFactory }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }], propDecorators: { enabled: [{\n                type: Input,\n                args: [{ alias: 'cdkTrapFocus', transform: booleanAttribute }]\n            }], autoCapture: [{\n                type: Input,\n                args: [{ alias: 'cdkTrapFocusAutoCapture', transform: booleanAttribute }]\n            }] } });\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class uses a strategy pattern that determines how it traps focus.\n * See FocusTrapInertStrategy.\n */\nclass ConfigurableFocusTrap extends FocusTrap {\n    /** Whether the FocusTrap is enabled. */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._enabled) {\n            this._focusTrapManager.register(this);\n        }\n        else {\n            this._focusTrapManager.deregister(this);\n        }\n    }\n    constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config) {\n        super(_element, _checker, _ngZone, _document, config.defer);\n        this._focusTrapManager = _focusTrapManager;\n        this._inertStrategy = _inertStrategy;\n        this._focusTrapManager.register(this);\n    }\n    /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */\n    destroy() {\n        this._focusTrapManager.deregister(this);\n        super.destroy();\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _enable() {\n        this._inertStrategy.preventFocus(this);\n        this.toggleAnchors(true);\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _disable() {\n        this._inertStrategy.allowFocus(this);\n        this.toggleAnchors(false);\n    }\n}\n\n/** The injection token used to specify the inert strategy. */\nconst FOCUS_TRAP_INERT_STRATEGY = new InjectionToken('FOCUS_TRAP_INERT_STRATEGY');\n\n/**\n * Lightweight FocusTrapInertStrategy that adds a document focus event\n * listener to redirect focus back inside the FocusTrap.\n */\nclass EventListenerFocusTrapInertStrategy {\n    constructor() {\n        /** Focus event handler. */\n        this._listener = null;\n    }\n    /** Adds a document event listener that keeps focus inside the FocusTrap. */\n    preventFocus(focusTrap) {\n        // Ensure there's only one listener per document\n        if (this._listener) {\n            focusTrap._document.removeEventListener('focus', this._listener, true);\n        }\n        this._listener = (e) => this._trapFocus(focusTrap, e);\n        focusTrap._ngZone.runOutsideAngular(() => {\n            focusTrap._document.addEventListener('focus', this._listener, true);\n        });\n    }\n    /** Removes the event listener added in preventFocus. */\n    allowFocus(focusTrap) {\n        if (!this._listener) {\n            return;\n        }\n        focusTrap._document.removeEventListener('focus', this._listener, true);\n        this._listener = null;\n    }\n    /**\n     * Refocuses the first element in the FocusTrap if the focus event target was outside\n     * the FocusTrap.\n     *\n     * This is an event listener callback. The event listener is added in runOutsideAngular,\n     * so all this code runs outside Angular as well.\n     */\n    _trapFocus(focusTrap, event) {\n        const target = event.target;\n        const focusTrapRoot = focusTrap._element;\n        // Don't refocus if target was in an overlay, because the overlay might be associated\n        // with an element inside the FocusTrap, ex. mat-select.\n        if (target && !focusTrapRoot.contains(target) && !target.closest?.('div.cdk-overlay-pane')) {\n            // Some legacy FocusTrap usages have logic that focuses some element on the page\n            // just before FocusTrap is destroyed. For backwards compatibility, wait\n            // to be sure FocusTrap is still enabled before refocusing.\n            setTimeout(() => {\n                // Check whether focus wasn't put back into the focus trap while the timeout was pending.\n                if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {\n                    focusTrap.focusFirstTabbableElement();\n                }\n            });\n        }\n    }\n}\n\n/** Injectable that ensures only the most recently enabled FocusTrap is active. */\nclass FocusTrapManager {\n    constructor() {\n        // A stack of the FocusTraps on the page. Only the FocusTrap at the\n        // top of the stack is active.\n        this._focusTrapStack = [];\n    }\n    /**\n     * Disables the FocusTrap at the top of the stack, and then pushes\n     * the new FocusTrap onto the stack.\n     */\n    register(focusTrap) {\n        // Dedupe focusTraps that register multiple times.\n        this._focusTrapStack = this._focusTrapStack.filter(ft => ft !== focusTrap);\n        let stack = this._focusTrapStack;\n        if (stack.length) {\n            stack[stack.length - 1]._disable();\n        }\n        stack.push(focusTrap);\n        focusTrap._enable();\n    }\n    /**\n     * Removes the FocusTrap from the stack, and activates the\n     * FocusTrap that is the new top of the stack.\n     */\n    deregister(focusTrap) {\n        focusTrap._disable();\n        const stack = this._focusTrapStack;\n        const i = stack.indexOf(focusTrap);\n        if (i !== -1) {\n            stack.splice(i, 1);\n            if (stack.length) {\n                stack[stack.length - 1]._enable();\n            }\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: FocusTrapManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: FocusTrapManager, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: FocusTrapManager, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/** Factory that allows easy instantiation of configurable focus traps. */\nclass ConfigurableFocusTrapFactory {\n    constructor(_checker, _ngZone, _focusTrapManager, _document, _inertStrategy) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._focusTrapManager = _focusTrapManager;\n        this._document = _document;\n        // TODO split up the strategies into different modules, similar to DateAdapter.\n        this._inertStrategy = _inertStrategy || new EventListenerFocusTrapInertStrategy();\n    }\n    create(element, config = { defer: false }) {\n        let configObject;\n        if (typeof config === 'boolean') {\n            configObject = { defer: config };\n        }\n        else {\n            configObject = config;\n        }\n        return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ConfigurableFocusTrapFactory, deps: [{ token: InteractivityChecker }, { token: i0.NgZone }, { token: FocusTrapManager }, { token: DOCUMENT }, { token: FOCUS_TRAP_INERT_STRATEGY, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ConfigurableFocusTrapFactory, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: ConfigurableFocusTrapFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: InteractivityChecker }, { type: i0.NgZone }, { type: FocusTrapManager }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [FOCUS_TRAP_INERT_STRATEGY]\n                }] }] });\n\n/** Gets whether an event could be a faked `mousedown` event dispatched by a screen reader. */\nfunction isFakeMousedownFromScreenReader(event) {\n    // Some screen readers will dispatch a fake `mousedown` event when pressing enter or space on\n    // a clickable element. We can distinguish these events when `event.buttons` is zero, or\n    // `event.detail` is zero depending on the browser:\n    // - `event.buttons` works on Firefox, but fails on Chrome.\n    // - `detail` works on Chrome, but fails on Firefox.\n    return event.buttons === 0 || event.detail === 0;\n}\n/** Gets whether an event could be a faked `touchstart` event dispatched by a screen reader. */\nfunction isFakeTouchstartFromScreenReader(event) {\n    const touch = (event.touches && event.touches[0]) || (event.changedTouches && event.changedTouches[0]);\n    // A fake `touchstart` can be distinguished from a real one by looking at the `identifier`\n    // which is typically >= 0 on a real device versus -1 from a screen reader. Just to be safe,\n    // we can also look at `radiusX` and `radiusY`. This behavior was observed against a Windows 10\n    // device with a touch screen running NVDA v2020.4 and Firefox 85 or Chrome 88.\n    return (!!touch &&\n        touch.identifier === -1 &&\n        (touch.radiusX == null || touch.radiusX === 1) &&\n        (touch.radiusY == null || touch.radiusY === 1));\n}\n\n/**\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\n * options.\n */\nconst INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken('cdk-input-modality-detector-options');\n/**\n * Default options for the InputModalityDetector.\n *\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\n * keyboard input modality) for two reasons:\n *\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\n *    in new tab', and are thus less representative of actual keyboard interaction.\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\n *    these keys so as to not update the input modality.\n *\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\n * distinguish between the two.\n */\nconst INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {\n    ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT],\n};\n/**\n * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown\n * event to be attributed as mouse and not touch.\n *\n * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n * that a value of around 650ms seems appropriate.\n */\nconst TOUCH_BUFFER_MS = 650;\n/**\n * Event listener options that enable capturing and also mark the listener as passive if the browser\n * supports it.\n */\nconst modalityEventListenerOptions = normalizePassiveListenerOptions({\n    passive: true,\n    capture: true,\n});\n/**\n * Service that detects the user's input modality.\n *\n * This service does not update the input modality when a user navigates with a screen reader\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\n * input interaction.\n *\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\n * update the input modality to keyboard, but in general this service's behavior is largely\n * undefined.\n */\nclass InputModalityDetector {\n    /** The most recently detected input modality. */\n    get mostRecentModality() {\n        return this._modality.value;\n    }\n    constructor(_platform, ngZone, document, options) {\n        this._platform = _platform;\n        /**\n         * The most recently detected input modality event target. Is null if no input modality has been\n         * detected or if the associated event target is null for some unknown reason.\n         */\n        this._mostRecentTarget = null;\n        /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\n        this._modality = new BehaviorSubject(null);\n        /**\n         * The timestamp of the last touch input modality. Used to determine whether mousedown events\n         * should be attributed to mouse or touch.\n         */\n        this._lastTouchMs = 0;\n        /**\n         * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\n         * bound.\n         */\n        this._onKeydown = (event) => {\n            // If this is one of the keys we should ignore, then ignore it and don't update the input\n            // modality to keyboard.\n            if (this._options?.ignoreKeys?.some(keyCode => keyCode === event.keyCode)) {\n                return;\n            }\n            this._modality.next('keyboard');\n            this._mostRecentTarget = _getEventTarget(event);\n        };\n        /**\n         * Handles mousedown events. Must be an arrow function in order to preserve the context when it\n         * gets bound.\n         */\n        this._onMousedown = (event) => {\n            // Touches trigger both touch and mouse events, so we need to distinguish between mouse events\n            // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely\n            // after the previous touch event.\n            if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {\n                return;\n            }\n            // Fake mousedown events are fired by some screen readers when controls are activated by the\n            // screen reader. Attribute them to keyboard input modality.\n            this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');\n            this._mostRecentTarget = _getEventTarget(event);\n        };\n        /**\n         * Handles touchstart events. Must be an arrow function in order to preserve the context when it\n         * gets bound.\n         */\n        this._onTouchstart = (event) => {\n            // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart\n            // events are fired. Again, attribute to keyboard input modality.\n            if (isFakeTouchstartFromScreenReader(event)) {\n                this._modality.next('keyboard');\n                return;\n            }\n            // Store the timestamp of this touch event, as it's used to distinguish between mouse events\n            // triggered via mouse vs touch.\n            this._lastTouchMs = Date.now();\n            this._modality.next('touch');\n            this._mostRecentTarget = _getEventTarget(event);\n        };\n        this._options = {\n            ...INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS,\n            ...options,\n        };\n        // Skip the first emission as it's null.\n        this.modalityDetected = this._modality.pipe(skip(1));\n        this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());\n        // If we're not in a browser, this service should do nothing, as there's no relevant input\n        // modality to detect.\n        if (_platform.isBrowser) {\n            ngZone.runOutsideAngular(() => {\n                document.addEventListener('keydown', this._onKeydown, modalityEventListenerOptions);\n                document.addEventListener('mousedown', this._onMousedown, modalityEventListenerOptions);\n                document.addEventListener('touchstart', this._onTouchstart, modalityEventListenerOptions);\n            });\n        }\n    }\n    ngOnDestroy() {\n        this._modality.complete();\n        if (this._platform.isBrowser) {\n            document.removeEventListener('keydown', this._onKeydown, modalityEventListenerOptions);\n            document.removeEventListener('mousedown', this._onMousedown, modalityEventListenerOptions);\n            document.removeEventListener('touchstart', this._onTouchstart, modalityEventListenerOptions);\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: InputModalityDetector, deps: [{ token: i1.Platform }, { token: i0.NgZone }, { token: DOCUMENT }, { token: INPUT_MODALITY_DETECTOR_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: InputModalityDetector, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: InputModalityDetector, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.Platform }, { type: i0.NgZone }, { type: Document, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [INPUT_MODALITY_DETECTOR_OPTIONS]\n                }] }] });\n\nconst LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement', {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n});\n/** @docs-private */\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n    return null;\n}\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nconst LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\n\nlet uniqueIds = 0;\nclass LiveAnnouncer {\n    constructor(elementToken, _ngZone, _document, _defaultOptions) {\n        this._ngZone = _ngZone;\n        this._defaultOptions = _defaultOptions;\n        // We inject the live element and document as `any` because the constructor signature cannot\n        // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n        // a class decorator causes TypeScript to preserve the constructor signature types.\n        this._document = _document;\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    announce(message, ...args) {\n        const defaultOptions = this._defaultOptions;\n        let politeness;\n        let duration;\n        if (args.length === 1 && typeof args[0] === 'number') {\n            duration = args[0];\n        }\n        else {\n            [politeness, duration] = args;\n        }\n        this.clear();\n        clearTimeout(this._previousTimeout);\n        if (!politeness) {\n            politeness =\n                defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : 'polite';\n        }\n        if (duration == null && defaultOptions) {\n            duration = defaultOptions.duration;\n        }\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        if (this._liveElement.id) {\n            this._exposeAnnouncerToModals(this._liveElement.id);\n        }\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        return this._ngZone.runOutsideAngular(() => {\n            if (!this._currentPromise) {\n                this._currentPromise = new Promise(resolve => (this._currentResolve = resolve));\n            }\n            clearTimeout(this._previousTimeout);\n            this._previousTimeout = setTimeout(() => {\n                this._liveElement.textContent = message;\n                if (typeof duration === 'number') {\n                    this._previousTimeout = setTimeout(() => this.clear(), duration);\n                }\n                this._currentResolve();\n                this._currentPromise = this._currentResolve = undefined;\n            }, 100);\n            return this._currentPromise;\n        });\n    }\n    /**\n     * Clears the current text from the announcer element. Can be used to prevent\n     * screen readers from reading the text out again while the user is going\n     * through the page landmarks.\n     */\n    clear() {\n        if (this._liveElement) {\n            this._liveElement.textContent = '';\n        }\n    }\n    ngOnDestroy() {\n        clearTimeout(this._previousTimeout);\n        this._liveElement?.remove();\n        this._liveElement = null;\n        this._currentResolve?.();\n        this._currentPromise = this._currentResolve = undefined;\n    }\n    _createLiveElement() {\n        const elementClass = 'cdk-live-announcer-element';\n        const previousElements = this._document.getElementsByClassName(elementClass);\n        const liveEl = this._document.createElement('div');\n        // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n        for (let i = 0; i < previousElements.length; i++) {\n            previousElements[i].remove();\n        }\n        liveEl.classList.add(elementClass);\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        liveEl.id = `cdk-live-announcer-${uniqueIds++}`;\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    }\n    /**\n     * Some browsers won't expose the accessibility node of the live announcer element if there is an\n     * `aria-modal` and the live announcer is outside of it. This method works around the issue by\n     * pointing the `aria-owns` of all modals to the live announcer element.\n     */\n    _exposeAnnouncerToModals(id) {\n        // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n        // the `SnakBarContainer` and other usages.\n        //\n        // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n        // section of the DOM we need to look through. This should cover all the cases we support, but\n        // the selector can be expanded if it turns out to be too narrow.\n        const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal=\"true\"]');\n        for (let i = 0; i < modals.length; i++) {\n            const modal = modals[i];\n            const ariaOwns = modal.getAttribute('aria-owns');\n            if (!ariaOwns) {\n                modal.setAttribute('aria-owns', id);\n            }\n            else if (ariaOwns.indexOf(id) === -1) {\n                modal.setAttribute('aria-owns', ariaOwns + ' ' + id);\n            }\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: LiveAnnouncer, deps: [{ token: LIVE_ANNOUNCER_ELEMENT_TOKEN, optional: true }, { token: i0.NgZone }, { token: DOCUMENT }, { token: LIVE_ANNOUNCER_DEFAULT_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: LiveAnnouncer, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: LiveAnnouncer, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [LIVE_ANNOUNCER_ELEMENT_TOKEN]\n                }] }, { type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS]\n                }] }] });\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\nclass CdkAriaLive {\n    /** The aria-live politeness level to use when announcing messages. */\n    get politeness() {\n        return this._politeness;\n    }\n    set politeness(value) {\n        this._politeness = value === 'off' || value === 'assertive' ? value : 'polite';\n        if (this._politeness === 'off') {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n                this._subscription = null;\n            }\n        }\n        else if (!this._subscription) {\n            this._subscription = this._ngZone.runOutsideAngular(() => {\n                return this._contentObserver.observe(this._elementRef).subscribe(() => {\n                    // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                    const elementText = this._elementRef.nativeElement.textContent;\n                    // The `MutationObserver` fires also for attribute\n                    // changes which we don't want to announce.\n                    if (elementText !== this._previousAnnouncedText) {\n                        this._liveAnnouncer.announce(elementText, this._politeness, this.duration);\n                        this._previousAnnouncedText = elementText;\n                    }\n                });\n            });\n        }\n    }\n    constructor(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\n        this._elementRef = _elementRef;\n        this._liveAnnouncer = _liveAnnouncer;\n        this._contentObserver = _contentObserver;\n        this._ngZone = _ngZone;\n        this._politeness = 'polite';\n    }\n    ngOnDestroy() {\n        if (this._subscription) {\n            this._subscription.unsubscribe();\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkAriaLive, deps: [{ token: i0.ElementRef }, { token: LiveAnnouncer }, { token: i1$1.ContentObserver }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: CdkAriaLive, selector: \"[cdkAriaLive]\", inputs: { politeness: [\"cdkAriaLive\", \"politeness\"], duration: [\"cdkAriaLiveDuration\", \"duration\"] }, exportAs: [\"cdkAriaLive\"], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkAriaLive, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkAriaLive]',\n                    exportAs: 'cdkAriaLive',\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: LiveAnnouncer }, { type: i1$1.ContentObserver }, { type: i0.NgZone }], propDecorators: { politeness: [{\n                type: Input,\n                args: ['cdkAriaLive']\n            }], duration: [{\n                type: Input,\n                args: ['cdkAriaLiveDuration']\n            }] } });\n\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken('cdk-focus-monitor-default-options');\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\n    passive: true,\n    capture: true,\n});\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nclass FocusMonitor {\n    constructor(_ngZone, _platform, _inputModalityDetector, \n    /** @breaking-change 11.0.0 make document required */\n    document, options) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        this._inputModalityDetector = _inputModalityDetector;\n        /** The focus origin that the next focus event is a result of. */\n        this._origin = null;\n        /** Whether the window has just been focused. */\n        this._windowFocused = false;\n        /**\n         * Whether the origin was determined via a touch interaction. Necessary as properly attributing\n         * focus events to touch interactions requires special logic.\n         */\n        this._originFromTouchInteraction = false;\n        /** Map of elements being monitored to their info. */\n        this._elementInfo = new Map();\n        /** The number of elements currently being monitored. */\n        this._monitoredElementCount = 0;\n        /**\n         * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n         * as well as the number of monitored elements that they contain. We have to treat focus/blur\n         * handlers differently from the rest of the events, because the browser won't emit events\n         * to the document when focus moves inside of a shadow root.\n         */\n        this._rootNodeFocusListenerCount = new Map();\n        /**\n         * Event listener for `focus` events on the window.\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\n         */\n        this._windowFocusListener = () => {\n            // Make a note of when the window regains focus, so we can\n            // restore the origin info for the focused element.\n            this._windowFocused = true;\n            this._windowFocusTimeoutId = window.setTimeout(() => (this._windowFocused = false));\n        };\n        /** Subject for stopping our InputModalityDetector subscription. */\n        this._stopInputModalityDetector = new Subject();\n        /**\n         * Event listener for `focus` and 'blur' events on the document.\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\n         */\n        this._rootNodeFocusAndBlurListener = (event) => {\n            const target = _getEventTarget(event);\n            // We need to walk up the ancestor chain in order to support `checkChildren`.\n            for (let element = target; element; element = element.parentElement) {\n                if (event.type === 'focus') {\n                    this._onFocus(event, element);\n                }\n                else {\n                    this._onBlur(event, element);\n                }\n            }\n        };\n        this._document = document;\n        this._detectionMode = options?.detectionMode || 0 /* FocusMonitorDetectionMode.IMMEDIATE */;\n    }\n    monitor(element, checkChildren = false) {\n        const nativeElement = coerceElement(element);\n        // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n        if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n            // Note: we don't want the observable to emit at all so we don't pass any parameters.\n            return of();\n        }\n        // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n        // the shadow root, rather than the `document`, because the browser won't emit focus events\n        // to the `document`, if focus is moving within the same shadow root.\n        const rootNode = _getShadowRoot(nativeElement) || this._getDocument();\n        const cachedInfo = this._elementInfo.get(nativeElement);\n        // Check if we're already monitoring this element.\n        if (cachedInfo) {\n            if (checkChildren) {\n                // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n                // observers into ones that behave as if `checkChildren` was turned on. We need a more\n                // robust solution.\n                cachedInfo.checkChildren = true;\n            }\n            return cachedInfo.subject;\n        }\n        // Create monitored element info.\n        const info = {\n            checkChildren: checkChildren,\n            subject: new Subject(),\n            rootNode,\n        };\n        this._elementInfo.set(nativeElement, info);\n        this._registerGlobalListeners(info);\n        return info.subject;\n    }\n    stopMonitoring(element) {\n        const nativeElement = coerceElement(element);\n        const elementInfo = this._elementInfo.get(nativeElement);\n        if (elementInfo) {\n            elementInfo.subject.complete();\n            this._setClasses(nativeElement);\n            this._elementInfo.delete(nativeElement);\n            this._removeGlobalListeners(elementInfo);\n        }\n    }\n    focusVia(element, origin, options) {\n        const nativeElement = coerceElement(element);\n        const focusedElement = this._getDocument().activeElement;\n        // If the element is focused already, calling `focus` again won't trigger the event listener\n        // which means that the focus classes won't be updated. If that's the case, update the classes\n        // directly without waiting for an event.\n        if (nativeElement === focusedElement) {\n            this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\n        }\n        else {\n            this._setOrigin(origin);\n            // `focus` isn't available on the server\n            if (typeof nativeElement.focus === 'function') {\n                nativeElement.focus(options);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n    }\n    /** Access injected document if available or fallback to global document reference */\n    _getDocument() {\n        return this._document || document;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        const doc = this._getDocument();\n        return doc.defaultView || window;\n    }\n    _getFocusOrigin(focusEventTarget) {\n        if (this._origin) {\n            // If the origin was realized via a touch interaction, we need to perform additional checks\n            // to determine whether the focus origin should be attributed to touch or program.\n            if (this._originFromTouchInteraction) {\n                return this._shouldBeAttributedToTouch(focusEventTarget) ? 'touch' : 'program';\n            }\n            else {\n                return this._origin;\n            }\n        }\n        // If the window has just regained focus, we can restore the most recent origin from before the\n        // window blurred. Otherwise, we've reached the point where we can't identify the source of the\n        // focus. This typically means one of two things happened:\n        //\n        // 1) The element was programmatically focused, or\n        // 2) The element was focused via screen reader navigation (which generally doesn't fire\n        //    events).\n        //\n        // Because we can't distinguish between these two cases, we default to setting `program`.\n        if (this._windowFocused && this._lastFocusOrigin) {\n            return this._lastFocusOrigin;\n        }\n        // If the interaction is coming from an input label, we consider it a mouse interactions.\n        // This is a special case where focus moves on `click`, rather than `mousedown` which breaks\n        // our detection, because all our assumptions are for `mousedown`. We need to handle this\n        // special case, because it's very common for checkboxes and radio buttons.\n        if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {\n            return 'mouse';\n        }\n        return 'program';\n    }\n    /**\n     * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\n     * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\n     * handle a focus event following a touch interaction, we need to determine whether (1) the focus\n     * event was directly caused by the touch interaction or (2) the focus event was caused by a\n     * subsequent programmatic focus call triggered by the touch interaction.\n     * @param focusEventTarget The target of the focus event under examination.\n     */\n    _shouldBeAttributedToTouch(focusEventTarget) {\n        // Please note that this check is not perfect. Consider the following edge case:\n        //\n        // <div #parent tabindex=\"0\">\n        //   <div #child tabindex=\"0\" (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // Suppose there is a FocusMonitor in IMMEDIATE mode attached to #parent. When the user touches\n        // #child, #parent is programmatically focused. This code will attribute the focus to touch\n        // instead of program. This is a relatively minor edge-case that can be worked around by using\n        // focusVia(parent, 'program') to focus #parent.\n        return (this._detectionMode === 1 /* FocusMonitorDetectionMode.EVENTUAL */ ||\n            !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget));\n    }\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param element The element to update the classes on.\n     * @param origin The focus origin.\n     */\n    _setClasses(element, origin) {\n        element.classList.toggle('cdk-focused', !!origin);\n        element.classList.toggle('cdk-touch-focused', origin === 'touch');\n        element.classList.toggle('cdk-keyboard-focused', origin === 'keyboard');\n        element.classList.toggle('cdk-mouse-focused', origin === 'mouse');\n        element.classList.toggle('cdk-program-focused', origin === 'program');\n    }\n    /**\n     * Updates the focus origin. If we're using immediate detection mode, we schedule an async\n     * function to clear the origin at the end of a timeout. The duration of the timeout depends on\n     * the origin being set.\n     * @param origin The origin to set.\n     * @param isFromInteraction Whether we are setting the origin from an interaction event.\n     */\n    _setOrigin(origin, isFromInteraction = false) {\n        this._ngZone.runOutsideAngular(() => {\n            this._origin = origin;\n            this._originFromTouchInteraction = origin === 'touch' && isFromInteraction;\n            // If we're in IMMEDIATE mode, reset the origin at the next tick (or in `TOUCH_BUFFER_MS` ms\n            // for a touch event). We reset the origin at the next tick because Firefox focuses one tick\n            // after the interaction event. We wait `TOUCH_BUFFER_MS` ms before resetting the origin for\n            // a touch event because when a touch event is fired, the associated focus event isn't yet in\n            // the event queue. Before doing so, clear any pending timeouts.\n            if (this._detectionMode === 0 /* FocusMonitorDetectionMode.IMMEDIATE */) {\n                clearTimeout(this._originTimeoutId);\n                const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;\n                this._originTimeoutId = setTimeout(() => (this._origin = null), ms);\n            }\n        });\n    }\n    /**\n     * Handles focus events on a registered element.\n     * @param event The focus event.\n     * @param element The monitored element.\n     */\n    _onFocus(event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        const elementInfo = this._elementInfo.get(element);\n        const focusEventTarget = _getEventTarget(event);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== focusEventTarget)) {\n            return;\n        }\n        this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);\n    }\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    _onBlur(event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        const elementInfo = this._elementInfo.get(element);\n        if (!elementInfo ||\n            (elementInfo.checkChildren &&\n                event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        this._emitOrigin(elementInfo, null);\n    }\n    _emitOrigin(info, origin) {\n        if (info.subject.observers.length) {\n            this._ngZone.run(() => info.subject.next(origin));\n        }\n    }\n    _registerGlobalListeners(elementInfo) {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        const rootNode = elementInfo.rootNode;\n        const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n        if (!rootNodeFocusListeners) {\n            this._ngZone.runOutsideAngular(() => {\n                rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n            });\n        }\n        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount === 1) {\n            // Note: we listen to events in the capture phase so we\n            // can detect them even if the user stops propagation.\n            this._ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                window.addEventListener('focus', this._windowFocusListener);\n            });\n            // The InputModalityDetector is also just a collection of global listeners.\n            this._inputModalityDetector.modalityDetected\n                .pipe(takeUntil(this._stopInputModalityDetector))\n                .subscribe(modality => {\n                this._setOrigin(modality, true /* isFromInteraction */);\n            });\n        }\n    }\n    _removeGlobalListeners(elementInfo) {\n        const rootNode = elementInfo.rootNode;\n        if (this._rootNodeFocusListenerCount.has(rootNode)) {\n            const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n            if (rootNodeFocusListeners > 1) {\n                this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n            }\n            else {\n                rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                this._rootNodeFocusListenerCount.delete(rootNode);\n            }\n        }\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            const window = this._getWindow();\n            window.removeEventListener('focus', this._windowFocusListener);\n            // Equivalently, stop our InputModalityDetector subscription.\n            this._stopInputModalityDetector.next();\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(this._windowFocusTimeoutId);\n            clearTimeout(this._originTimeoutId);\n        }\n    }\n    /** Updates all the state on an element once its focus origin has changed. */\n    _originChanged(element, origin, elementInfo) {\n        this._setClasses(element, origin);\n        this._emitOrigin(elementInfo, origin);\n        this._lastFocusOrigin = origin;\n    }\n    /**\n     * Collects the `MonitoredElementInfo` of a particular element and\n     * all of its ancestors that have enabled `checkChildren`.\n     * @param element Element from which to start the search.\n     */\n    _getClosestElementsInfo(element) {\n        const results = [];\n        this._elementInfo.forEach((info, currentElement) => {\n            if (currentElement === element || (info.checkChildren && currentElement.contains(element))) {\n                results.push([currentElement, info]);\n            }\n        });\n        return results;\n    }\n    /**\n     * Returns whether an interaction is likely to have come from the user clicking the `label` of\n     * an `input` or `textarea` in order to focus it.\n     * @param focusEventTarget Target currently receiving focus.\n     */\n    _isLastInteractionFromInputLabel(focusEventTarget) {\n        const { _mostRecentTarget: mostRecentTarget, mostRecentModality } = this._inputModalityDetector;\n        // If the last interaction used the mouse on an element contained by one of the labels\n        // of an `input`/`textarea` that is currently focused, it is very likely that the\n        // user redirected focus using the label.\n        if (mostRecentModality !== 'mouse' ||\n            !mostRecentTarget ||\n            mostRecentTarget === focusEventTarget ||\n            (focusEventTarget.nodeName !== 'INPUT' && focusEventTarget.nodeName !== 'TEXTAREA') ||\n            focusEventTarget.disabled) {\n            return false;\n        }\n        const labels = focusEventTarget.labels;\n        if (labels) {\n            for (let i = 0; i < labels.length; i++) {\n                if (labels[i].contains(mostRecentTarget)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: FocusMonitor, deps: [{ token: i0.NgZone }, { token: i1.Platform }, { token: InputModalityDetector }, { token: DOCUMENT, optional: true }, { token: FOCUS_MONITOR_DEFAULT_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: FocusMonitor, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: FocusMonitor, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i1.Platform }, { type: InputModalityDetector }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [FOCUS_MONITOR_DEFAULT_OPTIONS]\n                }] }] });\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nclass CdkMonitorFocus {\n    constructor(_elementRef, _focusMonitor) {\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this._focusOrigin = null;\n        this.cdkFocusChange = new EventEmitter();\n    }\n    get focusOrigin() {\n        return this._focusOrigin;\n    }\n    ngAfterViewInit() {\n        const element = this._elementRef.nativeElement;\n        this._monitorSubscription = this._focusMonitor\n            .monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(origin => {\n            this._focusOrigin = origin;\n            this.cdkFocusChange.emit(origin);\n        });\n    }\n    ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n        if (this._monitorSubscription) {\n            this._monitorSubscription.unsubscribe();\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkMonitorFocus, deps: [{ token: i0.ElementRef }, { token: FocusMonitor }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"17.0.4\", type: CdkMonitorFocus, selector: \"[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]\", outputs: { cdkFocusChange: \"cdkFocusChange\" }, exportAs: [\"cdkMonitorFocus\"], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: CdkMonitorFocus, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                    exportAs: 'cdkMonitorFocus',\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: FocusMonitor }], propDecorators: { cdkFocusChange: [{\n                type: Output\n            }] } });\n\n/** CSS class applied to the document body when in black-on-white high-contrast mode. */\nconst BLACK_ON_WHITE_CSS_CLASS = 'cdk-high-contrast-black-on-white';\n/** CSS class applied to the document body when in white-on-black high-contrast mode. */\nconst WHITE_ON_BLACK_CSS_CLASS = 'cdk-high-contrast-white-on-black';\n/** CSS class applied to the document body when in high-contrast mode. */\nconst HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = 'cdk-high-contrast-active';\n/**\n * Service to determine whether the browser is currently in a high-contrast-mode environment.\n *\n * Microsoft Windows supports an accessibility feature called \"High Contrast Mode\". This mode\n * changes the appearance of all applications, including web applications, to dramatically increase\n * contrast.\n *\n * IE, Edge, and Firefox currently support this mode. Chrome does not support Windows High Contrast\n * Mode. This service does not detect high-contrast mode as added by the Chrome \"High Contrast\"\n * browser extension.\n */\nclass HighContrastModeDetector {\n    constructor(_platform, document) {\n        this._platform = _platform;\n        this._document = document;\n        this._breakpointSubscription = inject(BreakpointObserver)\n            .observe('(forced-colors: active)')\n            .subscribe(() => {\n            if (this._hasCheckedHighContrastMode) {\n                this._hasCheckedHighContrastMode = false;\n                this._applyBodyHighContrastModeCssClasses();\n            }\n        });\n    }\n    /** Gets the current high-contrast-mode for the page. */\n    getHighContrastMode() {\n        if (!this._platform.isBrowser) {\n            return 0 /* HighContrastMode.NONE */;\n        }\n        // Create a test element with an arbitrary background-color that is neither black nor\n        // white; high-contrast mode will coerce the color to either black or white. Also ensure that\n        // appending the test element to the DOM does not affect layout by absolutely positioning it\n        const testElement = this._document.createElement('div');\n        testElement.style.backgroundColor = 'rgb(1,2,3)';\n        testElement.style.position = 'absolute';\n        this._document.body.appendChild(testElement);\n        // Get the computed style for the background color, collapsing spaces to normalize between\n        // browsers. Once we get this color, we no longer need the test element. Access the `window`\n        // via the document so we can fake it in tests. Note that we have extra null checks, because\n        // this logic will likely run during app bootstrap and throwing can break the entire app.\n        const documentWindow = this._document.defaultView || window;\n        const computedStyle = documentWindow && documentWindow.getComputedStyle\n            ? documentWindow.getComputedStyle(testElement)\n            : null;\n        const computedColor = ((computedStyle && computedStyle.backgroundColor) || '').replace(/ /g, '');\n        testElement.remove();\n        switch (computedColor) {\n            // Pre Windows 11 dark theme.\n            case 'rgb(0,0,0)':\n            // Windows 11 dark themes.\n            case 'rgb(45,50,54)':\n            case 'rgb(32,32,32)':\n                return 2 /* HighContrastMode.WHITE_ON_BLACK */;\n            // Pre Windows 11 light theme.\n            case 'rgb(255,255,255)':\n            // Windows 11 light theme.\n            case 'rgb(255,250,239)':\n                return 1 /* HighContrastMode.BLACK_ON_WHITE */;\n        }\n        return 0 /* HighContrastMode.NONE */;\n    }\n    ngOnDestroy() {\n        this._breakpointSubscription.unsubscribe();\n    }\n    /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */\n    _applyBodyHighContrastModeCssClasses() {\n        if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {\n            const bodyClasses = this._document.body.classList;\n            bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);\n            this._hasCheckedHighContrastMode = true;\n            const mode = this.getHighContrastMode();\n            if (mode === 1 /* HighContrastMode.BLACK_ON_WHITE */) {\n                bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);\n            }\n            else if (mode === 2 /* HighContrastMode.WHITE_ON_BLACK */) {\n                bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);\n            }\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: HighContrastModeDetector, deps: [{ token: i1.Platform }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: HighContrastModeDetector, providedIn: 'root' }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: HighContrastModeDetector, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.Platform }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }] });\n\nclass A11yModule {\n    constructor(highContrastModeDetector) {\n        highContrastModeDetector._applyBodyHighContrastModeCssClasses();\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: A11yModule, deps: [{ token: HighContrastModeDetector }], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.4\", ngImport: i0, type: A11yModule, declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus], imports: [ObserversModule], exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: A11yModule, imports: [ObserversModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: A11yModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [ObserversModule],\n                    declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                }]\n        }], ctorParameters: () => [{ type: HighContrastModeDetector }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { A11yModule, ActiveDescendantKeyManager, AriaDescriber, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, CDK_DESCRIBEDBY_ID_PREFIX, CdkAriaLive, CdkMonitorFocus, CdkTrapFocus, ConfigurableFocusTrap, ConfigurableFocusTrapFactory, EventListenerFocusTrapInertStrategy, FOCUS_MONITOR_DEFAULT_OPTIONS, FOCUS_TRAP_INERT_STRATEGY, FocusKeyManager, FocusMonitor, FocusTrap, FocusTrapFactory, HighContrastModeDetector, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS, INPUT_MODALITY_DETECTOR_OPTIONS, InputModalityDetector, InteractivityChecker, IsFocusableConfig, LIVE_ANNOUNCER_DEFAULT_OPTIONS, LIVE_ANNOUNCER_ELEMENT_TOKEN, LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY, ListKeyManager, LiveAnnouncer, MESSAGES_CONTAINER_ID, addAriaReferencedId, getAriaReferenceIds, isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader, removeAriaReferencedId };\n","import * as i0 from '@angular/core';\nimport { Component } from '@angular/core';\nimport { BaseIcon } from 'primeng/baseicon';\n\nclass AngleDoubleDownIcon extends BaseIcon {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: AngleDoubleDownIcon, deps: null, target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.5\", type: AngleDoubleDownIcon, isStandalone: true, selector: \"AngleDoubleDownIcon\", usesInheritance: true, ngImport: i0, template: `\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" [attr.aria-label]=\"ariaLabel\" [attr.aria-hidden]=\"ariaHidden\" [attr.role]=\"role\" [class]=\"getClassNames()\">\n            <path\n                fill-rule=\"evenodd\"\n                clip-rule=\"evenodd\"\n                d=\"M6.70786 6.59831C6.80043 6.63674 6.89974 6.65629 6.99997 6.65581C7.19621 6.64081 7.37877 6.54953 7.50853 6.40153L11.0685 2.8416C11.1364 2.69925 11.1586 2.53932 11.132 2.38384C11.1053 2.22837 11.0311 2.08498 10.9195 1.97343C10.808 1.86188 10.6646 1.78766 10.5091 1.76099C10.3536 1.73431 10.1937 1.75649 10.0513 1.82448L6.99997 4.87585L3.9486 1.82448C3.80625 1.75649 3.64632 1.73431 3.49084 1.76099C3.33536 1.78766 3.19197 1.86188 3.08043 1.97343C2.96888 2.08498 2.89466 2.22837 2.86798 2.38384C2.84131 2.53932 2.86349 2.69925 2.93147 2.8416L6.46089 6.43205C6.53132 6.50336 6.61528 6.55989 6.70786 6.59831ZM6.70786 12.1925C6.80043 12.2309 6.89974 12.2505 6.99997 12.25C7.10241 12.2465 7.20306 12.2222 7.29575 12.1785C7.38845 12.1348 7.47124 12.0726 7.53905 11.9957L11.0685 8.46629C11.1614 8.32292 11.2036 8.15249 11.1881 7.98233C11.1727 7.81216 11.1005 7.6521 10.9833 7.52781C10.866 7.40353 10.7104 7.3222 10.5415 7.29688C10.3725 7.27155 10.1999 7.30369 10.0513 7.38814L6.99997 10.4395L3.9486 7.38814C3.80006 7.30369 3.62747 7.27155 3.45849 7.29688C3.28951 7.3222 3.13393 7.40353 3.01667 7.52781C2.89942 7.6521 2.82729 7.81216 2.81184 7.98233C2.79639 8.15249 2.83852 8.32292 2.93148 8.46629L6.4609 12.0262C6.53133 12.0975 6.61529 12.1541 6.70786 12.1925Z\"\n                fill=\"currentColor\"\n            />\n        </svg>\n    `, isInline: true });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: AngleDoubleDownIcon, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'AngleDoubleDownIcon',\n                    standalone: true,\n                    imports: [BaseIcon],\n                    template: `\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" [attr.aria-label]=\"ariaLabel\" [attr.aria-hidden]=\"ariaHidden\" [attr.role]=\"role\" [class]=\"getClassNames()\">\n            <path\n                fill-rule=\"evenodd\"\n                clip-rule=\"evenodd\"\n                d=\"M6.70786 6.59831C6.80043 6.63674 6.89974 6.65629 6.99997 6.65581C7.19621 6.64081 7.37877 6.54953 7.50853 6.40153L11.0685 2.8416C11.1364 2.69925 11.1586 2.53932 11.132 2.38384C11.1053 2.22837 11.0311 2.08498 10.9195 1.97343C10.808 1.86188 10.6646 1.78766 10.5091 1.76099C10.3536 1.73431 10.1937 1.75649 10.0513 1.82448L6.99997 4.87585L3.9486 1.82448C3.80625 1.75649 3.64632 1.73431 3.49084 1.76099C3.33536 1.78766 3.19197 1.86188 3.08043 1.97343C2.96888 2.08498 2.89466 2.22837 2.86798 2.38384C2.84131 2.53932 2.86349 2.69925 2.93147 2.8416L6.46089 6.43205C6.53132 6.50336 6.61528 6.55989 6.70786 6.59831ZM6.70786 12.1925C6.80043 12.2309 6.89974 12.2505 6.99997 12.25C7.10241 12.2465 7.20306 12.2222 7.29575 12.1785C7.38845 12.1348 7.47124 12.0726 7.53905 11.9957L11.0685 8.46629C11.1614 8.32292 11.2036 8.15249 11.1881 7.98233C11.1727 7.81216 11.1005 7.6521 10.9833 7.52781C10.866 7.40353 10.7104 7.3222 10.5415 7.29688C10.3725 7.27155 10.1999 7.30369 10.0513 7.38814L6.99997 10.4395L3.9486 7.38814C3.80006 7.30369 3.62747 7.27155 3.45849 7.29688C3.28951 7.3222 3.13393 7.40353 3.01667 7.52781C2.89942 7.6521 2.82729 7.81216 2.81184 7.98233C2.79639 8.15249 2.83852 8.32292 2.93148 8.46629L6.4609 12.0262C6.53133 12.0975 6.61529 12.1541 6.70786 12.1925Z\"\n                fill=\"currentColor\"\n            />\n        </svg>\n    `\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngleDoubleDownIcon };\n","import * as i0 from '@angular/core';\nimport { Component } from '@angular/core';\nimport { BaseIcon } from 'primeng/baseicon';\n\nclass AngleDoubleUpIcon extends BaseIcon {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: AngleDoubleUpIcon, deps: null, target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.5\", type: AngleDoubleUpIcon, isStandalone: true, selector: \"AngleDoubleUpIcon\", usesInheritance: true, ngImport: i0, template: `\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" [attr.aria-label]=\"ariaLabel\" [attr.aria-hidden]=\"ariaHidden\" [attr.role]=\"role\" [class]=\"getClassNames()\">\n            <path\n                fill-rule=\"evenodd\"\n                clip-rule=\"evenodd\"\n                d=\"M10.1504 6.67719C10.2417 6.71508 10.3396 6.73436 10.4385 6.73389C10.6338 6.74289 10.8249 6.67441 10.97 6.54334C11.1109 6.4023 11.19 6.21112 11.19 6.01178C11.19 5.81245 11.1109 5.62127 10.97 5.48023L7.45977 1.96998C7.31873 1.82912 7.12755 1.75 6.92821 1.75C6.72888 1.75 6.5377 1.82912 6.39666 1.96998L2.9165 5.45014C2.83353 5.58905 2.79755 5.751 2.81392 5.91196C2.83028 6.07293 2.89811 6.22433 3.00734 6.34369C3.11656 6.46306 3.26137 6.54402 3.42025 6.57456C3.57914 6.60511 3.74364 6.5836 3.88934 6.51325L6.89813 3.50446L9.90691 6.51325C9.97636 6.58357 10.0592 6.6393 10.1504 6.67719ZM9.93702 11.9993C10.065 12.1452 10.245 12.2352 10.4385 12.25C10.632 12.2352 10.812 12.1452 10.9399 11.9993C11.0633 11.8614 11.1315 11.6828 11.1315 11.4978C11.1315 11.3128 11.0633 11.1342 10.9399 10.9963L7.48987 7.48609C7.34883 7.34523 7.15765 7.26611 6.95832 7.26611C6.75899 7.26611 6.5678 7.34523 6.42677 7.48609L2.91652 10.9963C2.84948 11.1367 2.82761 11.2944 2.85391 11.4477C2.88022 11.601 2.9534 11.7424 3.06339 11.8524C3.17338 11.9624 3.31477 12.0356 3.46808 12.0619C3.62139 12.0882 3.77908 12.0663 3.91945 11.9993L6.92823 8.99048L9.93702 11.9993Z\"\n                fill=\"currentColor\"\n            />\n        </svg>\n    `, isInline: true });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: AngleDoubleUpIcon, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'AngleDoubleUpIcon',\n                    standalone: true,\n                    imports: [BaseIcon],\n                    template: `\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" [attr.aria-label]=\"ariaLabel\" [attr.aria-hidden]=\"ariaHidden\" [attr.role]=\"role\" [class]=\"getClassNames()\">\n            <path\n                fill-rule=\"evenodd\"\n                clip-rule=\"evenodd\"\n                d=\"M10.1504 6.67719C10.2417 6.71508 10.3396 6.73436 10.4385 6.73389C10.6338 6.74289 10.8249 6.67441 10.97 6.54334C11.1109 6.4023 11.19 6.21112 11.19 6.01178C11.19 5.81245 11.1109 5.62127 10.97 5.48023L7.45977 1.96998C7.31873 1.82912 7.12755 1.75 6.92821 1.75C6.72888 1.75 6.5377 1.82912 6.39666 1.96998L2.9165 5.45014C2.83353 5.58905 2.79755 5.751 2.81392 5.91196C2.83028 6.07293 2.89811 6.22433 3.00734 6.34369C3.11656 6.46306 3.26137 6.54402 3.42025 6.57456C3.57914 6.60511 3.74364 6.5836 3.88934 6.51325L6.89813 3.50446L9.90691 6.51325C9.97636 6.58357 10.0592 6.6393 10.1504 6.67719ZM9.93702 11.9993C10.065 12.1452 10.245 12.2352 10.4385 12.25C10.632 12.2352 10.812 12.1452 10.9399 11.9993C11.0633 11.8614 11.1315 11.6828 11.1315 11.4978C11.1315 11.3128 11.0633 11.1342 10.9399 10.9963L7.48987 7.48609C7.34883 7.34523 7.15765 7.26611 6.95832 7.26611C6.75899 7.26611 6.5678 7.34523 6.42677 7.48609L2.91652 10.9963C2.84948 11.1367 2.82761 11.2944 2.85391 11.4477C2.88022 11.601 2.9534 11.7424 3.06339 11.8524C3.17338 11.9624 3.31477 12.0356 3.46808 12.0619C3.62139 12.0882 3.77908 12.0663 3.91945 11.9993L6.92823 8.99048L9.93702 11.9993Z\"\n                fill=\"currentColor\"\n            />\n        </svg>\n    `\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngleDoubleUpIcon };\n","import * as i5 from '@angular/cdk/drag-drop';\nimport { transferArrayItem, moveItemInArray, DragDropModule, CDK_DRAG_CONFIG } from '@angular/cdk/drag-drop';\nimport * as i2 from '@angular/common';\nimport { isPlatformBrowser, DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, PLATFORM_ID, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, ViewChild, ContentChildren, NgModule } from '@angular/core';\nimport * as i1 from 'primeng/api';\nimport { PrimeTemplate, SharedModule } from 'primeng/api';\nimport * as i3 from 'primeng/button';\nimport { ButtonModule } from 'primeng/button';\nimport { DomHandler } from 'primeng/dom';\nimport { AngleDoubleDownIcon } from 'primeng/icons/angledoubledown';\nimport { AngleDoubleLeftIcon } from 'primeng/icons/angledoubleleft';\nimport { AngleDoubleRightIcon } from 'primeng/icons/angledoubleright';\nimport { AngleDoubleUpIcon } from 'primeng/icons/angledoubleup';\nimport { AngleDownIcon } from 'primeng/icons/angledown';\nimport { AngleLeftIcon } from 'primeng/icons/angleleft';\nimport { AngleRightIcon } from 'primeng/icons/angleright';\nimport { AngleUpIcon } from 'primeng/icons/angleup';\nimport { HomeIcon } from 'primeng/icons/home';\nimport { SearchIcon } from 'primeng/icons/search';\nimport * as i4 from 'primeng/ripple';\nimport { RippleModule } from 'primeng/ripple';\nimport { UniqueComponentId, ObjectUtils } from 'primeng/utils';\n\n/**\n * PickList is used to reorder items between different lists.\n * @group Components\n */\nclass PickList {\n    document;\n    platformId;\n    renderer;\n    el;\n    cd;\n    filterService;\n    config;\n    /**\n     * An array of objects for the source list.\n     * @group Props\n     */\n    source;\n    /**\n     * An array of objects for the target list.\n     * @group Props\n     */\n    target;\n    /**\n     * Text for the source list caption\n     * @group Props\n     */\n    sourceHeader;\n    /**\n     * Index of the element in tabbing order.\n     * @group Props\n     */\n    tabindex = 0;\n    /**\n     * Defines a string that labels the move to right button for accessibility.\n     * @group Props\n     */\n    rightButtonAriaLabel;\n    /**\n     * Defines a string that labels the move to left button for accessibility.\n     * @group Props\n     */\n    leftButtonAriaLabel;\n    /**\n     * Defines a string that labels the move to all right button for accessibility.\n     * @group Props\n     */\n    allRightButtonAriaLabel;\n    /**\n     * Defines a string that labels the move to all left button for accessibility.\n     * @group Props\n     */\n    allLeftButtonAriaLabel;\n    /**\n     * Defines a string that labels the move to up button for accessibility.\n     * @group Props\n     */\n    upButtonAriaLabel;\n    /**\n     * Defines a string that labels the move to down button for accessibility.\n     * @group Props\n     */\n    downButtonAriaLabel;\n    /**\n     * Defines a string that labels the move to top button for accessibility.\n     * @group Props\n     */\n    topButtonAriaLabel;\n    /**\n     * Defines a string that labels the move to bottom button for accessibility.\n     * @group Props\n     */\n    bottomButtonAriaLabel;\n    /**\n     * Text for the target list caption\n     * @group Props\n     */\n    targetHeader;\n    /**\n     * When enabled orderlist adjusts its controls based on screen size.\n     * @group Props\n     */\n    responsive;\n    /**\n     * When specified displays an input field to filter the items on keyup and decides which field to search (Accepts multiple fields with a comma).\n     * @group Props\n     */\n    filterBy;\n    /**\n     * Locale to use in filtering. The default locale is the host environment's current locale.\n     * @group Props\n     */\n    filterLocale;\n    /**\n     * Function to optimize the dom operations by delegating to ngForTrackBy, default algorithm checks for object identity. Use sourceTrackBy or targetTrackBy in case different algorithms are needed per list.\n     * @group Props\n     */\n    trackBy = (index, item) => item;\n    /**\n     * Function to optimize the dom operations by delegating to ngForTrackBy in source list, default algorithm checks for object identity.\n     * @group Props\n     */\n    sourceTrackBy;\n    /**\n     * Function to optimize the dom operations by delegating to ngForTrackBy in target list, default algorithm checks for object identity.\n     * @group Props\n     */\n    targetTrackBy;\n    /**\n     * Whether to show filter input for source list when filterBy is enabled.\n     * @group Props\n     */\n    showSourceFilter = true;\n    /**\n     * Whether to show filter input for target list when filterBy is enabled.\n     * @group Props\n     */\n    showTargetFilter = true;\n    /**\n     * Defines how multiple items can be selected, when true metaKey needs to be pressed to select or unselect an item and when set to false selection of each item can be toggled individually. On touch enabled devices, metaKeySelection is turned off automatically.\n     * @group Props\n     */\n    metaKeySelection = true;\n    /**\n     * Whether to enable dragdrop based reordering.\n     * @group Props\n     */\n    dragdrop = false;\n    /**\n     * Inline style of the component.\n     * @group Props\n     */\n    style;\n    /**\n     * Style class of the component.\n     * @group Props\n     */\n    styleClass;\n    /**\n     * Inline style of the source list element.\n     * @group Props\n     */\n    sourceStyle;\n    /**\n     * Inline style of the target list element.\n     * @group Props\n     */\n    targetStyle;\n    /**\n     * Whether to show buttons of source list.\n     * @group Props\n     */\n    showSourceControls = true;\n    /**\n     * Whether to show buttons of target list.\n     * @group Props\n     */\n    showTargetControls = true;\n    /**\n     * Placeholder text on source filter input.\n     * @group Props\n     */\n    sourceFilterPlaceholder;\n    /**\n     * Placeholder text on target filter input.\n     * @group Props\n     */\n    targetFilterPlaceholder;\n    /**\n     * When present, it specifies that the component should be disabled.\n     * @group Props\n     */\n    disabled = false;\n    /**\n     * Defines a string that labels the filter input of source list.\n     * @group Props\n     */\n    ariaSourceFilterLabel;\n    /**\n     * Defines a string that labels the filter input of target list.\n     * @group Props\n     */\n    ariaTargetFilterLabel;\n    /**\n     * Defines how the items are filtered.\n     * @group Props\n     */\n    filterMatchMode = 'contains';\n    /**\n     * Whether to displays rows with alternating colors.\n     * @group Props\n     */\n    stripedRows;\n    /**\n     * Keeps selection on the transfer list.\n     * @group Props\n     */\n    keepSelection = false;\n    /**\n     * Indicates the width of the screen at which the component should change its behavior.\n     * @group Props\n     */\n    get breakpoint() {\n        return this._breakpoint;\n    }\n    set breakpoint(value) {\n        if (value !== this._breakpoint) {\n            this._breakpoint = value;\n            if (isPlatformBrowser(this.platformId)) {\n                this.destroyMedia();\n                this.initMedia();\n            }\n        }\n    }\n    /**\n     * Callback to invoke when items are moved from target to source.\n     * @param {PickListMoveToSourceEvent} event - Custom move to source event.\n     * @group Emits\n     */\n    onMoveToSource = new EventEmitter();\n    /**\n     * Callback to invoke when all items are moved from target to source.\n     * @param {PickListMoveAllToSourceEvent} event - Custom move all to source event.\n     * @group Emits\n     */\n    onMoveAllToSource = new EventEmitter();\n    /**\n     * Callback to invoke when all items are moved from source to target.\n     * @param {PickListMoveAllToTargetEvent} event - Custom move all to target event.\n     * @group Emits\n     */\n    onMoveAllToTarget = new EventEmitter();\n    /**\n     * Callback to invoke when items are moved from source to target.\n     * @param {PickListMoveToTargetEvent} event - Custom move to target event.\n     * @group Emits\n     */\n    onMoveToTarget = new EventEmitter();\n    /**\n     * Callback to invoke when items are reordered within source list.\n     * @param {PickListSourceReorderEvent} event - Custom source reorder event.\n     * @group Emits\n     */\n    onSourceReorder = new EventEmitter();\n    /**\n     * Callback to invoke when items are reordered within target list.\n     * @param {PickListTargetReorderEvent} event - Custom target reorder event.\n     * @group Emits\n     */\n    onTargetReorder = new EventEmitter();\n    /**\n     * Callback to invoke when items are selected within source list.\n     * @param {PickListSourceSelectEvent} event - Custom source select event.\n     * @group Emits\n     */\n    onSourceSelect = new EventEmitter();\n    /**\n     * Callback to invoke when items are selected within target list.\n     * @param {PickListTargetSelectEvent} event - Custom target select event.\n     * @group Emits\n     */\n    onTargetSelect = new EventEmitter();\n    /**\n     * Callback to invoke when the source list is filtered\n     * @param {PickListSourceFilterEvent} event - Custom source filter event.\n     * @group Emits\n     */\n    onSourceFilter = new EventEmitter();\n    /**\n     * Callback to invoke when the target list is filtered\n     * @param {PickListTargetFilterEvent} event - Custom target filter event.\n     * @group Emits\n     */\n    onTargetFilter = new EventEmitter();\n    /**\n     * Callback to invoke when the list is focused\n     * @param {Event} event - Browser event.\n     * @group Emits\n     */\n    onFocus = new EventEmitter();\n    /**\n     * Callback to invoke when the list is blurred\n     * @param {Event} event - Browser event.\n     * @group Emits\n     */\n    onBlur = new EventEmitter();\n    listViewSourceChild;\n    listViewTargetChild;\n    sourceFilterViewChild;\n    targetFilterViewChild;\n    templates;\n    get moveUpAriaLabel() {\n        return this.upButtonAriaLabel ? this.upButtonAriaLabel : this.config.translation.aria ? this.config.translation.aria.moveUp : undefined;\n    }\n    get moveTopAriaLabel() {\n        return this.topButtonAriaLabel ? this.topButtonAriaLabel : this.config.translation.aria ? this.config.translation.aria.moveTop : undefined;\n    }\n    get moveDownAriaLabel() {\n        return this.downButtonAriaLabel ? this.downButtonAriaLabel : this.config.translation.aria ? this.config.translation.aria.moveDown : undefined;\n    }\n    get moveBottomAriaLabel() {\n        return this.bottomButtonAriaLabel ? this.bottomButtonAriaLabel : this.config.translation.aria ? this.config.translation.aria.moveDown : undefined;\n    }\n    get moveToTargetAriaLabel() {\n        return this.rightButtonAriaLabel ? this.rightButtonAriaLabel : this.config.translation.aria ? this.config.translation.aria.moveToTarget : undefined;\n    }\n    get moveAllToTargetAriaLabel() {\n        return this.allRightButtonAriaLabel ? this.allRightButtonAriaLabel : this.config.translation.aria ? this.config.translation.aria.moveAllToTarget : undefined;\n    }\n    get moveToSourceAriaLabel() {\n        return this.allLeftButtonAriaLabel ? this.allLeftButtonAriaLabel : this.config.translation.aria ? this.config.translation.aria.moveToSource : undefined;\n    }\n    get moveAllToSourceAriaLabel() {\n        return this.allLeftButtonAriaLabel ? this.allLeftButtonAriaLabel : this.config.translation.aria ? this.config.translation.aria.moveAllToSource : undefined;\n    }\n    get idSource() {\n        return this.id + '_source';\n    }\n    get idTarget() {\n        return this.id + '_target';\n    }\n    get focusedOptionId() {\n        return this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : null;\n    }\n    _breakpoint = '960px';\n    itemTemplate;\n    moveTopIconTemplate;\n    moveUpIconTemplate;\n    moveDownIconTemplate;\n    moveBottomIconTemplate;\n    moveToTargetIconTemplate;\n    moveAllToTargetIconTemplate;\n    moveToSourceIconTemplate;\n    moveAllToSourceIconTemplate;\n    targetFilterIconTemplate;\n    sourceFilterIconTemplate;\n    visibleOptionsSource;\n    visibleOptionsTarget;\n    selectedItemsSource = [];\n    selectedItemsTarget = [];\n    reorderedListElement;\n    movedUp;\n    movedDown;\n    itemTouched;\n    styleElement;\n    id = UniqueComponentId();\n    filterValueSource;\n    filterValueTarget;\n    fromListType;\n    emptyMessageSourceTemplate;\n    emptyFilterMessageSourceTemplate;\n    emptyMessageTargetTemplate;\n    emptyFilterMessageTargetTemplate;\n    sourceHeaderTemplate;\n    targetHeaderTemplate;\n    sourceFilterTemplate;\n    targetFilterTemplate;\n    sourceFilterOptions;\n    targetFilterOptions;\n    SOURCE_LIST = -1;\n    TARGET_LIST = 1;\n    window;\n    media;\n    viewChanged;\n    focusedOptionIndex = -1;\n    focusedOption;\n    focused = {\n        sourceList: false,\n        targetList: false\n    };\n    mediaChangeListener;\n    constructor(document, platformId, renderer, el, cd, filterService, config) {\n        this.document = document;\n        this.platformId = platformId;\n        this.renderer = renderer;\n        this.el = el;\n        this.cd = cd;\n        this.filterService = filterService;\n        this.config = config;\n        this.window = this.document.defaultView;\n    }\n    ngOnInit() {\n        if (this.responsive) {\n            this.createStyle();\n            this.initMedia();\n        }\n        if (this.filterBy) {\n            this.sourceFilterOptions = {\n                filter: (value) => this.filterSource(value),\n                reset: () => this.resetSourceFilter()\n            };\n            this.targetFilterOptions = {\n                filter: (value) => this.filterTarget(value),\n                reset: () => this.resetTargetFilter()\n            };\n        }\n    }\n    ngAfterContentInit() {\n        this.templates.forEach((item) => {\n            switch (item.getType()) {\n                case 'item':\n                    this.itemTemplate = item.template;\n                    break;\n                case 'sourceHeader':\n                    this.sourceHeaderTemplate = item.template;\n                    break;\n                case 'targetHeader':\n                    this.targetHeaderTemplate = item.template;\n                    break;\n                case 'sourceFilter':\n                    this.sourceFilterTemplate = item.template;\n                    break;\n                case 'targetFilter':\n                    this.targetFilterTemplate = item.template;\n                    break;\n                case 'emptymessagesource':\n                    this.emptyMessageSourceTemplate = item.template;\n                    break;\n                case 'emptyfiltermessagesource':\n                    this.emptyFilterMessageSourceTemplate = item.template;\n                    break;\n                case 'emptymessagetarget':\n                    this.emptyMessageTargetTemplate = item.template;\n                    break;\n                case 'emptyfiltermessagetarget':\n                    this.emptyFilterMessageTargetTemplate = item.template;\n                    break;\n                case 'moveupicon':\n                    this.moveUpIconTemplate = item.template;\n                    break;\n                case 'movetopicon':\n                    this.moveTopIconTemplate = item.template;\n                    break;\n                case 'movedownicon':\n                    this.moveDownIconTemplate = item.template;\n                    break;\n                case 'movebottomicon':\n                    this.moveBottomIconTemplate = item.template;\n                    break;\n                case 'movetotargeticon':\n                    this.moveToTargetIconTemplate = item.template;\n                    break;\n                case 'movealltotargeticon':\n                    this.moveAllToTargetIconTemplate = item.template;\n                    break;\n                case 'movetosourceicon':\n                    this.moveToSourceIconTemplate = item.template;\n                    break;\n                case 'movealltosourceicon':\n                    this.moveAllToSourceIconTemplate = item.template;\n                    break;\n                case 'targetfiltericon':\n                    this.targetFilterIconTemplate = item.template;\n                    break;\n                case 'sourcefiltericon':\n                    this.sourceFilterIconTemplate = item.template;\n                    break;\n                default:\n                    this.itemTemplate = item.template;\n                    break;\n            }\n        });\n    }\n    ngAfterViewChecked() {\n        if (this.movedUp || this.movedDown) {\n            let listItems = DomHandler.find(this.reorderedListElement, 'li.p-highlight');\n            let listItem;\n            if (this.movedUp)\n                listItem = listItems[0];\n            else\n                listItem = listItems[listItems.length - 1];\n            DomHandler.scrollInView(this.reorderedListElement, listItem);\n            this.movedUp = false;\n            this.movedDown = false;\n            this.reorderedListElement = null;\n        }\n    }\n    onItemClick(event, item, selectedItems, callback, itemId) {\n        if (this.disabled) {\n            return;\n        }\n        let index = this.findIndexInList(item, selectedItems);\n        if (itemId)\n            this.focusedOptionIndex = itemId;\n        let selected = index != -1;\n        let metaSelection = this.itemTouched ? false : this.metaKeySelection;\n        if (metaSelection) {\n            let metaKey = event.metaKey || event.ctrlKey || event.shiftKey;\n            if (selected && metaKey) {\n                selectedItems.splice(index, 1);\n            }\n            else {\n                if (!metaKey) {\n                    selectedItems.length = 0;\n                }\n                selectedItems.push(item);\n            }\n        }\n        else {\n            if (selected)\n                selectedItems.splice(index, 1);\n            else\n                selectedItems.push(item);\n        }\n        callback.emit({ originalEvent: event, items: selectedItems });\n        this.itemTouched = false;\n    }\n    onOptionMouseDown(index, listType) {\n        this.focused[listType === this.SOURCE_LIST ? 'sourceList' : 'targetList'] = true;\n        this.focusedOptionIndex = index;\n    }\n    onSourceItemDblClick() {\n        if (this.disabled) {\n            return;\n        }\n        this.moveRight();\n    }\n    onTargetItemDblClick() {\n        if (this.disabled) {\n            return;\n        }\n        this.moveLeft();\n    }\n    onFilter(event, listType) {\n        let query = event.target.value;\n        if (listType === this.SOURCE_LIST)\n            this.filterSource(query);\n        else if (listType === this.TARGET_LIST)\n            this.filterTarget(query);\n    }\n    filterSource(value = '') {\n        this.filterValueSource = value.trim().toLocaleLowerCase(this.filterLocale);\n        this.filter(this.source, this.SOURCE_LIST);\n    }\n    filterTarget(value = '') {\n        this.filterValueTarget = value.trim().toLocaleLowerCase(this.filterLocale);\n        this.filter(this.target, this.TARGET_LIST);\n    }\n    filter(data, listType) {\n        let searchFields = this.filterBy.split(',');\n        if (listType === this.SOURCE_LIST) {\n            this.visibleOptionsSource = this.filterService.filter(data, searchFields, this.filterValueSource, this.filterMatchMode, this.filterLocale);\n            this.onSourceFilter.emit({ query: this.filterValueSource, value: this.visibleOptionsSource });\n        }\n        else if (listType === this.TARGET_LIST) {\n            this.visibleOptionsTarget = this.filterService.filter(data, searchFields, this.filterValueTarget, this.filterMatchMode, this.filterLocale);\n            this.onTargetFilter.emit({ query: this.filterValueTarget, value: this.visibleOptionsTarget });\n        }\n    }\n    isItemVisible(item, listType) {\n        if (listType == this.SOURCE_LIST)\n            return this.isVisibleInList(this.visibleOptionsSource, item, this.filterValueSource);\n        else\n            return this.isVisibleInList(this.visibleOptionsTarget, item, this.filterValueTarget);\n    }\n    isEmpty(listType) {\n        if (listType == this.SOURCE_LIST)\n            return this.filterValueSource ? !this.visibleOptionsSource || this.visibleOptionsSource.length === 0 : !this.source || this.source.length === 0;\n        else\n            return this.filterValueTarget ? !this.visibleOptionsTarget || this.visibleOptionsTarget.length === 0 : !this.target || this.target.length === 0;\n    }\n    isVisibleInList(data, item, filterValue) {\n        if (filterValue && filterValue.trim().length) {\n            for (let i = 0; i < data.length; i++) {\n                if (item == data[i]) {\n                    return true;\n                }\n            }\n        }\n        else {\n            return true;\n        }\n    }\n    onItemTouchEnd() {\n        if (this.disabled) {\n            return;\n        }\n        this.itemTouched = true;\n    }\n    sortByIndexInList(items, list) {\n        return items.sort((item1, item2) => ObjectUtils.findIndexInList(item1, list) - ObjectUtils.findIndexInList(item2, list));\n    }\n    moveUp(listElement, list, selectedItems, callback, listType) {\n        if (selectedItems && selectedItems.length) {\n            selectedItems = this.sortByIndexInList(selectedItems, list);\n            for (let i = 0; i < selectedItems.length; i++) {\n                let selectedItem = selectedItems[i];\n                let selectedItemIndex = ObjectUtils.findIndexInList(selectedItem, list);\n                if (selectedItemIndex != 0) {\n                    let movedItem = list[selectedItemIndex];\n                    let temp = list[selectedItemIndex - 1];\n                    list[selectedItemIndex - 1] = movedItem;\n                    list[selectedItemIndex] = temp;\n                }\n                else {\n                    break;\n                }\n            }\n            if (this.dragdrop && ((this.filterValueSource && listType === this.SOURCE_LIST) || (this.filterValueTarget && listType === this.TARGET_LIST)))\n                this.filter(list, listType);\n            this.movedUp = true;\n            this.reorderedListElement = listElement;\n            callback.emit({ items: selectedItems });\n        }\n    }\n    moveTop(listElement, list, selectedItems, callback, listType) {\n        if (selectedItems && selectedItems.length) {\n            selectedItems = this.sortByIndexInList(selectedItems, list);\n            for (let i = 0; i < selectedItems.length; i++) {\n                let selectedItem = selectedItems[i];\n                let selectedItemIndex = ObjectUtils.findIndexInList(selectedItem, list);\n                if (selectedItemIndex != 0) {\n                    let movedItem = list.splice(selectedItemIndex, 1)[0];\n                    list.unshift(movedItem);\n                }\n                else {\n                    break;\n                }\n            }\n            if (this.dragdrop && ((this.filterValueSource && listType === this.SOURCE_LIST) || (this.filterValueTarget && listType === this.TARGET_LIST)))\n                this.filter(list, listType);\n            listElement.scrollTop = 0;\n            callback.emit({ items: selectedItems });\n        }\n    }\n    moveDown(listElement, list, selectedItems, callback, listType) {\n        if (selectedItems && selectedItems.length) {\n            selectedItems = this.sortByIndexInList(selectedItems, list);\n            for (let i = selectedItems.length - 1; i >= 0; i--) {\n                let selectedItem = selectedItems[i];\n                let selectedItemIndex = ObjectUtils.findIndexInList(selectedItem, list);\n                if (selectedItemIndex != list.length - 1) {\n                    let movedItem = list[selectedItemIndex];\n                    let temp = list[selectedItemIndex + 1];\n                    list[selectedItemIndex + 1] = movedItem;\n                    list[selectedItemIndex] = temp;\n                }\n                else {\n                    break;\n                }\n            }\n            if (this.dragdrop && ((this.filterValueSource && listType === this.SOURCE_LIST) || (this.filterValueTarget && listType === this.TARGET_LIST)))\n                this.filter(list, listType);\n            this.movedDown = true;\n            this.reorderedListElement = listElement;\n            callback.emit({ items: selectedItems });\n        }\n    }\n    moveBottom(listElement, list, selectedItems, callback, listType) {\n        if (selectedItems && selectedItems.length) {\n            selectedItems = this.sortByIndexInList(selectedItems, list);\n            for (let i = selectedItems.length - 1; i >= 0; i--) {\n                let selectedItem = selectedItems[i];\n                let selectedItemIndex = ObjectUtils.findIndexInList(selectedItem, list);\n                if (selectedItemIndex != list.length - 1) {\n                    let movedItem = list.splice(selectedItemIndex, 1)[0];\n                    list.push(movedItem);\n                }\n                else {\n                    break;\n                }\n            }\n            if (this.dragdrop && ((this.filterValueSource && listType === this.SOURCE_LIST) || (this.filterValueTarget && listType === this.TARGET_LIST)))\n                this.filter(list, listType);\n            listElement.scrollTop = listElement.scrollHeight;\n            callback.emit({ items: selectedItems });\n        }\n    }\n    moveRight() {\n        if (this.selectedItemsSource && this.selectedItemsSource.length) {\n            for (let i = 0; i < this.selectedItemsSource.length; i++) {\n                let selectedItem = this.selectedItemsSource[i];\n                if (ObjectUtils.findIndexInList(selectedItem, this.target) == -1) {\n                    this.target?.push(this.source?.splice(ObjectUtils.findIndexInList(selectedItem, this.source), 1)[0]);\n                    if (this.visibleOptionsSource?.includes(selectedItem)) {\n                        this.visibleOptionsSource.splice(ObjectUtils.findIndexInList(selectedItem, this.visibleOptionsSource), 1);\n                    }\n                }\n            }\n            this.onMoveToTarget.emit({\n                items: this.selectedItemsSource\n            });\n            if (this.keepSelection) {\n                this.selectedItemsTarget = [...this.selectedItemsTarget, ...this.selectedItemsSource];\n            }\n            this.selectedItemsSource = [];\n            if (this.filterValueTarget) {\n                this.filter(this.target, this.TARGET_LIST);\n            }\n        }\n    }\n    moveAllRight() {\n        if (this.source) {\n            let movedItems = [];\n            for (let i = 0; i < this.source.length; i++) {\n                if (this.isItemVisible(this.source[i], this.SOURCE_LIST)) {\n                    let removedItem = this.source.splice(i, 1)[0];\n                    this.target?.push(removedItem);\n                    movedItems.push(removedItem);\n                    i--;\n                }\n            }\n            this.onMoveAllToTarget.emit({\n                items: movedItems\n            });\n            if (this.keepSelection) {\n                this.selectedItemsTarget = [...this.selectedItemsTarget, ...this.selectedItemsSource];\n            }\n            this.selectedItemsSource = [];\n            if (this.filterValueTarget) {\n                this.filter(this.target, this.TARGET_LIST);\n            }\n            this.visibleOptionsSource = [];\n        }\n    }\n    moveLeft() {\n        if (this.selectedItemsTarget && this.selectedItemsTarget.length) {\n            for (let i = 0; i < this.selectedItemsTarget.length; i++) {\n                let selectedItem = this.selectedItemsTarget[i];\n                if (ObjectUtils.findIndexInList(selectedItem, this.source) == -1) {\n                    this.source?.push(this.target?.splice(ObjectUtils.findIndexInList(selectedItem, this.target), 1)[0]);\n                    if (this.visibleOptionsTarget?.includes(selectedItem)) {\n                        this.visibleOptionsTarget.splice(ObjectUtils.findIndexInList(selectedItem, this.visibleOptionsTarget), 1)[0];\n                    }\n                }\n            }\n            this.onMoveToSource.emit({\n                items: this.selectedItemsTarget\n            });\n            if (this.keepSelection) {\n                this.selectedItemsSource = [...this.selectedItemsSource, ...this.selectedItemsTarget];\n            }\n            this.selectedItemsTarget = [];\n            if (this.filterValueSource) {\n                this.filter(this.source, this.SOURCE_LIST);\n            }\n        }\n    }\n    moveAllLeft() {\n        if (this.target) {\n            let movedItems = [];\n            for (let i = 0; i < this.target.length; i++) {\n                if (this.isItemVisible(this.target[i], this.TARGET_LIST)) {\n                    let removedItem = this.target.splice(i, 1)[0];\n                    this.source?.push(removedItem);\n                    movedItems.push(removedItem);\n                    i--;\n                }\n            }\n            this.onMoveAllToSource.emit({\n                items: movedItems\n            });\n            if (this.keepSelection) {\n                this.selectedItemsSource = [...this.selectedItemsSource, ...this.selectedItemsTarget];\n            }\n            this.selectedItemsTarget = [];\n            if (this.filterValueSource) {\n                this.filter(this.source, this.SOURCE_LIST);\n            }\n            this.visibleOptionsTarget = [];\n        }\n    }\n    isSelected(item, selectedItems) {\n        return this.findIndexInList(item, selectedItems) != -1;\n    }\n    itemClass(item, id, selectedItems) {\n        return {\n            'p-picklist-item': true,\n            'p-highlight': this.isSelected(item, selectedItems),\n            'p-focus': id === this.focusedOptionId\n        };\n    }\n    findIndexInList(item, selectedItems) {\n        return ObjectUtils.findIndexInList(item, selectedItems);\n    }\n    onDrop(event, listType) {\n        let isTransfer = event.previousContainer !== event.container;\n        let dropIndexes = this.getDropIndexes(event.previousIndex, event.currentIndex, listType, isTransfer, event.item.data);\n        if (listType === this.SOURCE_LIST) {\n            if (isTransfer) {\n                transferArrayItem(event.previousContainer.data, event.container.data, dropIndexes.previousIndex, dropIndexes.currentIndex);\n                let selectedItemIndex = ObjectUtils.findIndexInList(event.item.data, this.selectedItemsTarget);\n                if (selectedItemIndex != -1) {\n                    this.selectedItemsTarget.splice(selectedItemIndex, 1);\n                    if (this.keepSelection) {\n                        this.selectedItemsTarget.push(event.item.data);\n                    }\n                }\n                if (this.visibleOptionsTarget)\n                    this.visibleOptionsTarget.splice(event.previousIndex, 1);\n                this.onMoveToSource.emit({ items: [event.item.data] });\n            }\n            else {\n                moveItemInArray(event.container.data, dropIndexes.previousIndex, dropIndexes.currentIndex);\n                this.onSourceReorder.emit({ items: [event.item.data] });\n            }\n            if (this.filterValueSource) {\n                this.filter(this.source, this.SOURCE_LIST);\n            }\n        }\n        else {\n            if (isTransfer) {\n                transferArrayItem(event.previousContainer.data, event.container.data, dropIndexes.previousIndex, dropIndexes.currentIndex);\n                let selectedItemIndex = ObjectUtils.findIndexInList(event.item.data, this.selectedItemsSource);\n                if (selectedItemIndex != -1) {\n                    this.selectedItemsSource.splice(selectedItemIndex, 1);\n                    if (this.keepSelection) {\n                        this.selectedItemsTarget.push(event.item.data);\n                    }\n                }\n                if (this.visibleOptionsSource)\n                    this.visibleOptionsSource.splice(event.previousIndex, 1);\n                this.onMoveToTarget.emit({ items: [event.item.data] });\n            }\n            else {\n                moveItemInArray(event.container.data, dropIndexes.previousIndex, dropIndexes.currentIndex);\n                this.onTargetReorder.emit({ items: [event.item.data] });\n            }\n            if (this.filterValueTarget) {\n                this.filter(this.target, this.TARGET_LIST);\n            }\n        }\n    }\n    onListFocus(event, listType) {\n        let listElement = this.getListElement(listType);\n        const selectedFirstItem = DomHandler.findSingle(listElement, 'li.p-picklist-item.p-highlight') || DomHandler.findSingle(listElement, 'li.p-picklist-item');\n        const findIndex = ObjectUtils.findIndexInList(selectedFirstItem, listElement.children);\n        this.focused[listType === this.SOURCE_LIST ? 'sourceList' : 'targetList'] = true;\n        const index = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : selectedFirstItem ? findIndex : -1;\n        this.changeFocusedOptionIndex(index, listType);\n        this.onFocus.emit(event);\n    }\n    onListBlur(event, listType) {\n        this.focused[listType === this.SOURCE_LIST ? 'sourceList' : 'targetList'] = false;\n        this.focusedOptionIndex = -1;\n        this.focusedOption = null;\n        this.onBlur.emit(event);\n    }\n    getListElement(listType) {\n        return listType === this.SOURCE_LIST ? this.listViewSourceChild?.nativeElement : this.listViewTargetChild?.nativeElement;\n    }\n    getListItems(listType) {\n        let listElemet = this.getListElement(listType);\n        return DomHandler.find(listElemet, 'li.p-picklist-item');\n    }\n    getLatestSelectedVisibleOptionIndex(visibleList, selectedItems) {\n        const latestSelectedItem = [...selectedItems].reverse().find((item) => visibleList.includes(item));\n        return latestSelectedItem !== undefined ? visibleList.indexOf(latestSelectedItem) : -1;\n    }\n    getVisibleList(listType) {\n        if (listType === this.SOURCE_LIST) {\n            return this.visibleOptionsSource && this.visibleOptionsSource.length > 0 ? this.visibleOptionsSource : this.source && this.source.length > 0 ? this.source : null;\n        }\n        return this.visibleOptionsTarget && this.visibleOptionsTarget.length > 0 ? this.visibleOptionsTarget : this.target && this.target.length > 0 ? this.target : null;\n    }\n    setSelectionList(listType, selectedItems) {\n        if (listType === this.SOURCE_LIST) {\n            this.selectedItemsSource = selectedItems;\n        }\n        else {\n            this.selectedItemsTarget = selectedItems;\n        }\n    }\n    findNextOptionIndex(index, listType) {\n        const items = this.getListItems(listType);\n        const matchedOptionIndex = [...items].findIndex((link) => link.id === index);\n        return matchedOptionIndex > -1 ? matchedOptionIndex + 1 : 0;\n    }\n    findPrevOptionIndex(index, listType) {\n        const items = this.getListItems(listType);\n        const matchedOptionIndex = [...items].findIndex((link) => link.id === index);\n        return matchedOptionIndex > -1 ? matchedOptionIndex - 1 : 0;\n    }\n    onItemKeyDown(event, selectedItems, callback, listType) {\n        switch (event.code) {\n            case 'ArrowDown':\n                this.onArrowDownKey(event, selectedItems, callback, listType);\n                break;\n            case 'ArrowUp':\n                this.onArrowUpKey(event, selectedItems, callback, listType);\n                break;\n            case 'Home':\n                this.onHomeKey(event, selectedItems, callback, listType);\n                break;\n            case 'End':\n                this.onEndKey(event, selectedItems, callback, listType);\n                break;\n            case 'Enter':\n                this.onEnterKey(event, selectedItems, callback);\n                break;\n            case 'Space':\n                this.onSpaceKey(event, selectedItems, callback, listType);\n                break;\n            case 'KeyA':\n                if (event.ctrlKey) {\n                    this.setSelectionList(listType, this.getVisibleList(listType));\n                    callback.emit({ items: selectedItems });\n                    event.preventDefault();\n                }\n            default:\n                break;\n        }\n    }\n    getFocusedOption(index, listType) {\n        if (index === -1)\n            return null;\n        if (listType === this.SOURCE_LIST) {\n            return this.visibleOptionsSource && this.visibleOptionsSource.length ? this.visibleOptionsSource[index] : this.source && this.source.length ? this.source[index] : null;\n        }\n        return this.visibleOptionsTarget && this.visibleOptionsTarget.length ? this.visibleOptionsTarget[index] : this.target && this.target.length ? this.target[index] : null;\n    }\n    changeFocusedOptionIndex(index, listType) {\n        const items = this.getListItems(listType);\n        if (items?.length > 0) {\n            let order = index >= items.length ? items.length - 1 : index < 0 ? 0 : index;\n            this.focusedOptionIndex = items[order].getAttribute('id');\n            this.focusedOption = this.getFocusedOption(order, listType);\n            this.scrollInView(items[order].getAttribute('id'), listType);\n        }\n    }\n    scrollInView(id, listType) {\n        const element = DomHandler.findSingle(this.getListElement(listType), `li[id=\"${id}\"]`);\n        if (element) {\n            element.scrollIntoView && element.scrollIntoView({ block: 'nearest', inline: 'start' });\n        }\n    }\n    onArrowDownKey(event, selectedItems, callback, listType) {\n        const optionIndex = this.findNextOptionIndex(this.focusedOptionIndex, listType);\n        this.changeFocusedOptionIndex(optionIndex, listType);\n        if (event.shiftKey) {\n            this.onEnterKey(event, selectedItems, callback);\n        }\n        event.preventDefault();\n    }\n    onArrowUpKey(event, selectedItems, callback, listType) {\n        const optionIndex = this.findPrevOptionIndex(this.focusedOptionIndex, listType);\n        this.changeFocusedOptionIndex(optionIndex, listType);\n        if (event.shiftKey) {\n            this.onEnterKey(event, selectedItems, callback);\n        }\n        event.preventDefault();\n    }\n    onEnterKey(event, selectedItems, callback) {\n        this.onItemClick(event, this.focusedOption, selectedItems, callback);\n        event.preventDefault();\n    }\n    onSpaceKey(event, selectedItems, callback, listType) {\n        event.preventDefault();\n        if (event.shiftKey && selectedItems && selectedItems.length > 0) {\n            let visibleList = this.getVisibleList(listType);\n            let lastSelectedIndex = this.getLatestSelectedVisibleOptionIndex(visibleList, selectedItems);\n            if (lastSelectedIndex !== -1) {\n                let focusedIndex = ObjectUtils.findIndexInList(this.focusedOption, visibleList);\n                selectedItems = [...visibleList.slice(Math.min(lastSelectedIndex, focusedIndex), Math.max(lastSelectedIndex, focusedIndex) + 1)];\n                this.setSelectionList(listType, selectedItems);\n                callback.emit({ items: selectedItems });\n                return;\n            }\n        }\n        this.onEnterKey(event, selectedItems, callback);\n    }\n    onHomeKey(event, selectedItems, callback, listType) {\n        if (event.ctrlKey && event.shiftKey) {\n            let visibleList = this.getVisibleList(listType);\n            let focusedIndex = ObjectUtils.findIndexInList(this.focusedOption, visibleList);\n            selectedItems = [...visibleList.slice(0, focusedIndex + 1)];\n            this.setSelectionList(listType, selectedItems);\n            callback.emit({ items: selectedItems });\n        }\n        else {\n            this.changeFocusedOptionIndex(0, listType);\n        }\n        event.preventDefault();\n    }\n    onEndKey(event, selectedItems, callback, listType) {\n        let visibleList = this.getVisibleList(listType);\n        let lastIndex = visibleList && visibleList.length > 0 ? visibleList.length - 1 : null;\n        if (lastIndex === null)\n            return;\n        if (event.ctrlKey && event.shiftKey) {\n            let focusedIndex = ObjectUtils.findIndexInList(this.focusedOption, visibleList);\n            selectedItems = [...visibleList.slice(focusedIndex, lastIndex)];\n            this.setSelectionList(listType, selectedItems);\n            callback.emit({ items: selectedItems });\n        }\n        else {\n            this.changeFocusedOptionIndex(lastIndex, listType);\n        }\n        event.preventDefault();\n    }\n    getDropIndexes(fromIndex, toIndex, droppedList, isTransfer, data) {\n        let previousIndex, currentIndex;\n        if (droppedList === this.SOURCE_LIST) {\n            previousIndex = isTransfer ? (this.filterValueTarget ? ObjectUtils.findIndexInList(data, this.target) : fromIndex) : this.filterValueSource ? ObjectUtils.findIndexInList(data, this.source) : fromIndex;\n            currentIndex = this.filterValueSource ? this.findFilteredCurrentIndex(this.visibleOptionsSource, toIndex, this.source) : toIndex;\n        }\n        else {\n            previousIndex = isTransfer ? (this.filterValueSource ? ObjectUtils.findIndexInList(data, this.source) : fromIndex) : this.filterValueTarget ? ObjectUtils.findIndexInList(data, this.target) : fromIndex;\n            currentIndex = this.filterValueTarget ? this.findFilteredCurrentIndex(this.visibleOptionsTarget, toIndex, this.target) : toIndex;\n        }\n        return { previousIndex, currentIndex };\n    }\n    findFilteredCurrentIndex(visibleOptions, index, options) {\n        if (visibleOptions.length === index) {\n            let toIndex = ObjectUtils.findIndexInList(visibleOptions[index - 1], options);\n            return toIndex + 1;\n        }\n        else {\n            return ObjectUtils.findIndexInList(visibleOptions[index], options);\n        }\n    }\n    resetSourceFilter() {\n        this.visibleOptionsSource = null;\n        this.filterValueSource = null;\n        this.sourceFilterViewChild && (this.sourceFilterViewChild.nativeElement.value = '');\n    }\n    resetTargetFilter() {\n        this.visibleOptionsTarget = null;\n        this.filterValueTarget = null;\n        this.targetFilterViewChild && (this.targetFilterViewChild.nativeElement.value = '');\n    }\n    resetFilter() {\n        this.resetSourceFilter();\n        this.resetTargetFilter();\n    }\n    onItemKeydown(event, item, selectedItems, callback) {\n        let listItem = event.currentTarget;\n        switch (event.which) {\n            //down\n            case 40:\n                var nextItem = this.findNextItem(listItem);\n                if (nextItem) {\n                    nextItem.focus();\n                }\n                event.preventDefault();\n                break;\n            //up\n            case 38:\n                var prevItem = this.findPrevItem(listItem);\n                if (prevItem) {\n                    prevItem.focus();\n                }\n                event.preventDefault();\n                break;\n            //enter\n            case 13:\n                this.onItemClick(event, item, selectedItems, callback);\n                event.preventDefault();\n                break;\n        }\n    }\n    findNextItem(item) {\n        let nextItem = item.nextElementSibling;\n        if (nextItem)\n            return !DomHandler.hasClass(nextItem, 'p-picklist-item') || DomHandler.isHidden(nextItem) ? this.findNextItem(nextItem) : nextItem;\n        else\n            return null;\n    }\n    findPrevItem(item) {\n        let prevItem = item.previousElementSibling;\n        if (prevItem)\n            return !DomHandler.hasClass(prevItem, 'p-picklist-item') || DomHandler.isHidden(prevItem) ? this.findPrevItem(prevItem) : prevItem;\n        else\n            return null;\n    }\n    initMedia() {\n        if (isPlatformBrowser(this.platformId)) {\n            this.media = this.window.matchMedia(`(max-width: ${this.breakpoint})`);\n            this.viewChanged = this.media.matches;\n            this.bindMediaChangeListener();\n        }\n    }\n    destroyMedia() {\n        this.unbindMediaChangeListener();\n    }\n    bindMediaChangeListener() {\n        if (this.media && !this.mediaChangeListener) {\n            this.mediaChangeListener = this.renderer.listen(this.media, 'change', (event) => {\n                this.viewChanged = event.matches;\n                this.cd.markForCheck();\n            });\n        }\n    }\n    unbindMediaChangeListener() {\n        if (this.mediaChangeListener) {\n            this.mediaChangeListener();\n            this.mediaChangeListener = null;\n        }\n    }\n    createStyle() {\n        if (isPlatformBrowser(this.platformId)) {\n            if (!this.styleElement) {\n                this.renderer.setAttribute(this.el.nativeElement.children[0], this.id, '');\n                this.styleElement = this.renderer.createElement('style');\n                this.renderer.setAttribute(this.styleElement, 'type', 'text/css');\n                this.renderer.appendChild(this.document.head, this.styleElement);\n                let innerHTML = `\n                @media screen and (max-width: ${this.breakpoint}) {\n                    .p-picklist[${this.id}] {\n                        flex-direction: column;\n                    }\n\n                    .p-picklist[${this.id}] .p-picklist-buttons {\n                        padding: var(--content-padding);\n                        flex-direction: row;\n                    }\n\n                    .p-picklist[${this.id}] .p-picklist-buttons .p-button {\n                        margin-right: var(--inline-spacing);\n                        margin-bottom: 0;\n                    }\n\n                    .p-picklist[${this.id}] .p-picklist-buttons .p-button:last-child {\n                        margin-right: 0;\n                    }\n                }`;\n                this.renderer.setProperty(this.styleElement, 'innerHTML', innerHTML);\n            }\n        }\n    }\n    sourceMoveDisabled() {\n        if (this.disabled || !this.selectedItemsSource.length) {\n            return true;\n        }\n    }\n    targetMoveDisabled() {\n        if (this.disabled || !this.selectedItemsTarget.length) {\n            return true;\n        }\n    }\n    moveRightDisabled() {\n        return this.disabled || ObjectUtils.isEmpty(this.selectedItemsSource);\n    }\n    moveLeftDisabled() {\n        return this.disabled || ObjectUtils.isEmpty(this.selectedItemsTarget);\n    }\n    moveAllRightDisabled() {\n        return this.disabled || ObjectUtils.isEmpty(this.source);\n    }\n    moveAllLeftDisabled() {\n        return this.disabled || ObjectUtils.isEmpty(this.target);\n    }\n    destroyStyle() {\n        if (this.styleElement) {\n            this.renderer.removeChild(this.document.head, this.styleElement);\n            this.styleElement = null;\n            ``;\n        }\n    }\n    ngOnDestroy() {\n        this.destroyStyle();\n        this.destroyMedia();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: PickList, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i1.FilterService }, { token: i1.PrimeNGConfig }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.5\", type: PickList, selector: \"p-pickList\", inputs: { source: \"source\", target: \"target\", sourceHeader: \"sourceHeader\", tabindex: \"tabindex\", rightButtonAriaLabel: \"rightButtonAriaLabel\", leftButtonAriaLabel: \"leftButtonAriaLabel\", allRightButtonAriaLabel: \"allRightButtonAriaLabel\", allLeftButtonAriaLabel: \"allLeftButtonAriaLabel\", upButtonAriaLabel: \"upButtonAriaLabel\", downButtonAriaLabel: \"downButtonAriaLabel\", topButtonAriaLabel: \"topButtonAriaLabel\", bottomButtonAriaLabel: \"bottomButtonAriaLabel\", targetHeader: \"targetHeader\", responsive: \"responsive\", filterBy: \"filterBy\", filterLocale: \"filterLocale\", trackBy: \"trackBy\", sourceTrackBy: \"sourceTrackBy\", targetTrackBy: \"targetTrackBy\", showSourceFilter: \"showSourceFilter\", showTargetFilter: \"showTargetFilter\", metaKeySelection: \"metaKeySelection\", dragdrop: \"dragdrop\", style: \"style\", styleClass: \"styleClass\", sourceStyle: \"sourceStyle\", targetStyle: \"targetStyle\", showSourceControls: \"showSourceControls\", showTargetControls: \"showTargetControls\", sourceFilterPlaceholder: \"sourceFilterPlaceholder\", targetFilterPlaceholder: \"targetFilterPlaceholder\", disabled: \"disabled\", ariaSourceFilterLabel: \"ariaSourceFilterLabel\", ariaTargetFilterLabel: \"ariaTargetFilterLabel\", filterMatchMode: \"filterMatchMode\", stripedRows: \"stripedRows\", keepSelection: \"keepSelection\", breakpoint: \"breakpoint\" }, outputs: { onMoveToSource: \"onMoveToSource\", onMoveAllToSource: \"onMoveAllToSource\", onMoveAllToTarget: \"onMoveAllToTarget\", onMoveToTarget: \"onMoveToTarget\", onSourceReorder: \"onSourceReorder\", onTargetReorder: \"onTargetReorder\", onSourceSelect: \"onSourceSelect\", onTargetSelect: \"onTargetSelect\", onSourceFilter: \"onSourceFilter\", onTargetFilter: \"onTargetFilter\", onFocus: \"onFocus\", onBlur: \"onBlur\" }, host: { classAttribute: \"p-element\" }, queries: [{ propertyName: \"templates\", predicate: PrimeTemplate }], viewQueries: [{ propertyName: \"listViewSourceChild\", first: true, predicate: [\"sourcelist\"], descendants: true }, { propertyName: \"listViewTargetChild\", first: true, predicate: [\"targetlist\"], descendants: true }, { propertyName: \"sourceFilterViewChild\", first: true, predicate: [\"sourceFilter\"], descendants: true }, { propertyName: \"targetFilterViewChild\", first: true, predicate: [\"targetFilter\"], descendants: true }], ngImport: i0, template: `\n        <div [class]=\"styleClass\" [ngStyle]=\"style\" [ngClass]=\"{ 'p-picklist p-component': true, 'p-picklist-striped': stripedRows }\" cdkDropListGroup [attr.data-pc-name]=\"'picklist'\" [attr.data-pc-section]=\"'root'\">\n            <div class=\"p-picklist-buttons p-picklist-source-controls\" *ngIf=\"showSourceControls\" [attr.data-pc-section]=\"'sourceControls'\" [attr.data-pc-group-section]=\"'controls'\">\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveUpAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"sourceMoveDisabled()\"\n                    (click)=\"moveUp(sourcelist, source, selectedItemsSource, onSourceReorder, SOURCE_LIST)\"\n                    [attr.data-pc-section]=\"'sourceMoveUpButton'\"\n                >\n                    <AngleUpIcon *ngIf=\"!moveUpIconTemplate\" [attr.data-pc-section]=\"'moveupicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveUpIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveTopAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"sourceMoveDisabled()\"\n                    (click)=\"moveTop(sourcelist, source, selectedItemsSource, onSourceReorder, SOURCE_LIST)\"\n                    [attr.data-pc-section]=\"'sourceMoveTopButton'\"\n                >\n                    <AngleDoubleUpIcon *ngIf=\"!moveTopIconTemplate\" [attr.data-pc-section]=\"'movetopicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveTopIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveDownAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"sourceMoveDisabled()\"\n                    (click)=\"moveDown(sourcelist, source, selectedItemsSource, onSourceReorder, SOURCE_LIST)\"\n                    [attr.data-pc-section]=\"'sourceMoveDownButton'\"\n                >\n                    <AngleDownIcon *ngIf=\"!moveDownIconTemplate\" [attr.data-pc-section]=\"'movedownicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveDownIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveBottomAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"sourceMoveDisabled()\"\n                    (click)=\"moveBottom(sourcelist, source, selectedItemsSource, onSourceReorder, SOURCE_LIST)\"\n                    [attr.data-pc-section]=\"'sourceMoveBottomButton'\"\n                >\n                    <AngleDoubleDownIcon *ngIf=\"!moveBottomIconTemplate\" [attr.data-pc-section]=\"'movebottomicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveBottomIconTemplate\"></ng-template>\n                </button>\n            </div>\n            <div class=\"p-picklist-list-wrapper p-picklist-source-wrapper\" [attr.data-pc-section]=\"'sourceWrapper'\" [attr.data-pc-group-section]=\"'listWrapper'\">\n                <div class=\"p-picklist-header\" *ngIf=\"sourceHeader || sourceHeaderTemplate\" [attr.data-pc-section]=\"'sourceHeader'\" [attr.data-pc-group-section]=\"'header'\">\n                    <div class=\"p-picklist-title\" *ngIf=\"!sourceHeaderTemplate\">{{ sourceHeader }}</div>\n                    <ng-container *ngTemplateOutlet=\"sourceHeaderTemplate\"></ng-container>\n                </div>\n                <div class=\"p-picklist-filter-container\" *ngIf=\"filterBy && showSourceFilter !== false\" [attr.data-pc-section]=\"'sourceFilterContainer'\">\n                    <ng-container *ngIf=\"sourceFilterTemplate; else builtInSourceElement\">\n                        <ng-container *ngTemplateOutlet=\"sourceFilterTemplate; context: { options: sourceFilterOptions }\"></ng-container>\n                    </ng-container>\n                    <ng-template #builtInSourceElement>\n                        <div class=\"p-picklist-filter\" [attr.data-pc-section]=\"'sourceFilter'\">\n                            <input\n                                #sourceFilter\n                                type=\"text\"\n                                role=\"textbox\"\n                                (keyup)=\"onFilter($event, SOURCE_LIST)\"\n                                class=\"p-picklist-filter-input p-inputtext p-component\"\n                                [disabled]=\"disabled\"\n                                [attr.placeholder]=\"sourceFilterPlaceholder\"\n                                [attr.aria-label]=\"ariaSourceFilterLabel\"\n                                [attr.data-pc-section]=\"'sourceFilterInput'\"\n                            />\n                            <SearchIcon *ngIf=\"!sourceFilterIconTemplate\" [styleClass]=\"'p-picklist-filter-icon'\" [attr.data-pc-section]=\"'sourcefilterIcon'\" />\n                            <span class=\"p-picklist-filter-icon\" *ngIf=\"sourceFilterIconTemplate\" [attr.data-pc-section]=\"'sourcefilterIcon'\">\n                                <ng-template *ngTemplateOutlet=\"sourceFilterIconTemplate\"></ng-template>\n                            </span>\n                        </div>\n                    </ng-template>\n                </div>\n\n                <ul\n                    #sourcelist\n                    class=\"p-picklist-list p-picklist-source\"\n                    [id]=\"idSource + '_list'\"\n                    (keydown)=\"onItemKeyDown($event, selectedItemsSource, onSourceSelect, SOURCE_LIST)\"\n                    (focus)=\"onListFocus($event, SOURCE_LIST)\"\n                    (blur)=\"onListBlur($event, SOURCE_LIST)\"\n                    cdkDropList\n                    [cdkDropListData]=\"source\"\n                    (cdkDropListDropped)=\"onDrop($event, SOURCE_LIST)\"\n                    [ngStyle]=\"sourceStyle\"\n                    role=\"listbox\"\n                    aria-multiselectable=\"true\"\n                    [attr.aria-activedescendant]=\"focused['sourceList'] ? focusedOptionId : undefined\"\n                    [attr.tabindex]=\"source && source.length > 0 ? tabindex : -1\"\n                    [attr.data-pc-section]=\"'sourceList'\"\n                    [attr.data-pc-group-section]=\"'list'\"\n                >\n                    <ng-template ngFor let-item [ngForOf]=\"source\" [ngForTrackBy]=\"sourceTrackBy || trackBy\" let-i=\"index\" let-l=\"last\">\n                        <li\n                            [ngClass]=\"{ 'p-picklist-item': true, 'p-highlight': isSelected(item, selectedItemsSource), 'p-disabled': disabled }\"\n                            pRipple\n                            cdkDrag\n                            [id]=\"idSource + '_' + i\"\n                            [ngClass]=\"itemClass(item, idSource + '_' + i, selectedItemsSource)\"\n                            [cdkDragData]=\"item\"\n                            [cdkDragDisabled]=\"!dragdrop\"\n                            (click)=\"onItemClick($event, item, selectedItemsSource, onSourceSelect, idSource + '_' + i)\"\n                            (mousedown)=\"onOptionMouseDown(i, SOURCE_LIST)\"\n                            (dblclick)=\"onSourceItemDblClick()\"\n                            (touchend)=\"onItemTouchEnd()\"\n                            *ngIf=\"isItemVisible(item, SOURCE_LIST)\"\n                            role=\"option\"\n                            [attr.data-pc-section]=\"'item'\"\n                            [attr.aria-selected]=\"isSelected(item, selectedItemsSource)\"\n                        >\n                            <ng-container *ngTemplateOutlet=\"itemTemplate; context: { $implicit: item, index: i }\"></ng-container>\n                        </li>\n                    </ng-template>\n                    <ng-container *ngIf=\"isEmpty(SOURCE_LIST) && (emptyMessageSourceTemplate || emptyFilterMessageSourceTemplate)\">\n                        <li class=\"p-picklist-empty-message\" *ngIf=\"!filterValueSource || !emptyFilterMessageSourceTemplate\" [attr.data-pc-section]=\"'sourceEmptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyMessageSourceTemplate\"></ng-container>\n                        </li>\n                        <li class=\"p-picklist-empty-message\" *ngIf=\"filterValueSource\" [attr.data-pc-section]=\"'sourceEmptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyFilterMessageSourceTemplate\"></ng-container>\n                        </li>\n                    </ng-container>\n                </ul>\n            </div>\n            <div class=\"p-picklist-buttons p-picklist-transfer-buttons\" [attr.data-pc-section]=\"'buttons'\" [attr.data-pc-group-section]=\"'controls'\">\n                <button type=\"button\" [attr.aria-label]=\"moveToTargetAriaLabel\" pButton pRipple class=\"p-button-icon-only\" [disabled]=\"moveRightDisabled()\" (click)=\"moveRight()\" [attr.data-pc-section]=\"'moveToTargetButton'\">\n                    <ng-container *ngIf=\"!moveToTargetIconTemplate\">\n                        <AngleRightIcon *ngIf=\"!viewChanged\" [attr.data-pc-section]=\"'movetotargeticon'\" />\n                        <AngleDownIcon *ngIf=\"viewChanged\" [attr.data-pc-section]=\"'movetotargeticon'\" />\n                    </ng-container>\n                    <ng-template *ngTemplateOutlet=\"moveToTargetIconTemplate; context: { $implicit: viewChanged }\"></ng-template>\n                </button>\n                <button type=\"button\" [attr.aria-label]=\"moveAllToTargetAriaLabel\" pButton pRipple class=\"p-button-icon-only\" [disabled]=\"moveAllRightDisabled()\" (click)=\"moveAllRight()\" [attr.data-pc-section]=\"'moveAllToTargetButton'\">\n                    <ng-container *ngIf=\"!moveAllToTargetIconTemplate\">\n                        <AngleDoubleRightIcon *ngIf=\"!viewChanged\" [attr.data-pc-section]=\"'movealltotargeticon'\" />\n                        <AngleDoubleDownIcon *ngIf=\"viewChanged\" [attr.data-pc-section]=\"'movealltotargeticon'\" />\n                    </ng-container>\n                    <ng-template *ngTemplateOutlet=\"moveAllToTargetIconTemplate; context: { $implicit: viewChanged }\"></ng-template>\n                </button>\n                <button type=\"button\" [attr.aria-label]=\"moveToSourceAriaLabel\" pButton pRipple class=\"p-button-icon-only\" [disabled]=\"moveLeftDisabled()\" (click)=\"moveLeft()\" [attr.data-pc-section]=\"'moveToSourceButton'\">\n                    <ng-container *ngIf=\"!moveToSourceIconTemplate\">\n                        <AngleLeftIcon *ngIf=\"!viewChanged\" [attr.data-pc-section]=\"'movedownsourceticon'\" />\n                        <AngleUpIcon *ngIf=\"viewChanged\" [attr.data-pc-section]=\"'movedownsourceticon'\" />\n                    </ng-container>\n                    <ng-template *ngTemplateOutlet=\"moveToSourceIconTemplate; context: { $implicit: viewChanged }\"></ng-template>\n                </button>\n                <button type=\"button\" [attr.aria-label]=\"moveAllToSourceAriaLabel\" pButton pRipple class=\"p-button-icon-only\" [disabled]=\"moveAllLeftDisabled()\" (click)=\"moveAllLeft()\" [attr.data-pc-section]=\"'moveAllToSourceButton'\">\n                    <ng-container *ngIf=\"!moveAllToSourceIconTemplate\">\n                        <AngleDoubleLeftIcon *ngIf=\"!viewChanged\" [attr.data-pc-section]=\"'movealltosourceticon'\" />\n                        <AngleDoubleUpIcon *ngIf=\"viewChanged\" [attr.data-pc-section]=\"'movealltosourceticon'\" />\n                    </ng-container>\n                    <ng-template *ngTemplateOutlet=\"moveAllToSourceIconTemplate; context: { $implicit: viewChanged }\"></ng-template>\n                </button>\n            </div>\n            <div class=\"p-picklist-list-wrapper p-picklist-target-wrapper\" [attr.data-pc-section]=\"'targetWrapper'\" [attr.data-pc-group-section]=\"'listwrapper'\">\n                <div class=\"p-picklist-header\" *ngIf=\"targetHeader || targetHeaderTemplate\" [attr.data-pc-section]=\"'targetHead'\" [attr.data-pc-group-section]=\"'header'\">\n                    <div class=\"p-picklist-title\" *ngIf=\"!targetHeaderTemplate\">{{ targetHeader }}</div>\n                    <ng-container *ngTemplateOutlet=\"targetHeaderTemplate\"></ng-container>\n                </div>\n                <div class=\"p-picklist-filter-container\" *ngIf=\"filterBy && showTargetFilter !== false\" [attr.data-pc-section]=\"'targetFilterContainer'\">\n                    <ng-container *ngIf=\"targetFilterTemplate; else builtInTargetElement\">\n                        <ng-container *ngTemplateOutlet=\"targetFilterTemplate; context: { options: targetFilterOptions }\"></ng-container>\n                    </ng-container>\n                    <ng-template #builtInTargetElement>\n                        <div class=\"p-picklist-filter\" [attr.data-pc-section]=\"'targetFilter'\">\n                            <input\n                                #targetFilter\n                                type=\"text\"\n                                role=\"textbox\"\n                                (keyup)=\"onFilter($event, TARGET_LIST)\"\n                                class=\"p-picklist-filter-input p-inputtext p-component\"\n                                [disabled]=\"disabled\"\n                                [attr.placeholder]=\"targetFilterPlaceholder\"\n                                [attr.aria-label]=\"ariaTargetFilterLabel\"\n                                [attr.data-pc-section]=\"'targetFilterInput'\"\n                            />\n                            <SearchIcon *ngIf=\"!targetFilterIconTemplate\" [styleClass]=\"'p-picklist-filter-icon'\" [attr.data-pc-section]=\"'targetfiltericon'\" />\n                            <span class=\"p-picklist-filter-icon\" *ngIf=\"targetFilterIconTemplate\" [attr.data-pc-section]=\"'targetfiltericon'\">\n                                <ng-template *ngTemplateOutlet=\"targetFilterIconTemplate\"></ng-template>\n                            </span>\n                        </div>\n                    </ng-template>\n                </div>\n                <ul\n                    #targetlist\n                    class=\"p-picklist-list p-picklist-target\"\n                    [id]=\"idTarget + '_list'\"\n                    (keydown)=\"onItemKeyDown($event, selectedItemsTarget, onTargetSelect, TARGET_LIST)\"\n                    (focus)=\"onListFocus($event, TARGET_LIST)\"\n                    (blur)=\"onListBlur($event, TARGET_LIST)\"\n                    cdkDropList\n                    [cdkDropListData]=\"target\"\n                    (cdkDropListDropped)=\"onDrop($event, TARGET_LIST)\"\n                    [ngStyle]=\"targetStyle\"\n                    role=\"listbox\"\n                    aria-multiselectable=\"true\"\n                    [attr.aria-activedescendant]=\"focused['targetList'] ? focusedOptionId : undefined\"\n                    [attr.tabindex]=\"target && target.length > 0 ? tabindex : -1\"\n                    [attr.data-pc-section]=\"'targetList'\"\n                    [attr.data-pc-group-section]=\"'list'\"\n                >\n                    <ng-template ngFor let-item [ngForOf]=\"target\" [ngForTrackBy]=\"targetTrackBy || trackBy\" let-i=\"index\" let-l=\"last\">\n                        <li\n                            [ngClass]=\"{ 'p-picklist-item': true, 'p-highlight': isSelected(item, selectedItemsTarget), 'p-disabled': disabled }\"\n                            pRipple\n                            cdkDrag\n                            [id]=\"idTarget + '_' + i\"\n                            [ngClass]=\"itemClass(item, idTarget + '_' + i, selectedItemsTarget)\"\n                            [cdkDragData]=\"item\"\n                            [cdkDragDisabled]=\"!dragdrop\"\n                            (click)=\"onItemClick($event, item, selectedItemsTarget, onTargetSelect, idTarget + '_' + i)\"\n                            (mousedown)=\"onOptionMouseDown(i, TARGET_LIST)\"\n                            (dblclick)=\"onTargetItemDblClick()\"\n                            (touchend)=\"onItemTouchEnd()\"\n                            *ngIf=\"isItemVisible(item, TARGET_LIST)\"\n                            role=\"option\"\n                            [attr.data-pc-section]=\"'item'\"\n                            [attr.aria-selected]=\"isSelected(item, selectedItemsTarget)\"\n                        >\n                            <ng-container *ngTemplateOutlet=\"itemTemplate; context: { $implicit: item, index: i }\"></ng-container>\n                        </li>\n                    </ng-template>\n                    <ng-container *ngIf=\"isEmpty(TARGET_LIST) && (emptyMessageTargetTemplate || emptyFilterMessageTargetTemplate)\">\n                        <li class=\"p-picklist-empty-message\" *ngIf=\"!filterValueTarget || !emptyFilterMessageTargetTemplate\" [attr.data-pc-section]=\"'targetEmptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyMessageTargetTemplate\"></ng-container>\n                        </li>\n                        <li class=\"p-picklist-empty-message\" *ngIf=\"filterValueTarget\" [attr.data-pc-section]=\"'targetEmptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyFilterMessageTargetTemplate\"></ng-container>\n                        </li>\n                    </ng-container>\n                </ul>\n            </div>\n            <div class=\"p-picklist-buttons p-picklist-target-controls\" *ngIf=\"showTargetControls\" [attr.data-pc-section]=\"'targetControls'\" [attr.data-pc-group-section]=\"'controls'\">\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveUpAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"targetMoveDisabled()\"\n                    (click)=\"moveUp(targetlist, target, selectedItemsTarget, onTargetReorder, TARGET_LIST)\"\n                    [attr.data-pc-section]=\"'targetMoveUpButton'\"\n                >\n                    <AngleUpIcon *ngIf=\"!moveUpIconTemplate\" [attr.data-pc-section]=\"'moveupicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveUpIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveTopAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"targetMoveDisabled()\"\n                    (click)=\"moveTop(targetlist, target, selectedItemsTarget, onTargetReorder, TARGET_LIST)\"\n                    [attr.data-pc-section]=\"'targetMoveTopButton'\"\n                >\n                    <AngleDoubleUpIcon *ngIf=\"!moveTopIconTemplate\" [attr.data-pc-section]=\"'movetopicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveTopIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveDownAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"targetMoveDisabled()\"\n                    (click)=\"moveDown(targetlist, target, selectedItemsTarget, onTargetReorder, TARGET_LIST)\"\n                    [attr.data-pc-section]=\"'targetMoveDownButton'\"\n                >\n                    <AngleDownIcon *ngIf=\"!moveDownIconTemplate\" [attr.data-pc-section]=\"'movedownicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveDownIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveBottomAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"targetMoveDisabled()\"\n                    (click)=\"moveBottom(targetlist, target, selectedItemsTarget, onTargetReorder, TARGET_LIST)\"\n                    [attr.data-pc-section]=\"'targetMoveBottomButton'\"\n                >\n                    <AngleDoubleDownIcon *ngIf=\"!moveBottomIconTemplate\" [attr.data-pc-section]=\"'movebottomicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveBottomIconTemplate\"></ng-template>\n                </button>\n            </div>\n        </div>\n    `, isInline: true, styles: [\"@layer primeng{.p-picklist{display:flex}.p-picklist-buttons{display:flex;flex-direction:column;justify-content:center}.p-picklist-list-wrapper{flex:1 1 50%}.p-picklist-list{list-style-type:none;margin:0;padding:0;overflow:auto;min-height:12rem}.p-picklist-item{display:block;cursor:pointer;overflow:hidden;position:relative}.p-picklist-item:not(.cdk-drag-disabled){cursor:move}.p-picklist-item.cdk-drag-placeholder{opacity:0}.p-picklist-item.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.p-picklist-filter{position:relative}.p-picklist-filter-icon{position:absolute;top:50%;margin-top:-.5rem}.p-picklist-filter-input{width:100%}.p-picklist-list.cdk-drop-list-dragging .p-picklist-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}}\\n\"], dependencies: [{ kind: \"directive\", type: i0.forwardRef(() => i2.NgClass), selector: \"[ngClass]\", inputs: [\"class\", \"ngClass\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgForOf), selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgIf), selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgTemplateOutlet), selector: \"[ngTemplateOutlet]\", inputs: [\"ngTemplateOutletContext\", \"ngTemplateOutlet\", \"ngTemplateOutletInjector\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgStyle), selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }, { kind: \"directive\", type: i0.forwardRef(() => i3.ButtonDirective), selector: \"[pButton]\", inputs: [\"iconPos\", \"loadingIcon\", \"label\", \"icon\", \"loading\"] }, { kind: \"directive\", type: i0.forwardRef(() => i4.Ripple), selector: \"[pRipple]\" }, { kind: \"directive\", type: i0.forwardRef(() => i5.CdkDropList), selector: \"[cdkDropList], cdk-drop-list\", inputs: [\"cdkDropListConnectedTo\", \"cdkDropListData\", \"cdkDropListOrientation\", \"id\", \"cdkDropListLockAxis\", \"cdkDropListDisabled\", \"cdkDropListSortingDisabled\", \"cdkDropListEnterPredicate\", \"cdkDropListSortPredicate\", \"cdkDropListAutoScrollDisabled\", \"cdkDropListAutoScrollStep\"], outputs: [\"cdkDropListDropped\", \"cdkDropListEntered\", \"cdkDropListExited\", \"cdkDropListSorted\"], exportAs: [\"cdkDropList\"] }, { kind: \"directive\", type: i0.forwardRef(() => i5.CdkDropListGroup), selector: \"[cdkDropListGroup]\", inputs: [\"cdkDropListGroupDisabled\"], exportAs: [\"cdkDropListGroup\"] }, { kind: \"directive\", type: i0.forwardRef(() => i5.CdkDrag), selector: \"[cdkDrag]\", inputs: [\"cdkDragData\", \"cdkDragLockAxis\", \"cdkDragRootElement\", \"cdkDragBoundary\", \"cdkDragStartDelay\", \"cdkDragFreeDragPosition\", \"cdkDragDisabled\", \"cdkDragConstrainPosition\", \"cdkDragPreviewClass\", \"cdkDragPreviewContainer\"], outputs: [\"cdkDragStarted\", \"cdkDragReleased\", \"cdkDragEnded\", \"cdkDragEntered\", \"cdkDragExited\", \"cdkDragDropped\", \"cdkDragMoved\"], exportAs: [\"cdkDrag\"] }, { kind: \"component\", type: i0.forwardRef(() => AngleDoubleDownIcon), selector: \"AngleDoubleDownIcon\" }, { kind: \"component\", type: i0.forwardRef(() => AngleDoubleLeftIcon), selector: \"AngleDoubleLeftIcon\" }, { kind: \"component\", type: i0.forwardRef(() => AngleDoubleRightIcon), selector: \"AngleDoubleRightIcon\" }, { kind: \"component\", type: i0.forwardRef(() => AngleDoubleUpIcon), selector: \"AngleDoubleUpIcon\" }, { kind: \"component\", type: i0.forwardRef(() => AngleDownIcon), selector: \"AngleDownIcon\" }, { kind: \"component\", type: i0.forwardRef(() => AngleLeftIcon), selector: \"AngleLeftIcon\" }, { kind: \"component\", type: i0.forwardRef(() => AngleRightIcon), selector: \"AngleRightIcon\" }, { kind: \"component\", type: i0.forwardRef(() => AngleUpIcon), selector: \"AngleUpIcon\" }, { kind: \"component\", type: i0.forwardRef(() => SearchIcon), selector: \"SearchIcon\" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: PickList, decorators: [{\n            type: Component,\n            args: [{ selector: 'p-pickList', template: `\n        <div [class]=\"styleClass\" [ngStyle]=\"style\" [ngClass]=\"{ 'p-picklist p-component': true, 'p-picklist-striped': stripedRows }\" cdkDropListGroup [attr.data-pc-name]=\"'picklist'\" [attr.data-pc-section]=\"'root'\">\n            <div class=\"p-picklist-buttons p-picklist-source-controls\" *ngIf=\"showSourceControls\" [attr.data-pc-section]=\"'sourceControls'\" [attr.data-pc-group-section]=\"'controls'\">\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveUpAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"sourceMoveDisabled()\"\n                    (click)=\"moveUp(sourcelist, source, selectedItemsSource, onSourceReorder, SOURCE_LIST)\"\n                    [attr.data-pc-section]=\"'sourceMoveUpButton'\"\n                >\n                    <AngleUpIcon *ngIf=\"!moveUpIconTemplate\" [attr.data-pc-section]=\"'moveupicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveUpIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveTopAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"sourceMoveDisabled()\"\n                    (click)=\"moveTop(sourcelist, source, selectedItemsSource, onSourceReorder, SOURCE_LIST)\"\n                    [attr.data-pc-section]=\"'sourceMoveTopButton'\"\n                >\n                    <AngleDoubleUpIcon *ngIf=\"!moveTopIconTemplate\" [attr.data-pc-section]=\"'movetopicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveTopIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveDownAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"sourceMoveDisabled()\"\n                    (click)=\"moveDown(sourcelist, source, selectedItemsSource, onSourceReorder, SOURCE_LIST)\"\n                    [attr.data-pc-section]=\"'sourceMoveDownButton'\"\n                >\n                    <AngleDownIcon *ngIf=\"!moveDownIconTemplate\" [attr.data-pc-section]=\"'movedownicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveDownIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveBottomAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"sourceMoveDisabled()\"\n                    (click)=\"moveBottom(sourcelist, source, selectedItemsSource, onSourceReorder, SOURCE_LIST)\"\n                    [attr.data-pc-section]=\"'sourceMoveBottomButton'\"\n                >\n                    <AngleDoubleDownIcon *ngIf=\"!moveBottomIconTemplate\" [attr.data-pc-section]=\"'movebottomicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveBottomIconTemplate\"></ng-template>\n                </button>\n            </div>\n            <div class=\"p-picklist-list-wrapper p-picklist-source-wrapper\" [attr.data-pc-section]=\"'sourceWrapper'\" [attr.data-pc-group-section]=\"'listWrapper'\">\n                <div class=\"p-picklist-header\" *ngIf=\"sourceHeader || sourceHeaderTemplate\" [attr.data-pc-section]=\"'sourceHeader'\" [attr.data-pc-group-section]=\"'header'\">\n                    <div class=\"p-picklist-title\" *ngIf=\"!sourceHeaderTemplate\">{{ sourceHeader }}</div>\n                    <ng-container *ngTemplateOutlet=\"sourceHeaderTemplate\"></ng-container>\n                </div>\n                <div class=\"p-picklist-filter-container\" *ngIf=\"filterBy && showSourceFilter !== false\" [attr.data-pc-section]=\"'sourceFilterContainer'\">\n                    <ng-container *ngIf=\"sourceFilterTemplate; else builtInSourceElement\">\n                        <ng-container *ngTemplateOutlet=\"sourceFilterTemplate; context: { options: sourceFilterOptions }\"></ng-container>\n                    </ng-container>\n                    <ng-template #builtInSourceElement>\n                        <div class=\"p-picklist-filter\" [attr.data-pc-section]=\"'sourceFilter'\">\n                            <input\n                                #sourceFilter\n                                type=\"text\"\n                                role=\"textbox\"\n                                (keyup)=\"onFilter($event, SOURCE_LIST)\"\n                                class=\"p-picklist-filter-input p-inputtext p-component\"\n                                [disabled]=\"disabled\"\n                                [attr.placeholder]=\"sourceFilterPlaceholder\"\n                                [attr.aria-label]=\"ariaSourceFilterLabel\"\n                                [attr.data-pc-section]=\"'sourceFilterInput'\"\n                            />\n                            <SearchIcon *ngIf=\"!sourceFilterIconTemplate\" [styleClass]=\"'p-picklist-filter-icon'\" [attr.data-pc-section]=\"'sourcefilterIcon'\" />\n                            <span class=\"p-picklist-filter-icon\" *ngIf=\"sourceFilterIconTemplate\" [attr.data-pc-section]=\"'sourcefilterIcon'\">\n                                <ng-template *ngTemplateOutlet=\"sourceFilterIconTemplate\"></ng-template>\n                            </span>\n                        </div>\n                    </ng-template>\n                </div>\n\n                <ul\n                    #sourcelist\n                    class=\"p-picklist-list p-picklist-source\"\n                    [id]=\"idSource + '_list'\"\n                    (keydown)=\"onItemKeyDown($event, selectedItemsSource, onSourceSelect, SOURCE_LIST)\"\n                    (focus)=\"onListFocus($event, SOURCE_LIST)\"\n                    (blur)=\"onListBlur($event, SOURCE_LIST)\"\n                    cdkDropList\n                    [cdkDropListData]=\"source\"\n                    (cdkDropListDropped)=\"onDrop($event, SOURCE_LIST)\"\n                    [ngStyle]=\"sourceStyle\"\n                    role=\"listbox\"\n                    aria-multiselectable=\"true\"\n                    [attr.aria-activedescendant]=\"focused['sourceList'] ? focusedOptionId : undefined\"\n                    [attr.tabindex]=\"source && source.length > 0 ? tabindex : -1\"\n                    [attr.data-pc-section]=\"'sourceList'\"\n                    [attr.data-pc-group-section]=\"'list'\"\n                >\n                    <ng-template ngFor let-item [ngForOf]=\"source\" [ngForTrackBy]=\"sourceTrackBy || trackBy\" let-i=\"index\" let-l=\"last\">\n                        <li\n                            [ngClass]=\"{ 'p-picklist-item': true, 'p-highlight': isSelected(item, selectedItemsSource), 'p-disabled': disabled }\"\n                            pRipple\n                            cdkDrag\n                            [id]=\"idSource + '_' + i\"\n                            [ngClass]=\"itemClass(item, idSource + '_' + i, selectedItemsSource)\"\n                            [cdkDragData]=\"item\"\n                            [cdkDragDisabled]=\"!dragdrop\"\n                            (click)=\"onItemClick($event, item, selectedItemsSource, onSourceSelect, idSource + '_' + i)\"\n                            (mousedown)=\"onOptionMouseDown(i, SOURCE_LIST)\"\n                            (dblclick)=\"onSourceItemDblClick()\"\n                            (touchend)=\"onItemTouchEnd()\"\n                            *ngIf=\"isItemVisible(item, SOURCE_LIST)\"\n                            role=\"option\"\n                            [attr.data-pc-section]=\"'item'\"\n                            [attr.aria-selected]=\"isSelected(item, selectedItemsSource)\"\n                        >\n                            <ng-container *ngTemplateOutlet=\"itemTemplate; context: { $implicit: item, index: i }\"></ng-container>\n                        </li>\n                    </ng-template>\n                    <ng-container *ngIf=\"isEmpty(SOURCE_LIST) && (emptyMessageSourceTemplate || emptyFilterMessageSourceTemplate)\">\n                        <li class=\"p-picklist-empty-message\" *ngIf=\"!filterValueSource || !emptyFilterMessageSourceTemplate\" [attr.data-pc-section]=\"'sourceEmptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyMessageSourceTemplate\"></ng-container>\n                        </li>\n                        <li class=\"p-picklist-empty-message\" *ngIf=\"filterValueSource\" [attr.data-pc-section]=\"'sourceEmptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyFilterMessageSourceTemplate\"></ng-container>\n                        </li>\n                    </ng-container>\n                </ul>\n            </div>\n            <div class=\"p-picklist-buttons p-picklist-transfer-buttons\" [attr.data-pc-section]=\"'buttons'\" [attr.data-pc-group-section]=\"'controls'\">\n                <button type=\"button\" [attr.aria-label]=\"moveToTargetAriaLabel\" pButton pRipple class=\"p-button-icon-only\" [disabled]=\"moveRightDisabled()\" (click)=\"moveRight()\" [attr.data-pc-section]=\"'moveToTargetButton'\">\n                    <ng-container *ngIf=\"!moveToTargetIconTemplate\">\n                        <AngleRightIcon *ngIf=\"!viewChanged\" [attr.data-pc-section]=\"'movetotargeticon'\" />\n                        <AngleDownIcon *ngIf=\"viewChanged\" [attr.data-pc-section]=\"'movetotargeticon'\" />\n                    </ng-container>\n                    <ng-template *ngTemplateOutlet=\"moveToTargetIconTemplate; context: { $implicit: viewChanged }\"></ng-template>\n                </button>\n                <button type=\"button\" [attr.aria-label]=\"moveAllToTargetAriaLabel\" pButton pRipple class=\"p-button-icon-only\" [disabled]=\"moveAllRightDisabled()\" (click)=\"moveAllRight()\" [attr.data-pc-section]=\"'moveAllToTargetButton'\">\n                    <ng-container *ngIf=\"!moveAllToTargetIconTemplate\">\n                        <AngleDoubleRightIcon *ngIf=\"!viewChanged\" [attr.data-pc-section]=\"'movealltotargeticon'\" />\n                        <AngleDoubleDownIcon *ngIf=\"viewChanged\" [attr.data-pc-section]=\"'movealltotargeticon'\" />\n                    </ng-container>\n                    <ng-template *ngTemplateOutlet=\"moveAllToTargetIconTemplate; context: { $implicit: viewChanged }\"></ng-template>\n                </button>\n                <button type=\"button\" [attr.aria-label]=\"moveToSourceAriaLabel\" pButton pRipple class=\"p-button-icon-only\" [disabled]=\"moveLeftDisabled()\" (click)=\"moveLeft()\" [attr.data-pc-section]=\"'moveToSourceButton'\">\n                    <ng-container *ngIf=\"!moveToSourceIconTemplate\">\n                        <AngleLeftIcon *ngIf=\"!viewChanged\" [attr.data-pc-section]=\"'movedownsourceticon'\" />\n                        <AngleUpIcon *ngIf=\"viewChanged\" [attr.data-pc-section]=\"'movedownsourceticon'\" />\n                    </ng-container>\n                    <ng-template *ngTemplateOutlet=\"moveToSourceIconTemplate; context: { $implicit: viewChanged }\"></ng-template>\n                </button>\n                <button type=\"button\" [attr.aria-label]=\"moveAllToSourceAriaLabel\" pButton pRipple class=\"p-button-icon-only\" [disabled]=\"moveAllLeftDisabled()\" (click)=\"moveAllLeft()\" [attr.data-pc-section]=\"'moveAllToSourceButton'\">\n                    <ng-container *ngIf=\"!moveAllToSourceIconTemplate\">\n                        <AngleDoubleLeftIcon *ngIf=\"!viewChanged\" [attr.data-pc-section]=\"'movealltosourceticon'\" />\n                        <AngleDoubleUpIcon *ngIf=\"viewChanged\" [attr.data-pc-section]=\"'movealltosourceticon'\" />\n                    </ng-container>\n                    <ng-template *ngTemplateOutlet=\"moveAllToSourceIconTemplate; context: { $implicit: viewChanged }\"></ng-template>\n                </button>\n            </div>\n            <div class=\"p-picklist-list-wrapper p-picklist-target-wrapper\" [attr.data-pc-section]=\"'targetWrapper'\" [attr.data-pc-group-section]=\"'listwrapper'\">\n                <div class=\"p-picklist-header\" *ngIf=\"targetHeader || targetHeaderTemplate\" [attr.data-pc-section]=\"'targetHead'\" [attr.data-pc-group-section]=\"'header'\">\n                    <div class=\"p-picklist-title\" *ngIf=\"!targetHeaderTemplate\">{{ targetHeader }}</div>\n                    <ng-container *ngTemplateOutlet=\"targetHeaderTemplate\"></ng-container>\n                </div>\n                <div class=\"p-picklist-filter-container\" *ngIf=\"filterBy && showTargetFilter !== false\" [attr.data-pc-section]=\"'targetFilterContainer'\">\n                    <ng-container *ngIf=\"targetFilterTemplate; else builtInTargetElement\">\n                        <ng-container *ngTemplateOutlet=\"targetFilterTemplate; context: { options: targetFilterOptions }\"></ng-container>\n                    </ng-container>\n                    <ng-template #builtInTargetElement>\n                        <div class=\"p-picklist-filter\" [attr.data-pc-section]=\"'targetFilter'\">\n                            <input\n                                #targetFilter\n                                type=\"text\"\n                                role=\"textbox\"\n                                (keyup)=\"onFilter($event, TARGET_LIST)\"\n                                class=\"p-picklist-filter-input p-inputtext p-component\"\n                                [disabled]=\"disabled\"\n                                [attr.placeholder]=\"targetFilterPlaceholder\"\n                                [attr.aria-label]=\"ariaTargetFilterLabel\"\n                                [attr.data-pc-section]=\"'targetFilterInput'\"\n                            />\n                            <SearchIcon *ngIf=\"!targetFilterIconTemplate\" [styleClass]=\"'p-picklist-filter-icon'\" [attr.data-pc-section]=\"'targetfiltericon'\" />\n                            <span class=\"p-picklist-filter-icon\" *ngIf=\"targetFilterIconTemplate\" [attr.data-pc-section]=\"'targetfiltericon'\">\n                                <ng-template *ngTemplateOutlet=\"targetFilterIconTemplate\"></ng-template>\n                            </span>\n                        </div>\n                    </ng-template>\n                </div>\n                <ul\n                    #targetlist\n                    class=\"p-picklist-list p-picklist-target\"\n                    [id]=\"idTarget + '_list'\"\n                    (keydown)=\"onItemKeyDown($event, selectedItemsTarget, onTargetSelect, TARGET_LIST)\"\n                    (focus)=\"onListFocus($event, TARGET_LIST)\"\n                    (blur)=\"onListBlur($event, TARGET_LIST)\"\n                    cdkDropList\n                    [cdkDropListData]=\"target\"\n                    (cdkDropListDropped)=\"onDrop($event, TARGET_LIST)\"\n                    [ngStyle]=\"targetStyle\"\n                    role=\"listbox\"\n                    aria-multiselectable=\"true\"\n                    [attr.aria-activedescendant]=\"focused['targetList'] ? focusedOptionId : undefined\"\n                    [attr.tabindex]=\"target && target.length > 0 ? tabindex : -1\"\n                    [attr.data-pc-section]=\"'targetList'\"\n                    [attr.data-pc-group-section]=\"'list'\"\n                >\n                    <ng-template ngFor let-item [ngForOf]=\"target\" [ngForTrackBy]=\"targetTrackBy || trackBy\" let-i=\"index\" let-l=\"last\">\n                        <li\n                            [ngClass]=\"{ 'p-picklist-item': true, 'p-highlight': isSelected(item, selectedItemsTarget), 'p-disabled': disabled }\"\n                            pRipple\n                            cdkDrag\n                            [id]=\"idTarget + '_' + i\"\n                            [ngClass]=\"itemClass(item, idTarget + '_' + i, selectedItemsTarget)\"\n                            [cdkDragData]=\"item\"\n                            [cdkDragDisabled]=\"!dragdrop\"\n                            (click)=\"onItemClick($event, item, selectedItemsTarget, onTargetSelect, idTarget + '_' + i)\"\n                            (mousedown)=\"onOptionMouseDown(i, TARGET_LIST)\"\n                            (dblclick)=\"onTargetItemDblClick()\"\n                            (touchend)=\"onItemTouchEnd()\"\n                            *ngIf=\"isItemVisible(item, TARGET_LIST)\"\n                            role=\"option\"\n                            [attr.data-pc-section]=\"'item'\"\n                            [attr.aria-selected]=\"isSelected(item, selectedItemsTarget)\"\n                        >\n                            <ng-container *ngTemplateOutlet=\"itemTemplate; context: { $implicit: item, index: i }\"></ng-container>\n                        </li>\n                    </ng-template>\n                    <ng-container *ngIf=\"isEmpty(TARGET_LIST) && (emptyMessageTargetTemplate || emptyFilterMessageTargetTemplate)\">\n                        <li class=\"p-picklist-empty-message\" *ngIf=\"!filterValueTarget || !emptyFilterMessageTargetTemplate\" [attr.data-pc-section]=\"'targetEmptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyMessageTargetTemplate\"></ng-container>\n                        </li>\n                        <li class=\"p-picklist-empty-message\" *ngIf=\"filterValueTarget\" [attr.data-pc-section]=\"'targetEmptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyFilterMessageTargetTemplate\"></ng-container>\n                        </li>\n                    </ng-container>\n                </ul>\n            </div>\n            <div class=\"p-picklist-buttons p-picklist-target-controls\" *ngIf=\"showTargetControls\" [attr.data-pc-section]=\"'targetControls'\" [attr.data-pc-group-section]=\"'controls'\">\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveUpAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"targetMoveDisabled()\"\n                    (click)=\"moveUp(targetlist, target, selectedItemsTarget, onTargetReorder, TARGET_LIST)\"\n                    [attr.data-pc-section]=\"'targetMoveUpButton'\"\n                >\n                    <AngleUpIcon *ngIf=\"!moveUpIconTemplate\" [attr.data-pc-section]=\"'moveupicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveUpIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveTopAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"targetMoveDisabled()\"\n                    (click)=\"moveTop(targetlist, target, selectedItemsTarget, onTargetReorder, TARGET_LIST)\"\n                    [attr.data-pc-section]=\"'targetMoveTopButton'\"\n                >\n                    <AngleDoubleUpIcon *ngIf=\"!moveTopIconTemplate\" [attr.data-pc-section]=\"'movetopicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveTopIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveDownAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"targetMoveDisabled()\"\n                    (click)=\"moveDown(targetlist, target, selectedItemsTarget, onTargetReorder, TARGET_LIST)\"\n                    [attr.data-pc-section]=\"'targetMoveDownButton'\"\n                >\n                    <AngleDownIcon *ngIf=\"!moveDownIconTemplate\" [attr.data-pc-section]=\"'movedownicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveDownIconTemplate\"></ng-template>\n                </button>\n                <button\n                    type=\"button\"\n                    [attr.aria-label]=\"moveBottomAriaLabel\"\n                    pButton\n                    pRipple\n                    class=\"p-button-icon-only\"\n                    [disabled]=\"targetMoveDisabled()\"\n                    (click)=\"moveBottom(targetlist, target, selectedItemsTarget, onTargetReorder, TARGET_LIST)\"\n                    [attr.data-pc-section]=\"'targetMoveBottomButton'\"\n                >\n                    <AngleDoubleDownIcon *ngIf=\"!moveBottomIconTemplate\" [attr.data-pc-section]=\"'movebottomicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveBottomIconTemplate\"></ng-template>\n                </button>\n            </div>\n        </div>\n    `, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, host: {\n                        class: 'p-element'\n                    }, styles: [\"@layer primeng{.p-picklist{display:flex}.p-picklist-buttons{display:flex;flex-direction:column;justify-content:center}.p-picklist-list-wrapper{flex:1 1 50%}.p-picklist-list{list-style-type:none;margin:0;padding:0;overflow:auto;min-height:12rem}.p-picklist-item{display:block;cursor:pointer;overflow:hidden;position:relative}.p-picklist-item:not(.cdk-drag-disabled){cursor:move}.p-picklist-item.cdk-drag-placeholder{opacity:0}.p-picklist-item.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.p-picklist-filter{position:relative}.p-picklist-filter-icon{position:absolute;top:50%;margin-top:-.5rem}.p-picklist-filter-input{width:100%}.p-picklist-list.cdk-drop-list-dragging .p-picklist-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}}\\n\"] }]\n        }], ctorParameters: () => [{ type: Document, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1.FilterService }, { type: i1.PrimeNGConfig }], propDecorators: { source: [{\n                type: Input\n            }], target: [{\n                type: Input\n            }], sourceHeader: [{\n                type: Input\n            }], tabindex: [{\n                type: Input\n            }], rightButtonAriaLabel: [{\n                type: Input\n            }], leftButtonAriaLabel: [{\n                type: Input\n            }], allRightButtonAriaLabel: [{\n                type: Input\n            }], allLeftButtonAriaLabel: [{\n                type: Input\n            }], upButtonAriaLabel: [{\n                type: Input\n            }], downButtonAriaLabel: [{\n                type: Input\n            }], topButtonAriaLabel: [{\n                type: Input\n            }], bottomButtonAriaLabel: [{\n                type: Input\n            }], targetHeader: [{\n                type: Input\n            }], responsive: [{\n                type: Input\n            }], filterBy: [{\n                type: Input\n            }], filterLocale: [{\n                type: Input\n            }], trackBy: [{\n                type: Input\n            }], sourceTrackBy: [{\n                type: Input\n            }], targetTrackBy: [{\n                type: Input\n            }], showSourceFilter: [{\n                type: Input\n            }], showTargetFilter: [{\n                type: Input\n            }], metaKeySelection: [{\n                type: Input\n            }], dragdrop: [{\n                type: Input\n            }], style: [{\n                type: Input\n            }], styleClass: [{\n                type: Input\n            }], sourceStyle: [{\n                type: Input\n            }], targetStyle: [{\n                type: Input\n            }], showSourceControls: [{\n                type: Input\n            }], showTargetControls: [{\n                type: Input\n            }], sourceFilterPlaceholder: [{\n                type: Input\n            }], targetFilterPlaceholder: [{\n                type: Input\n            }], disabled: [{\n                type: Input\n            }], ariaSourceFilterLabel: [{\n                type: Input\n            }], ariaTargetFilterLabel: [{\n                type: Input\n            }], filterMatchMode: [{\n                type: Input\n            }], stripedRows: [{\n                type: Input\n            }], keepSelection: [{\n                type: Input\n            }], breakpoint: [{\n                type: Input\n            }], onMoveToSource: [{\n                type: Output\n            }], onMoveAllToSource: [{\n                type: Output\n            }], onMoveAllToTarget: [{\n                type: Output\n            }], onMoveToTarget: [{\n                type: Output\n            }], onSourceReorder: [{\n                type: Output\n            }], onTargetReorder: [{\n                type: Output\n            }], onSourceSelect: [{\n                type: Output\n            }], onTargetSelect: [{\n                type: Output\n            }], onSourceFilter: [{\n                type: Output\n            }], onTargetFilter: [{\n                type: Output\n            }], onFocus: [{\n                type: Output\n            }], onBlur: [{\n                type: Output\n            }], listViewSourceChild: [{\n                type: ViewChild,\n                args: ['sourcelist']\n            }], listViewTargetChild: [{\n                type: ViewChild,\n                args: ['targetlist']\n            }], sourceFilterViewChild: [{\n                type: ViewChild,\n                args: ['sourceFilter']\n            }], targetFilterViewChild: [{\n                type: ViewChild,\n                args: ['targetFilter']\n            }], templates: [{\n                type: ContentChildren,\n                args: [PrimeTemplate]\n            }] } });\nconst DragConfig = {\n    zIndex: 1200\n};\nclass PickListModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: PickListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.5\", ngImport: i0, type: PickListModule, declarations: [PickList], imports: [CommonModule, ButtonModule, SharedModule, RippleModule, DragDropModule, AngleDoubleDownIcon, AngleDoubleLeftIcon, AngleDoubleRightIcon, AngleDoubleUpIcon, AngleDownIcon, AngleLeftIcon, AngleRightIcon, AngleUpIcon, SearchIcon, HomeIcon], exports: [PickList, SharedModule, DragDropModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: PickListModule, providers: [{ provide: CDK_DRAG_CONFIG, useValue: DragConfig }], imports: [CommonModule, ButtonModule, SharedModule, RippleModule, DragDropModule, AngleDoubleDownIcon, AngleDoubleLeftIcon, AngleDoubleRightIcon, AngleDoubleUpIcon, AngleDownIcon, AngleLeftIcon, AngleRightIcon, AngleUpIcon, SearchIcon, HomeIcon, SharedModule, DragDropModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: PickListModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule, ButtonModule, SharedModule, RippleModule, DragDropModule, AngleDoubleDownIcon, AngleDoubleLeftIcon, AngleDoubleRightIcon, AngleDoubleUpIcon, AngleDownIcon, AngleLeftIcon, AngleRightIcon, AngleUpIcon, SearchIcon, HomeIcon],\n                    exports: [PickList, SharedModule, DragDropModule],\n                    declarations: [PickList],\n                    providers: [{ provide: CDK_DRAG_CONFIG, useValue: DragConfig }]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { PickList, PickListModule };\n","import * as i5 from '@angular/cdk/drag-drop';\nimport { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';\nimport * as i2 from '@angular/common';\nimport { isPlatformBrowser, DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, PLATFORM_ID, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, ViewChild, ContentChildren, NgModule } from '@angular/core';\nimport * as i1 from 'primeng/api';\nimport { PrimeTemplate, SharedModule } from 'primeng/api';\nimport * as i3 from 'primeng/button';\nimport { ButtonModule } from 'primeng/button';\nimport { DomHandler } from 'primeng/dom';\nimport { AngleDoubleDownIcon } from 'primeng/icons/angledoubledown';\nimport { AngleDoubleUpIcon } from 'primeng/icons/angledoubleup';\nimport { AngleDownIcon } from 'primeng/icons/angledown';\nimport { AngleUpIcon } from 'primeng/icons/angleup';\nimport { SearchIcon } from 'primeng/icons/search';\nimport * as i4 from 'primeng/ripple';\nimport { RippleModule } from 'primeng/ripple';\nimport { UniqueComponentId, ObjectUtils } from 'primeng/utils';\n\n/**\n * OrderList is used to managed the order of a collection.\n * @group Components\n */\nclass OrderList {\n    document;\n    platformId;\n    renderer;\n    el;\n    cd;\n    filterService;\n    config;\n    /**\n     * Text for the caption.\n     * @group Props\n     */\n    header;\n    /**\n     * Inline style of the component.\n     * @group Props\n     */\n    style;\n    /**\n     * Style class of the component.\n     * @group Props\n     */\n    styleClass;\n    /**\n     * Index of the element in tabbing order.\n     * @group Props\n     */\n    tabindex;\n    /**\n     * Defines a string that labels the input for accessibility.\n     * @group Props\n     */\n    ariaLabel;\n    /**\n     * Specifies one or more IDs in the DOM that labels the input field.\n     * @group Props\n     */\n    ariaLabelledBy;\n    /**\n     * Inline style of the list element.\n     * @group Props\n     */\n    listStyle;\n    /**\n     * A boolean value that indicates whether the component should be responsive.\n     * @group Props\n     */\n    responsive;\n    /**\n     * When specified displays an input field to filter the items on keyup and decides which fields to search against.\n     * @group Props\n     */\n    filterBy;\n    /**\n     * Placeholder of the filter input.\n     * @group Props\n     */\n    filterPlaceholder;\n    /**\n     * Locale to use in filtering. The default locale is the host environment's current locale.\n     * @group Props\n     */\n    filterLocale;\n    /**\n     * When true metaKey needs to be pressed to select or unselect an item and when set to false selection of each item can be toggled individually. On touch enabled devices, metaKeySelection is turned off automatically.\n     * @group Props\n     */\n    metaKeySelection = true;\n    /**\n     * Whether to enable dragdrop based reordering.\n     * @group Props\n     */\n    dragdrop = false;\n    /**\n     * Defines the location of the buttons with respect to the list.\n     * @group Props\n     */\n    controlsPosition = 'left';\n    /**\n     * Defines a string that labels the filter input.\n     * @group Props\n     */\n    ariaFilterLabel;\n    /**\n     * Defines how the items are filtered.\n     * @group Props\n     */\n    filterMatchMode = 'contains';\n    /**\n     * Indicates the width of the screen at which the component should change its behavior.\n     * @group Props\n     */\n    breakpoint = '960px';\n    /**\n     * Whether to displays rows with alternating colors.\n     * @group Props\n     */\n    stripedRows;\n    /**\n     * When present, it specifies that the component should be disabled.\n     * @group Props\n     */\n    disabled = false;\n    /**\n     * Function to optimize the dom operations by delegating to ngForTrackBy, default algorithm checks for object identity.\n     * @group Props\n     */\n    trackBy = (index, item) => item;\n    /**\n     * A list of values that are currently selected.\n     * @group Props\n     */\n    set selection(val) {\n        this.d_selection = val;\n    }\n    get selection() {\n        return this.d_selection;\n    }\n    /**\n     * Array of values to be displayed in the component.\n     * It represents the data source for the list of items.\n     * @group Props\n     */\n    set value(val) {\n        this._value = val;\n        if (this.filterValue) {\n            this.filter();\n        }\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n     * Callback to invoke on selection change.\n     * @param {*} any - selection instance.\n     * @group Emits\n     */\n    selectionChange = new EventEmitter();\n    /**\n     * Callback to invoke when list is reordered.\n     * @param {*} any - list instance.\n     * @group Emits\n     */\n    onReorder = new EventEmitter();\n    /**\n     * Callback to invoke when selection changes.\n     * @param {OrderListSelectionChangeEvent} event - Custom change event.\n     * @group Emits\n     */\n    onSelectionChange = new EventEmitter();\n    /**\n     * Callback to invoke when filtering occurs.\n     * @param {OrderListFilterEvent} event - Custom filter event.\n     * @group Emits\n     */\n    onFilterEvent = new EventEmitter();\n    /**\n     * Callback to invoke when the list is focused\n     * @param {Event} event - Browser event.\n     * @group Emits\n     */\n    onFocus = new EventEmitter();\n    /**\n     * Callback to invoke when the list is blurred\n     * @param {Event} event - Browser event.\n     * @group Emits\n     */\n    onBlur = new EventEmitter();\n    listViewChild;\n    filterViewChild;\n    templates;\n    itemTemplate;\n    headerTemplate;\n    emptyMessageTemplate;\n    emptyFilterMessageTemplate;\n    filterTemplate;\n    get moveUpAriaLabel() {\n        return this.config.translation.aria ? this.config.translation.aria.moveUp : undefined;\n    }\n    get moveTopAriaLabel() {\n        return this.config.translation.aria ? this.config.translation.aria.moveTop : undefined;\n    }\n    get moveDownAriaLabel() {\n        return this.config.translation.aria ? this.config.translation.aria.moveDown : undefined;\n    }\n    get moveBottomAriaLabel() {\n        return this.config.translation.aria ? this.config.translation.aria.moveBottom : undefined;\n    }\n    moveUpIconTemplate;\n    moveTopIconTemplate;\n    moveDownIconTemplate;\n    moveBottomIconTemplate;\n    filterIconTemplate;\n    filterOptions;\n    d_selection = [];\n    movedUp;\n    movedDown;\n    itemTouched;\n    styleElement;\n    id = UniqueComponentId();\n    focused = false;\n    focusedOptionIndex = -1;\n    focusedOption;\n    filterValue;\n    visibleOptions;\n    _value;\n    constructor(document, platformId, renderer, el, cd, filterService, config) {\n        this.document = document;\n        this.platformId = platformId;\n        this.renderer = renderer;\n        this.el = el;\n        this.cd = cd;\n        this.filterService = filterService;\n        this.config = config;\n    }\n    ngOnInit() {\n        if (this.responsive) {\n            this.createStyle();\n        }\n        if (this.filterBy) {\n            this.filterOptions = {\n                filter: (value) => this.onFilterKeyup(value),\n                reset: () => this.resetFilter()\n            };\n        }\n    }\n    ngAfterContentInit() {\n        this.templates.forEach((item) => {\n            switch (item.getType()) {\n                case 'item':\n                    this.itemTemplate = item.template;\n                    break;\n                case 'empty':\n                    this.emptyMessageTemplate = item.template;\n                    break;\n                case 'emptyfilter':\n                    this.emptyFilterMessageTemplate = item.template;\n                    break;\n                case 'filter':\n                    this.filterTemplate = item.template;\n                    break;\n                case 'header':\n                    this.headerTemplate = item.template;\n                    break;\n                case 'moveupicon':\n                    this.moveUpIconTemplate = item.template;\n                    break;\n                case 'movetopicon':\n                    this.moveTopIconTemplate = item.template;\n                    break;\n                case 'movedownicon':\n                    this.moveDownIconTemplate = item.template;\n                    break;\n                case 'movebottomicon':\n                    this.moveBottomIconTemplate = item.template;\n                    break;\n                case 'filtericon':\n                    this.filterIconTemplate = item.template;\n                    break;\n                default:\n                    this.itemTemplate = item.template;\n                    break;\n            }\n        });\n    }\n    ngAfterViewChecked() {\n        if (this.movedUp || this.movedDown) {\n            let listItems = DomHandler.find(this.listViewChild?.nativeElement, 'li.p-highlight');\n            let listItem;\n            if (listItems.length > 0) {\n                if (this.movedUp)\n                    listItem = listItems[0];\n                else\n                    listItem = listItems[listItems.length - 1];\n                DomHandler.scrollInView(this.listViewChild?.nativeElement, listItem);\n            }\n            this.movedUp = false;\n            this.movedDown = false;\n        }\n    }\n    onItemClick(event, item, index, selectedId) {\n        this.itemTouched = false;\n        let focusedIndex = index ? index : ObjectUtils.findIndexInList(this.focusedOption, this.value);\n        let selectedIndex = ObjectUtils.findIndexInList(item, this.d_selection);\n        let selected = selectedIndex !== -1;\n        let metaSelection = this.itemTouched ? false : this.metaKeySelection;\n        if (selectedId) {\n            this.focusedOptionIndex = selectedId;\n        }\n        if (metaSelection) {\n            let metaKey = event.metaKey || event.ctrlKey;\n            if (selected && metaKey) {\n                this.d_selection = this.d_selection.filter((val, focusedIndex) => focusedIndex !== selectedIndex);\n            }\n            else {\n                this.d_selection = metaKey ? (this.d_selection ? [...this.d_selection] : []) : [];\n                ObjectUtils.insertIntoOrderedArray(item, focusedIndex, this.d_selection, this.value);\n            }\n        }\n        else {\n            if (selected) {\n                this.d_selection = this.d_selection.filter((val, focusedIndex) => focusedIndex !== selectedIndex);\n            }\n            else {\n                this.d_selection = this.d_selection ? [...this.d_selection] : [];\n                ObjectUtils.insertIntoOrderedArray(item, focusedIndex, this.d_selection, this.value);\n            }\n        }\n        //binding\n        this.selectionChange.emit(this.d_selection);\n        //event\n        this.onSelectionChange.emit({ originalEvent: event, value: this.d_selection });\n    }\n    onFilterKeyup(event) {\n        this.filterValue = event.target.value.trim().toLocaleLowerCase(this.filterLocale);\n        this.filter();\n        this.onFilterEvent.emit({\n            originalEvent: event,\n            value: this.visibleOptions\n        });\n    }\n    filter() {\n        let searchFields = this.filterBy.split(',');\n        this.visibleOptions = this.filterService.filter(this.value, searchFields, this.filterValue, this.filterMatchMode, this.filterLocale);\n    }\n    /**\n     * Callback to invoke on filter reset.\n     * @group Method\n     */\n    resetFilter() {\n        this.filterValue = null;\n        this.filterViewChild && (this.filterViewChild.nativeElement.value = '');\n    }\n    isItemVisible(item) {\n        if (this.filterValue && this.filterValue.trim().length) {\n            for (let i = 0; i < this.visibleOptions.length; i++) {\n                if (item == this.visibleOptions[i]) {\n                    return true;\n                }\n            }\n        }\n        else {\n            return true;\n        }\n    }\n    onItemTouchEnd() {\n        this.itemTouched = true;\n    }\n    isSelected(item) {\n        return ObjectUtils.findIndexInList(item, this.d_selection) !== -1;\n    }\n    isEmpty() {\n        return this.filterValue ? !this.visibleOptions || this.visibleOptions.length === 0 : !this.value || this.value.length === 0;\n    }\n    moveUp() {\n        if (this.selection) {\n            for (let i = 0; i < this.selection.length; i++) {\n                let selectedItem = this.selection[i];\n                let selectedItemIndex = ObjectUtils.findIndexInList(selectedItem, this.value);\n                if (selectedItemIndex != 0 && this.value instanceof Array) {\n                    let movedItem = this.value[selectedItemIndex];\n                    let temp = this.value[selectedItemIndex - 1];\n                    this.value[selectedItemIndex - 1] = movedItem;\n                    this.value[selectedItemIndex] = temp;\n                }\n                else {\n                    break;\n                }\n            }\n            if (this.dragdrop && this.filterValue)\n                this.filter();\n            this.movedUp = true;\n            this.onReorder.emit(this.selection);\n        }\n    }\n    moveTop() {\n        if (this.selection) {\n            for (let i = this.selection.length - 1; i >= 0; i--) {\n                let selectedItem = this.selection[i];\n                let selectedItemIndex = ObjectUtils.findIndexInList(selectedItem, this.value);\n                if (selectedItemIndex != 0 && this.value instanceof Array) {\n                    let movedItem = this.value.splice(selectedItemIndex, 1)[0];\n                    this.value.unshift(movedItem);\n                }\n                else {\n                    break;\n                }\n            }\n            if (this.dragdrop && this.filterValue)\n                this.filter();\n            this.onReorder.emit(this.selection);\n            this.listViewChild.nativeElement.scrollTop = 0;\n        }\n    }\n    moveDown() {\n        if (this.selection) {\n            for (let i = this.selection.length - 1; i >= 0; i--) {\n                let selectedItem = this.selection[i];\n                let selectedItemIndex = ObjectUtils.findIndexInList(selectedItem, this.value);\n                if (this.value instanceof Array && selectedItemIndex != this.value.length - 1) {\n                    let movedItem = this.value[selectedItemIndex];\n                    let temp = this.value[selectedItemIndex + 1];\n                    this.value[selectedItemIndex + 1] = movedItem;\n                    this.value[selectedItemIndex] = temp;\n                }\n                else {\n                    break;\n                }\n            }\n            if (this.dragdrop && this.filterValue)\n                this.filter();\n            this.movedDown = true;\n            this.onReorder.emit(this.selection);\n        }\n    }\n    moveBottom() {\n        if (this.selection) {\n            for (let i = 0; i < this.selection.length; i++) {\n                let selectedItem = this.selection[i];\n                let selectedItemIndex = ObjectUtils.findIndexInList(selectedItem, this.value);\n                if (this.value instanceof Array && selectedItemIndex != this.value.length - 1) {\n                    let movedItem = this.value.splice(selectedItemIndex, 1)[0];\n                    this.value.push(movedItem);\n                }\n                else {\n                    break;\n                }\n            }\n            if (this.dragdrop && this.filterValue)\n                this.filter();\n            this.onReorder.emit(this.selection);\n            this.listViewChild.nativeElement.scrollTop = this.listViewChild?.nativeElement.scrollHeight;\n        }\n    }\n    onDrop(event) {\n        let previousIndex = event.previousIndex;\n        let currentIndex = event.currentIndex;\n        if (previousIndex !== currentIndex) {\n            if (this.visibleOptions) {\n                if (this.filterValue) {\n                    previousIndex = ObjectUtils.findIndexInList(event.item.data, this.value);\n                    currentIndex = ObjectUtils.findIndexInList(this.visibleOptions[currentIndex], this.value);\n                }\n                moveItemInArray(this.visibleOptions, event.previousIndex, event.currentIndex);\n            }\n            moveItemInArray(this.value, previousIndex, currentIndex);\n            this.changeFocusedOptionIndex(currentIndex);\n            this.onReorder.emit([event.item.data]);\n        }\n    }\n    onListFocus(event) {\n        const focusableEl = DomHandler.findSingle(this.listViewChild.nativeElement, '[data-p-highlight=\"true\"]') || DomHandler.findSingle(this.listViewChild.nativeElement, '[data-pc-section=\"item\"]');\n        if (focusableEl) {\n            const findIndex = ObjectUtils.findIndexInList(focusableEl, this.listViewChild.nativeElement.children);\n            this.focused = true;\n            const index = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : focusableEl ? findIndex : -1;\n            this.changeFocusedOptionIndex(index);\n        }\n        this.onFocus.emit(event);\n    }\n    onListBlur(event) {\n        this.focused = false;\n        this.focusedOption = null;\n        this.focusedOptionIndex = -1;\n        this.onBlur.emit(event);\n    }\n    onItemKeydown(event) {\n        switch (event.code) {\n            case 'ArrowDown':\n                this.onArrowDownKey(event);\n                break;\n            case 'ArrowUp':\n                this.onArrowUpKey(event);\n                break;\n            case 'Home':\n                this.onHomeKey(event);\n                break;\n            case 'End':\n                this.onEndKey(event);\n                break;\n            case 'Enter':\n                this.onEnterKey(event);\n                break;\n            case 'Space':\n                this.onSpaceKey(event);\n                break;\n            case 'KeyA':\n                if (event.ctrlKey) {\n                    this.d_selection = [...this.value];\n                    this.selectionChange.emit(this.d_selection);\n                }\n            default:\n                break;\n        }\n    }\n    onOptionMouseDown(index) {\n        this.focused = true;\n        this.focusedOptionIndex = index;\n    }\n    onArrowDownKey(event) {\n        const optionIndex = this.findNextOptionIndex(this.focusedOptionIndex);\n        this.changeFocusedOptionIndex(optionIndex);\n        if (event.shiftKey) {\n            this.onEnterKey(event);\n        }\n        event.preventDefault();\n    }\n    onArrowUpKey(event) {\n        const optionIndex = this.findPrevOptionIndex(this.focusedOptionIndex);\n        this.changeFocusedOptionIndex(optionIndex);\n        if (event.shiftKey) {\n            this.onEnterKey(event);\n        }\n        event.preventDefault();\n    }\n    onHomeKey(event) {\n        if (event.ctrlKey && event.shiftKey) {\n            let visibleOptions = this.getVisibleOptions();\n            let focusedIndex = ObjectUtils.findIndexInList(this.focusedOption, visibleOptions);\n            this.d_selection = [...this.value].slice(0, focusedIndex + 1);\n            this.selectionChange.emit(this.d_selection);\n        }\n        else {\n            this.changeFocusedOptionIndex(0);\n        }\n        event.preventDefault();\n    }\n    onEndKey(event) {\n        if (event.ctrlKey && event.shiftKey) {\n            let visibleOptions = this.getVisibleOptions();\n            let focusedIndex = ObjectUtils.findIndexInList(this.focusedOption, visibleOptions);\n            this.d_selection = [...this.value].slice(focusedIndex, visibleOptions.length - 1);\n            this.selectionChange.emit(this.d_selection);\n        }\n        else {\n            this.changeFocusedOptionIndex(DomHandler.find(this.listViewChild.nativeElement, '[data-pc-section=\"item\"]').length - 1);\n        }\n        event.preventDefault();\n    }\n    onEnterKey(event) {\n        this.onItemClick(event, this.focusedOption);\n        event.preventDefault();\n    }\n    onSpaceKey(event) {\n        event.preventDefault();\n        if (event.shiftKey && this.selection && this.selection.length > 0) {\n            let visibleOptions = this.getVisibleOptions();\n            let lastSelectedIndex = this.getLatestSelectedVisibleOptionIndex(visibleOptions);\n            if (lastSelectedIndex !== -1) {\n                let focusedIndex = ObjectUtils.findIndexInList(this.focusedOption, visibleOptions);\n                this.d_selection = [...visibleOptions.slice(Math.min(lastSelectedIndex, focusedIndex), Math.max(lastSelectedIndex, focusedIndex) + 1)];\n                this.selectionChange.emit(this.d_selection);\n                this.onSelectionChange.emit({ originalEvent: event, value: this.d_selection });\n                return;\n            }\n        }\n        this.onEnterKey(event);\n    }\n    findNextOptionIndex(index) {\n        const items = DomHandler.find(this.listViewChild.nativeElement, '[data-pc-section=\"item\"]');\n        const matchedOptionIndex = [...items].findIndex((link) => link.id === index);\n        return matchedOptionIndex > -1 ? matchedOptionIndex + 1 : 0;\n    }\n    findPrevOptionIndex(index) {\n        const items = DomHandler.find(this.listViewChild.nativeElement, '[data-pc-section=\"item\"]');\n        const matchedOptionIndex = [...items].findIndex((link) => link.id === index);\n        return matchedOptionIndex > -1 ? matchedOptionIndex - 1 : 0;\n    }\n    getLatestSelectedVisibleOptionIndex(visibleOptions) {\n        const latestSelectedItem = [...this.d_selection].reverse().find((item) => visibleOptions.includes(item));\n        return latestSelectedItem !== undefined ? visibleOptions.indexOf(latestSelectedItem) : -1;\n    }\n    getVisibleOptions() {\n        return this.visibleOptions && this.visibleOptions.length > 0 ? this.visibleOptions : this.value && this.value.length > 0 ? this.value : null;\n    }\n    getFocusedOption(index) {\n        if (index === -1)\n            return null;\n        return this.visibleOptions && this.visibleOptions.length ? this.visibleOptions[index] : this.value && this.value.length ? this.value[index] : null;\n    }\n    changeFocusedOptionIndex(index) {\n        const items = DomHandler.find(this.listViewChild.nativeElement, '[data-pc-section=\"item\"]');\n        let order = index >= items.length ? items.length - 1 : index < 0 ? 0 : index;\n        this.focusedOptionIndex = items[order] ? items[order].getAttribute('id') : -1;\n        this.focusedOption = this.getFocusedOption(order);\n        this.scrollInView(this.focusedOptionIndex);\n    }\n    scrollInView(id) {\n        const element = DomHandler.findSingle(this.listViewChild.nativeElement, `[data-pc-section=\"item\"][id=\"${id}\"]`);\n        if (element) {\n            element.scrollIntoView && element.scrollIntoView({ block: 'nearest', inline: 'nearest' });\n        }\n    }\n    findNextItem(item) {\n        let nextItem = item.nextElementSibling;\n        if (nextItem)\n            return !DomHandler.hasClass(nextItem, 'p-orderlist-item') || DomHandler.isHidden(nextItem) ? this.findNextItem(nextItem) : nextItem;\n        else\n            return null;\n    }\n    findPrevItem(item) {\n        let prevItem = item.previousElementSibling;\n        if (prevItem)\n            return !DomHandler.hasClass(prevItem, 'p-orderlist-item') || DomHandler.isHidden(prevItem) ? this.findPrevItem(prevItem) : prevItem;\n        else\n            return null;\n    }\n    moveDisabled() {\n        if (this.disabled || !this.selection.length) {\n            return true;\n        }\n    }\n    focusedOptionId() {\n        return this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : null;\n    }\n    createStyle() {\n        if (isPlatformBrowser(this.platformId)) {\n            if (!this.styleElement) {\n                this.renderer.setAttribute(this.el.nativeElement.children[0], this.id, '');\n                this.styleElement = this.renderer.createElement('style');\n                this.renderer.setAttribute(this.styleElement, 'type', 'text/css');\n                this.renderer.appendChild(this.document.head, this.styleElement);\n                let innerHTML = `\n                    @media screen and (max-width: ${this.breakpoint}) {\n                        .p-orderlist[${this.id}] {\n                            flex-direction: column;\n                        }\n\n                        .p-orderlist[${this.id}] .p-orderlist-controls {\n                            padding: var(--content-padding);\n                            flex-direction: row;\n                        }\n\n                        .p-orderlist[${this.id}] .p-orderlist-controls .p-button {\n                            margin-right: var(--inline-spacing);\n                            margin-bottom: 0;\n                        }\n\n                        .p-orderlist[${this.id}] .p-orderlist-controls .p-button:last-child {\n                            margin-right: 0;\n                        }\n                    }\n                `;\n                this.renderer.setProperty(this.styleElement, 'innerHTML', innerHTML);\n            }\n        }\n    }\n    destroyStyle() {\n        if (isPlatformBrowser(this.platformId)) {\n            if (this.styleElement) {\n                this.renderer.removeChild(this.document, this.styleElement);\n                this.styleElement = null;\n                ``;\n            }\n        }\n    }\n    ngOnDestroy() {\n        this.destroyStyle();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: OrderList, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i1.FilterService }, { token: i1.PrimeNGConfig }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.0.5\", type: OrderList, selector: \"p-orderList\", inputs: { header: \"header\", style: \"style\", styleClass: \"styleClass\", tabindex: \"tabindex\", ariaLabel: \"ariaLabel\", ariaLabelledBy: \"ariaLabelledBy\", listStyle: \"listStyle\", responsive: \"responsive\", filterBy: \"filterBy\", filterPlaceholder: \"filterPlaceholder\", filterLocale: \"filterLocale\", metaKeySelection: \"metaKeySelection\", dragdrop: \"dragdrop\", controlsPosition: \"controlsPosition\", ariaFilterLabel: \"ariaFilterLabel\", filterMatchMode: \"filterMatchMode\", breakpoint: \"breakpoint\", stripedRows: \"stripedRows\", disabled: \"disabled\", trackBy: \"trackBy\", selection: \"selection\", value: \"value\" }, outputs: { selectionChange: \"selectionChange\", onReorder: \"onReorder\", onSelectionChange: \"onSelectionChange\", onFilterEvent: \"onFilterEvent\", onFocus: \"onFocus\", onBlur: \"onBlur\" }, host: { classAttribute: \"p-element\" }, queries: [{ propertyName: \"templates\", predicate: PrimeTemplate }], viewQueries: [{ propertyName: \"listViewChild\", first: true, predicate: [\"listelement\"], descendants: true }, { propertyName: \"filterViewChild\", first: true, predicate: [\"filter\"], descendants: true }], ngImport: i0, template: `\n        <div\n            [ngClass]=\"{ 'p-orderlist p-component': true, 'p-orderlist-striped': stripedRows, 'p-orderlist-controls-left': controlsPosition === 'left', 'p-orderlist-controls-right': controlsPosition === 'right' }\"\n            [ngStyle]=\"style\"\n            [class]=\"styleClass\"\n            [attr.data-pc-section]=\"'root'\"\n        >\n            <div class=\"p-orderlist-controls\" [attr.data-pc-section]=\"'controls'\">\n                <button type=\"button\" [disabled]=\"moveDisabled()\" pButton pRipple class=\"p-button-icon-only\" (click)=\"moveUp()\" [attr.aria-label]=\"moveUpAriaLabel\" [attr.data-pc-section]=\"'moveUpButton'\">\n                    <AngleUpIcon *ngIf=\"!moveUpIconTemplate\" [attr.data-pc-section]=\"'moveupicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveUpIconTemplate\"></ng-template>\n                </button>\n                <button type=\"button\" [disabled]=\"moveDisabled()\" pButton pRipple class=\"p-button-icon-only\" (click)=\"moveTop()\" [attr.aria-label]=\"moveTopAriaLabel\" [attr.data-pc-section]=\"'moveTopButton'\">\n                    <AngleDoubleUpIcon *ngIf=\"!moveTopIconTemplate\" [attr.data-pc-section]=\"'movetopicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveTopIconTemplate\"></ng-template>\n                </button>\n                <button type=\"button\" [disabled]=\"moveDisabled()\" pButton pRipple class=\"p-button-icon-only\" (click)=\"moveDown()\" [attr.aria-label]=\"moveDownAriaLabel\" [attr.data-pc-section]=\"'moveDownButton'\">\n                    <AngleDownIcon *ngIf=\"!moveDownIconTemplate\" [attr.data-pc-section]=\"'movedownicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveDownIconTemplate\"></ng-template>\n                </button>\n                <button type=\"button\" [disabled]=\"moveDisabled()\" pButton pRipple class=\"p-button-icon-only\" (click)=\"moveBottom()\" [attr.aria-label]=\"moveBottomAriaLabel\" [attr.data-pc-section]=\"'moveBottomButton'\">\n                    <AngleDoubleDownIcon *ngIf=\"!moveBottomIconTemplate\" [attr.data-pc-section]=\"'movebottomicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveBottomIconTemplate\"></ng-template>\n                </button>\n            </div>\n            <div class=\"p-orderlist-list-container\" [attr.data-pc-section]=\"'container'\">\n                <div class=\"p-orderlist-header\" *ngIf=\"header || headerTemplate\" [attr.data-pc-section]=\"'header'\">\n                    <div class=\"p-orderlist-title\" *ngIf=\"!headerTemplate\">{{ header }}</div>\n                    <ng-container *ngTemplateOutlet=\"headerTemplate\"></ng-container>\n                </div>\n                <div class=\"p-orderlist-filter-container\" *ngIf=\"filterBy\" [attr.data-pc-section]=\"'filterContainer'\">\n                    <ng-container *ngIf=\"filterTemplate; else builtInFilterElement\">\n                        <ng-container *ngTemplateOutlet=\"filterTemplate; context: { options: filterOptions }\"></ng-container>\n                    </ng-container>\n                    <ng-template #builtInFilterElement>\n                        <div class=\"p-orderlist-filter\" [attr.data-pc-section]=\"'filter'\">\n                            <input\n                                #filter\n                                type=\"text\"\n                                role=\"textbox\"\n                                (keyup)=\"onFilterKeyup($event)\"\n                                [disabled]=\"disabled\"\n                                class=\"p-orderlist-filter-input p-inputtext p-component\"\n                                [attr.placeholder]=\"filterPlaceholder\"\n                                [attr.aria-label]=\"ariaFilterLabel\"\n                            />\n                            <SearchIcon *ngIf=\"!filterIconTemplate\" [styleClass]=\"'p-orderlist-filter-icon'\" [attr.data-pc-section]=\"'filterIcon'\" />\n                            <span class=\"p-orderlist-filter-icon\" *ngIf=\"filterIconTemplate\" [attr.data-pc-section]=\"'filterIcon'\">\n                                <ng-template *ngTemplateOutlet=\"filterIconTemplate\"></ng-template>\n                            </span>\n                        </div>\n                    </ng-template>\n                </div>\n                <ul\n                    #listelement\n                    [id]=\"id + '_list'\"\n                    cdkDropList\n                    (cdkDropListDropped)=\"onDrop($event)\"\n                    class=\"p-orderlist-list\"\n                    [ngStyle]=\"listStyle\"\n                    [attr.data-pc-section]=\"'list'\"\n                    role=\"listbox\"\n                    [tabindex]=\"tabindex\"\n                    aria-multiselectable=\"true\"\n                    [attr.aria-activedescendant]=\"focused ? focusedOptionId() : undefined\"\n                    [attr.aria-label]=\"ariaLabel\"\n                    [attr.aria-labelledby]=\"ariaLabelledBy\"\n                    (focus)=\"onListFocus($event)\"\n                    (blur)=\"onListBlur($event)\"\n                    (keydown)=\"onItemKeydown($event)\"\n                >\n                    <ng-template ngFor [ngForTrackBy]=\"trackBy\" let-item [ngForOf]=\"value\" let-i=\"index\" let-l=\"last\">\n                        <li\n                            [id]=\"id + '_' + i\"\n                            pRipple\n                            cdkDrag\n                            role=\"option\"\n                            class=\"p-orderlist-item\"\n                            [ngClass]=\"{ 'p-highlight': isSelected(item), 'p-disabled': disabled, 'p-focus': id + '_' + i === focusedOptionId() }\"\n                            [cdkDragData]=\"item\"\n                            [cdkDragDisabled]=\"!dragdrop\"\n                            (click)=\"onItemClick($event, item, i, id + '_' + i)\"\n                            (touchend)=\"onItemTouchEnd()\"\n                            (mousedown)=\"onOptionMouseDown(i)\"\n                            *ngIf=\"isItemVisible(item)\"\n                            [attr.aria-selected]=\"isSelected(item)\"\n                            [attr.data-pc-section]=\"'item'\"\n                            [attr.data-p-highlight]=\"isSelected(item)\"\n                            [attr.data-p-focused]=\"id + '_' + i === focusedOptionId()\"\n                        >\n                            <ng-container *ngTemplateOutlet=\"itemTemplate; context: { $implicit: item, index: i }\"></ng-container>\n                        </li>\n                    </ng-template>\n                    <ng-container *ngIf=\"isEmpty() && (emptyMessageTemplate || emptyFilterMessageTemplate)\">\n                        <li *ngIf=\"!filterValue || !emptyFilterMessageTemplate\" class=\"p-orderlist-empty-message\" [attr.data-pc-section]=\"'emptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyMessageTemplate\"></ng-container>\n                        </li>\n                        <li *ngIf=\"filterValue\" class=\"p-orderlist-empty-message\" [attr.data-pc-section]=\"'emptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyFilterMessageTemplate\"></ng-container>\n                        </li>\n                    </ng-container>\n                </ul>\n            </div>\n        </div>\n    `, isInline: true, styles: [\"@layer primeng{.p-orderlist{display:flex}.p-orderlist-controls{display:flex;flex-direction:column;justify-content:center}.p-orderlist-list-container{flex:1 1 auto}.p-orderlist-list{list-style-type:none;margin:0;padding:0;overflow:auto;min-height:12rem}.p-orderlist-item{display:block;cursor:pointer;overflow:hidden;position:relative}.p-orderlist-item:not(.cdk-drag-disabled){cursor:move}.p-orderlist-item.cdk-drag-placeholder{opacity:0}.p-orderlist-item.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.p-orderlist.p-state-disabled .p-orderlist-item,.p-orderlist.p-state-disabled .p-button{cursor:default}.p-orderlist.p-state-disabled .p-orderlist-list{overflow:hidden}.p-orderlist-filter{position:relative}.p-orderlist-filter-icon{position:absolute;top:50%;margin-top:-.5rem;cursor:pointer}.p-orderlist-filter-input{width:100%}.p-orderlist-controls-right .p-orderlist-controls{order:2}.p-orderlist-controls-right .p-orderlist-list-container{order:1}.p-orderlist-list.cdk-drop-list-dragging .p-orderlist-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}}\\n\"], dependencies: [{ kind: \"directive\", type: i0.forwardRef(() => i2.NgClass), selector: \"[ngClass]\", inputs: [\"class\", \"ngClass\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgForOf), selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgIf), selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgTemplateOutlet), selector: \"[ngTemplateOutlet]\", inputs: [\"ngTemplateOutletContext\", \"ngTemplateOutlet\", \"ngTemplateOutletInjector\"] }, { kind: \"directive\", type: i0.forwardRef(() => i2.NgStyle), selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }, { kind: \"directive\", type: i0.forwardRef(() => i3.ButtonDirective), selector: \"[pButton]\", inputs: [\"iconPos\", \"loadingIcon\", \"label\", \"icon\", \"loading\"] }, { kind: \"directive\", type: i0.forwardRef(() => i4.Ripple), selector: \"[pRipple]\" }, { kind: \"directive\", type: i0.forwardRef(() => i5.CdkDropList), selector: \"[cdkDropList], cdk-drop-list\", inputs: [\"cdkDropListConnectedTo\", \"cdkDropListData\", \"cdkDropListOrientation\", \"id\", \"cdkDropListLockAxis\", \"cdkDropListDisabled\", \"cdkDropListSortingDisabled\", \"cdkDropListEnterPredicate\", \"cdkDropListSortPredicate\", \"cdkDropListAutoScrollDisabled\", \"cdkDropListAutoScrollStep\"], outputs: [\"cdkDropListDropped\", \"cdkDropListEntered\", \"cdkDropListExited\", \"cdkDropListSorted\"], exportAs: [\"cdkDropList\"] }, { kind: \"directive\", type: i0.forwardRef(() => i5.CdkDrag), selector: \"[cdkDrag]\", inputs: [\"cdkDragData\", \"cdkDragLockAxis\", \"cdkDragRootElement\", \"cdkDragBoundary\", \"cdkDragStartDelay\", \"cdkDragFreeDragPosition\", \"cdkDragDisabled\", \"cdkDragConstrainPosition\", \"cdkDragPreviewClass\", \"cdkDragPreviewContainer\"], outputs: [\"cdkDragStarted\", \"cdkDragReleased\", \"cdkDragEnded\", \"cdkDragEntered\", \"cdkDragExited\", \"cdkDragDropped\", \"cdkDragMoved\"], exportAs: [\"cdkDrag\"] }, { kind: \"component\", type: i0.forwardRef(() => AngleDoubleDownIcon), selector: \"AngleDoubleDownIcon\" }, { kind: \"component\", type: i0.forwardRef(() => AngleDoubleUpIcon), selector: \"AngleDoubleUpIcon\" }, { kind: \"component\", type: i0.forwardRef(() => AngleUpIcon), selector: \"AngleUpIcon\" }, { kind: \"component\", type: i0.forwardRef(() => AngleDownIcon), selector: \"AngleDownIcon\" }, { kind: \"component\", type: i0.forwardRef(() => SearchIcon), selector: \"SearchIcon\" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: OrderList, decorators: [{\n            type: Component,\n            args: [{ selector: 'p-orderList', template: `\n        <div\n            [ngClass]=\"{ 'p-orderlist p-component': true, 'p-orderlist-striped': stripedRows, 'p-orderlist-controls-left': controlsPosition === 'left', 'p-orderlist-controls-right': controlsPosition === 'right' }\"\n            [ngStyle]=\"style\"\n            [class]=\"styleClass\"\n            [attr.data-pc-section]=\"'root'\"\n        >\n            <div class=\"p-orderlist-controls\" [attr.data-pc-section]=\"'controls'\">\n                <button type=\"button\" [disabled]=\"moveDisabled()\" pButton pRipple class=\"p-button-icon-only\" (click)=\"moveUp()\" [attr.aria-label]=\"moveUpAriaLabel\" [attr.data-pc-section]=\"'moveUpButton'\">\n                    <AngleUpIcon *ngIf=\"!moveUpIconTemplate\" [attr.data-pc-section]=\"'moveupicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveUpIconTemplate\"></ng-template>\n                </button>\n                <button type=\"button\" [disabled]=\"moveDisabled()\" pButton pRipple class=\"p-button-icon-only\" (click)=\"moveTop()\" [attr.aria-label]=\"moveTopAriaLabel\" [attr.data-pc-section]=\"'moveTopButton'\">\n                    <AngleDoubleUpIcon *ngIf=\"!moveTopIconTemplate\" [attr.data-pc-section]=\"'movetopicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveTopIconTemplate\"></ng-template>\n                </button>\n                <button type=\"button\" [disabled]=\"moveDisabled()\" pButton pRipple class=\"p-button-icon-only\" (click)=\"moveDown()\" [attr.aria-label]=\"moveDownAriaLabel\" [attr.data-pc-section]=\"'moveDownButton'\">\n                    <AngleDownIcon *ngIf=\"!moveDownIconTemplate\" [attr.data-pc-section]=\"'movedownicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveDownIconTemplate\"></ng-template>\n                </button>\n                <button type=\"button\" [disabled]=\"moveDisabled()\" pButton pRipple class=\"p-button-icon-only\" (click)=\"moveBottom()\" [attr.aria-label]=\"moveBottomAriaLabel\" [attr.data-pc-section]=\"'moveBottomButton'\">\n                    <AngleDoubleDownIcon *ngIf=\"!moveBottomIconTemplate\" [attr.data-pc-section]=\"'movebottomicon'\" />\n                    <ng-template *ngTemplateOutlet=\"moveBottomIconTemplate\"></ng-template>\n                </button>\n            </div>\n            <div class=\"p-orderlist-list-container\" [attr.data-pc-section]=\"'container'\">\n                <div class=\"p-orderlist-header\" *ngIf=\"header || headerTemplate\" [attr.data-pc-section]=\"'header'\">\n                    <div class=\"p-orderlist-title\" *ngIf=\"!headerTemplate\">{{ header }}</div>\n                    <ng-container *ngTemplateOutlet=\"headerTemplate\"></ng-container>\n                </div>\n                <div class=\"p-orderlist-filter-container\" *ngIf=\"filterBy\" [attr.data-pc-section]=\"'filterContainer'\">\n                    <ng-container *ngIf=\"filterTemplate; else builtInFilterElement\">\n                        <ng-container *ngTemplateOutlet=\"filterTemplate; context: { options: filterOptions }\"></ng-container>\n                    </ng-container>\n                    <ng-template #builtInFilterElement>\n                        <div class=\"p-orderlist-filter\" [attr.data-pc-section]=\"'filter'\">\n                            <input\n                                #filter\n                                type=\"text\"\n                                role=\"textbox\"\n                                (keyup)=\"onFilterKeyup($event)\"\n                                [disabled]=\"disabled\"\n                                class=\"p-orderlist-filter-input p-inputtext p-component\"\n                                [attr.placeholder]=\"filterPlaceholder\"\n                                [attr.aria-label]=\"ariaFilterLabel\"\n                            />\n                            <SearchIcon *ngIf=\"!filterIconTemplate\" [styleClass]=\"'p-orderlist-filter-icon'\" [attr.data-pc-section]=\"'filterIcon'\" />\n                            <span class=\"p-orderlist-filter-icon\" *ngIf=\"filterIconTemplate\" [attr.data-pc-section]=\"'filterIcon'\">\n                                <ng-template *ngTemplateOutlet=\"filterIconTemplate\"></ng-template>\n                            </span>\n                        </div>\n                    </ng-template>\n                </div>\n                <ul\n                    #listelement\n                    [id]=\"id + '_list'\"\n                    cdkDropList\n                    (cdkDropListDropped)=\"onDrop($event)\"\n                    class=\"p-orderlist-list\"\n                    [ngStyle]=\"listStyle\"\n                    [attr.data-pc-section]=\"'list'\"\n                    role=\"listbox\"\n                    [tabindex]=\"tabindex\"\n                    aria-multiselectable=\"true\"\n                    [attr.aria-activedescendant]=\"focused ? focusedOptionId() : undefined\"\n                    [attr.aria-label]=\"ariaLabel\"\n                    [attr.aria-labelledby]=\"ariaLabelledBy\"\n                    (focus)=\"onListFocus($event)\"\n                    (blur)=\"onListBlur($event)\"\n                    (keydown)=\"onItemKeydown($event)\"\n                >\n                    <ng-template ngFor [ngForTrackBy]=\"trackBy\" let-item [ngForOf]=\"value\" let-i=\"index\" let-l=\"last\">\n                        <li\n                            [id]=\"id + '_' + i\"\n                            pRipple\n                            cdkDrag\n                            role=\"option\"\n                            class=\"p-orderlist-item\"\n                            [ngClass]=\"{ 'p-highlight': isSelected(item), 'p-disabled': disabled, 'p-focus': id + '_' + i === focusedOptionId() }\"\n                            [cdkDragData]=\"item\"\n                            [cdkDragDisabled]=\"!dragdrop\"\n                            (click)=\"onItemClick($event, item, i, id + '_' + i)\"\n                            (touchend)=\"onItemTouchEnd()\"\n                            (mousedown)=\"onOptionMouseDown(i)\"\n                            *ngIf=\"isItemVisible(item)\"\n                            [attr.aria-selected]=\"isSelected(item)\"\n                            [attr.data-pc-section]=\"'item'\"\n                            [attr.data-p-highlight]=\"isSelected(item)\"\n                            [attr.data-p-focused]=\"id + '_' + i === focusedOptionId()\"\n                        >\n                            <ng-container *ngTemplateOutlet=\"itemTemplate; context: { $implicit: item, index: i }\"></ng-container>\n                        </li>\n                    </ng-template>\n                    <ng-container *ngIf=\"isEmpty() && (emptyMessageTemplate || emptyFilterMessageTemplate)\">\n                        <li *ngIf=\"!filterValue || !emptyFilterMessageTemplate\" class=\"p-orderlist-empty-message\" [attr.data-pc-section]=\"'emptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyMessageTemplate\"></ng-container>\n                        </li>\n                        <li *ngIf=\"filterValue\" class=\"p-orderlist-empty-message\" [attr.data-pc-section]=\"'emptyMessage'\">\n                            <ng-container *ngTemplateOutlet=\"emptyFilterMessageTemplate\"></ng-container>\n                        </li>\n                    </ng-container>\n                </ul>\n            </div>\n        </div>\n    `, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, host: {\n                        class: 'p-element'\n                    }, styles: [\"@layer primeng{.p-orderlist{display:flex}.p-orderlist-controls{display:flex;flex-direction:column;justify-content:center}.p-orderlist-list-container{flex:1 1 auto}.p-orderlist-list{list-style-type:none;margin:0;padding:0;overflow:auto;min-height:12rem}.p-orderlist-item{display:block;cursor:pointer;overflow:hidden;position:relative}.p-orderlist-item:not(.cdk-drag-disabled){cursor:move}.p-orderlist-item.cdk-drag-placeholder{opacity:0}.p-orderlist-item.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.p-orderlist.p-state-disabled .p-orderlist-item,.p-orderlist.p-state-disabled .p-button{cursor:default}.p-orderlist.p-state-disabled .p-orderlist-list{overflow:hidden}.p-orderlist-filter{position:relative}.p-orderlist-filter-icon{position:absolute;top:50%;margin-top:-.5rem;cursor:pointer}.p-orderlist-filter-input{width:100%}.p-orderlist-controls-right .p-orderlist-controls{order:2}.p-orderlist-controls-right .p-orderlist-list-container{order:1}.p-orderlist-list.cdk-drop-list-dragging .p-orderlist-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}}\\n\"] }]\n        }], ctorParameters: () => [{ type: Document, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1.FilterService }, { type: i1.PrimeNGConfig }], propDecorators: { header: [{\n                type: Input\n            }], style: [{\n                type: Input\n            }], styleClass: [{\n                type: Input\n            }], tabindex: [{\n                type: Input\n            }], ariaLabel: [{\n                type: Input\n            }], ariaLabelledBy: [{\n                type: Input\n            }], listStyle: [{\n                type: Input\n            }], responsive: [{\n                type: Input\n            }], filterBy: [{\n                type: Input\n            }], filterPlaceholder: [{\n                type: Input\n            }], filterLocale: [{\n                type: Input\n            }], metaKeySelection: [{\n                type: Input\n            }], dragdrop: [{\n                type: Input\n            }], controlsPosition: [{\n                type: Input\n            }], ariaFilterLabel: [{\n                type: Input\n            }], filterMatchMode: [{\n                type: Input\n            }], breakpoint: [{\n                type: Input\n            }], stripedRows: [{\n                type: Input\n            }], disabled: [{\n                type: Input\n            }], trackBy: [{\n                type: Input\n            }], selection: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }], selectionChange: [{\n                type: Output\n            }], onReorder: [{\n                type: Output\n            }], onSelectionChange: [{\n                type: Output\n            }], onFilterEvent: [{\n                type: Output\n            }], onFocus: [{\n                type: Output\n            }], onBlur: [{\n                type: Output\n            }], listViewChild: [{\n                type: ViewChild,\n                args: ['listelement']\n            }], filterViewChild: [{\n                type: ViewChild,\n                args: ['filter']\n            }], templates: [{\n                type: ContentChildren,\n                args: [PrimeTemplate]\n            }] } });\nclass OrderListModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: OrderListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.5\", ngImport: i0, type: OrderListModule, declarations: [OrderList], imports: [CommonModule, ButtonModule, SharedModule, RippleModule, DragDropModule, AngleDoubleDownIcon, AngleDoubleUpIcon, AngleUpIcon, AngleDownIcon, SearchIcon], exports: [OrderList, SharedModule, DragDropModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: OrderListModule, imports: [CommonModule, ButtonModule, SharedModule, RippleModule, DragDropModule, AngleDoubleDownIcon, AngleDoubleUpIcon, AngleUpIcon, AngleDownIcon, SearchIcon, SharedModule, DragDropModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.5\", ngImport: i0, type: OrderListModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule, ButtonModule, SharedModule, RippleModule, DragDropModule, AngleDoubleDownIcon, AngleDoubleUpIcon, AngleUpIcon, AngleDownIcon, SearchIcon],\n                    exports: [OrderList, SharedModule, DragDropModule],\n                    declarations: [OrderList]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { OrderList, OrderListModule };\n","<div class=\"grid\">\r\n\t<div class=\"col-12\">\r\n\t\t<div class=\"card\">\r\n\t\t\t<h5>DataView</h5>\r\n\t\t\t<p-dataView #dv [value]=\"products\" [paginator]=\"true\" [rows]=\"9\" filterBy=\"name\" [sortField]=\"sortField\" [sortOrder]=\"sortOrder\" layout=\"grid\">\r\n\t\t\t\t<ng-template pTemplate=\"header\">\r\n\t\t\t\t\t<div class=\"flex flex-column md:flex-row md:justify-content-between gap-2\">\r\n\t\t\t\t\t\t<p-dropdown [options]=\"sortOptions\" placeholder=\"Sort By Price\" (onChange)=\"onSortChange($event)\"></p-dropdown>\r\n\t\t\t\t\t\t<span class=\"p-input-icon-left\">\r\n                            <i class=\"pi pi-search\"></i>\r\n                            <input type=\"search\" pInputText placeholder=\"Search by Name\" (input)=\"onFilter(dv, $event)\">\r\n                        </span>\t\r\n\t\t\t\t\t\t<p-dataViewLayoutOptions></p-dataViewLayoutOptions>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</ng-template>\r\n\r\n\t\t\t\t<ng-template let-products pTemplate=\"listItem\">\r\n\t\t\t\t\t<div class=\"col-12\" *ngFor=\"let product of products\">\r\n\t\t\t\t\t\t<div class=\"flex flex-column md:flex-row align-items-center p-3 w-full\">\r\n\t\t\t\t\t\t\t<img [src]=\"'assets/demo/images/product/' + product.image\" [alt]=\"product.name\" class=\"my-4 md:my-0 w-9 md:w-10rem shadow-2 mr-5\"/>\r\n\t\t\t\t\t\t\t<div class=\"flex-1 flex flex-column align-items-center text-center md:text-left\">\r\n\t\t\t\t\t\t\t\t<div class=\"font-bold text-2xl\">{{product.name}}</div>\r\n\t\t\t\t\t\t\t\t<div class=\"mb-2\">{{product.description}}</div>\r\n\t\t\t\t\t\t\t\t<p-rating [ngModel]=\"product.rating\" [readonly]=\"true\" [cancel]=\"false\" styleClass=\"mb-2\"></p-rating>\r\n\t\t\t\t\t\t\t\t<div class=\"flex align-items-center mt-2\">\r\n\t\t\t\t\t\t\t\t\t<i class=\"pi pi-tag mr-2\"></i>\r\n\t\t\t\t\t\t\t\t\t<span class=\"font-semibold\">{{product.category}}</span>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t<div class=\"flex flex-row md:flex-column justify-content-between w-full md:w-auto align-items-center md:align-items-end mt-5 md:mt-0\">\r\n\t\t\t\t\t\t\t\t<span class=\"text-2xl font-semibold mb-2 align-self-center md:align-self-end\">${{product.price}}</span>\r\n\t\t\t\t\t\t\t\t<p-button icon=\"pi pi-shopping-cart\" label=\"Add to Cart\" [disabled]=\"product.inventoryStatus === 'OUTOFSTOCK'\" styleClass=\"mb-2 p-button-sm\"></p-button>\r\n\t\t\t\t\t\t\t\t<span [class]=\"'product-badge status-' + product.inventoryStatus.toLowerCase()\">{{product.inventoryStatus}}</span>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</ng-template>\r\n\r\n\t\t\t\t<ng-template let-products pTemplate=\"gridItem\">\r\n\t\t\t\t\t<div class=\"grid grid-nogutter\">\r\n\t\t\t\t\t<div class=\"col-12 md:col-4\" *ngFor=\"let product of products\">\r\n\t\t\t\t\t\t<div class=\"card m-3 border-1 surface-border\">\r\n\t\t\t\t\t\t\t<div class=\"flex flex-wrap gap-2 align-items-center justify-content-between mb-2\">\r\n\t\t\t\t\t\t\t\t<div class=\"flex align-items-center\">\r\n\t\t\t\t\t\t\t\t\t<i class=\"pi pi-tag mr-2\"></i>\r\n\t\t\t\t\t\t\t\t\t<span class=\"font-semibold\">{{product.category}}</span>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t<span [class]=\"'product-badge status-' + product.inventoryStatus.toLowerCase()\">{{product.inventoryStatus}}</span>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t<div class=\"flex flex-column align-items-center text-center mb-3\">\r\n\t\t\t\t\t\t\t\t<img [src]=\"'assets/demo/images/product/' + product.image\" [alt]=\"product.name\" class=\"w-9 shadow-2 my-3 mx-0\"/>\r\n\t\t\t\t\t\t\t\t<div class=\"text-2xl font-bold\">{{product.name}}</div>\r\n\t\t\t\t\t\t\t\t<div class=\"mb-3\">{{product.description}}</div>\r\n\t\t\t\t\t\t\t\t<p-rating [ngModel]=\"product.rating\" [readonly]=\"true\" [cancel]=\"false\"></p-rating>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t<div class=\"flex align-items-center justify-content-between\">\r\n\t\t\t\t\t\t\t\t<span class=\"text-2xl font-semibold\">${{product.price}}</span>\r\n\t\t\t\t\t\t\t\t<p-button icon=\"pi pi-shopping-cart\" [disabled]=\"product.inventoryStatus === 'OUTOFSTOCK'\"></p-button>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</ng-template>\r\n\t\t\t</p-dataView>\r\n\t\t</div>\r\n\t</div>\r\n\r\n\t<div class=\"col-12 xl:col-8\">\r\n\t\t<div class=\"card\">\r\n\t\t\t<h5>PickList</h5>\r\n\t\t\t<p-pickList [source]=\"sourceCities\" [target]=\"targetCities\" sourceHeader=\"From\" targetHeader=\"To\" [dragdrop]=\"true\"\r\n\t\t\t\t\t\t[responsive]=\"true\" [sourceStyle]=\"{'height':'250px'}\" [targetStyle]=\"{'height':'250px'}\">\r\n\t\t\t\t<ng-template let-city pTemplate=\"item\">\r\n\t\t\t\t\t<div>{{city.name}}</div>\r\n\t\t\t\t</ng-template>\r\n\t\t\t</p-pickList>\r\n\t\t</div>\r\n\t</div>\r\n\r\n\t<div class=\"col-12 xl:col-4\">\r\n\t\t<div class=\"card\">\r\n\t\t\t<h5>OrderList</h5>\r\n\t\t\t<p-orderList [value]=\"orderCities\" header=\"Cities\" [dragdrop]=\"true\" [listStyle]=\"{'height':'250px'}\">\r\n\t\t\t\t<ng-template let-city pTemplate=\"item\">\r\n\t\t\t\t\t<div>{{city.name}}</div>\r\n\t\t\t\t</ng-template>\r\n\t\t\t</p-orderList>\r\n\t\t</div>\r\n\t</div>\r\n</div>\r\n","import { Component, OnInit } from '@angular/core';\r\nimport { SelectItem } from 'primeng/api';\r\nimport { DataView } from 'primeng/dataview';\r\nimport { Product } from 'src/app/demo/api/product';\r\nimport { ProductService } from 'src/app/demo/service/product.service';\r\n\r\n@Component({\r\n    templateUrl: './listdemo.component.html'\r\n})\r\nexport class ListDemoComponent implements OnInit {\r\n\r\n    products: Product[] = [];\r\n\r\n    sortOptions: SelectItem[] = [];\r\n\r\n    sortOrder: number = 0;\r\n\r\n    sortField: string = '';\r\n\r\n    sourceCities: any[] = [];\r\n\r\n    targetCities: any[] = [];\r\n\r\n    orderCities: any[] = [];\r\n\r\n    constructor(private productService: ProductService) { }\r\n\r\n    ngOnInit() {\r\n        this.productService.getProducts().then(data => this.products = data);\r\n\r\n        this.sourceCities = [\r\n            { name: 'San Francisco', code: 'SF' },\r\n            { name: 'London', code: 'LDN' },\r\n            { name: 'Paris', code: 'PRS' },\r\n            { name: 'Istanbul', code: 'IST' },\r\n            { name: 'Berlin', code: 'BRL' },\r\n            { name: 'Barcelona', code: 'BRC' },\r\n            { name: 'Rome', code: 'RM' }];\r\n\r\n        this.targetCities = [];\r\n\r\n        this.orderCities = [\r\n            { name: 'San Francisco', code: 'SF' },\r\n            { name: 'London', code: 'LDN' },\r\n            { name: 'Paris', code: 'PRS' },\r\n            { name: 'Istanbul', code: 'IST' },\r\n            { name: 'Berlin', code: 'BRL' },\r\n            { name: 'Barcelona', code: 'BRC' },\r\n            { name: 'Rome', code: 'RM' }];\r\n\r\n        this.sortOptions = [\r\n            { label: 'Price High to Low', value: '!price' },\r\n            { label: 'Price Low to High', value: 'price' }\r\n        ];\r\n    }\r\n\r\n    onSortChange(event: any) {\r\n        const value = event.value;\r\n\r\n        if (value.indexOf('!') === 0) {\r\n            this.sortOrder = -1;\r\n            this.sortField = value.substring(1, value.length);\r\n        } else {\r\n            this.sortOrder = 1;\r\n            this.sortField = value;\r\n        }\r\n    }\r\n\r\n    onFilter(dv: DataView, event: Event) {\r\n        dv.filter((event.target as HTMLInputElement).value);\r\n    }\r\n    \r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { RouterModule } from '@angular/router';\r\nimport { ListDemoComponent } from './listdemo.component';\r\n\r\n@NgModule({\r\n\timports: [RouterModule.forChild([\r\n\t\t{ path: '', component: ListDemoComponent }\r\n\t])],\r\n\texports: [RouterModule]\r\n})\r\nexport class ListDemoRoutingModule { }\r\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { ListDemoComponent } from './listdemo.component';\r\nimport { ListDemoRoutingModule } from './listdemo-routing.module';\r\nimport { DataViewModule } from 'primeng/dataview';\r\nimport { PickListModule } from 'primeng/picklist';\r\nimport { OrderListModule } from 'primeng/orderlist';\r\nimport { InputTextModule } from 'primeng/inputtext';\r\nimport { DropdownModule } from 'primeng/dropdown';\r\nimport { RatingModule } from 'primeng/rating';\r\nimport { ButtonModule } from 'primeng/button';\r\n\r\n@NgModule({\r\n\timports: [\r\n\t\tCommonModule,\r\n\t\tFormsModule,\r\n\t\tListDemoRoutingModule,\r\n\t\tDataViewModule,\r\n\t\tPickListModule,\r\n\t\tOrderListModule,\r\n\t\tInputTextModule,\r\n\t\tDropdownModule,\r\n\t\tRatingModule,\r\n\t\tButtonModule\r\n\t],\r\n\tdeclarations: [ListDemoComponent]\r\n})\r\nexport class ListDemoModule { }\r\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}